<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2024/01/16/README/</url>
    <content><![CDATA[<p>大家好，这是hollis7的个人博客，用于记录学习的过程与心得。</p>
]]></content>
      <categories>
        <category>欢迎</category>
      </categories>
      <tags>
        <tag>welcome</tag>
        <tag>computer</tag>
        <tag>java learner</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis</title>
    <url>/2024/01/16/MyBatis/MyBatis/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="MyBaits中文网"><a href="#MyBaits中文网" class="headerlink" title="MyBaits中文网"></a>MyBaits中文网</h2><p><a href="https://mybatis.net.cn/">MyBatis</a></p>
<span id="more"></span>
<h2 id="MyBatis快速入门"><a href="#MyBatis快速入门" class="headerlink" title="MyBatis快速入门"></a>MyBatis快速入门</h2><ul>
<li><p>数据库表（tb_user）及数据准备</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database mybatis;</span><br><span class="line">use mybatis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user(</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">	username <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">	password <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">	gender <span class="type">char</span>(<span class="number">1</span>),</span><br><span class="line">	addr <span class="type">varchar</span>(<span class="number">30</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_user <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;北京&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_user <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;234&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;天津&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_user <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">&#x27;王五&#x27;</span>, <span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;西安&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入依赖，pom.xml，粘贴logback.xml到resource文件夹下</p>
</li>
<li><p>编写mybatis-config.xml文件</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--数据库连接信息--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///mybatis?useSSL=false&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hdb2205&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--加载sql映射文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>编写UserMapper.xml文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.ithdb.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from tb_user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>主程序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1. 加载mybatis的核心配置文件，获取 SqlSessionFactory</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 获取SqlSession对象，用它来执行sql</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 执行sql</span></span><br><span class="line">        List&lt;User&gt; users = sqlSession.selectList(<span class="string">&quot;test.selectAll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(users);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/01/12/71335_image-20240112095356363.png" alt="image-20240112095356363" style="zoom:50%;" /></p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/01/12/49567_image-20240112095507785.png" alt="image-20240112095507785" style="zoom: 50%;" /></p>
<p><strong>刷新一下可以看到数据库的表</strong></p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/01/12/47675_image-20240112095851919.png" alt="image-20240112095851919" style="zoom: 67%;" /></p>
<p><strong>idea中使用sql语句进行查询</strong></p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/01/12/57896_image-20240112100335351.png" alt="image-20240112100335351"></p>
<h2 id="使用Mapper代理方式完成入门案例"><a href="#使用Mapper代理方式完成入门案例" class="headerlink" title="使用Mapper代理方式完成入门案例"></a>使用Mapper代理方式完成入门案例</h2><ol>
<li>定义与SQL映射文件同名的Mapperf接口，并且将Mapper接口和SQL映射文件放置在同一目录下</li>
</ol>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/01/12/70576_image-20240112102522431.png" alt="image-20240112102522431"></p>
<p>这里一定要用<code>com/inhdb/mapper</code>创建包，而不是<code>com.inhdb.mapper</code>，否则编译后没有文件夹层次结构，只是一个<code>com.inhdb.mapper</code>文件</p>
<ol>
<li>设置SQL映射文件的namespace属性为Mapper接口全限定名</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;mapper namespace=<span class="string">&quot;com.ithdb.mapper.UserMapper&quot;</span>&gt;</span><br><span class="line">    &lt;select id=<span class="string">&quot;selectAll&quot;</span> resultType=<span class="string">&quot;com.ithdb.pojo.User&quot;</span>&gt;</span><br><span class="line">        select *</span><br><span class="line">        from tb_user;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>在Mapper接口中定义方法，方法名就是SQL映射文件中sql语句的id,并保持参数类型和返回值类型一致</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>修改mybatis-config.xml的UserMapper.xml地址</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--加载sql映射文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/ithdb/mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>编码</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//3.1 获取UserMapper接口的代理对象</span></span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">List&lt;User&gt; users = userMapper.selectAll();</span><br></pre></td></tr></table></figure>
<h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>只要遵循了<code>Mapper接口和SQL映射文件放置在同一目录下</code>（编译过后在同一目录下），就可以用包扫描的方法进行配置</p>
<p><code>mybatis-config.xml</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">    &lt;!--Mapper代理方式，识别到sql映射文件--&gt;</span><br><span class="line">   &lt;<span class="keyword">package</span> name=<span class="string">&quot;com.ithdb.mapper&quot;</span>/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure>
<h2 id="MyBatis核心配置文件"><a href="#MyBatis核心配置文件" class="headerlink" title="MyBatis核心配置文件"></a>MyBatis核心配置文件</h2><h3 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h3><p>environments：配置数据库连接环境信息。可以配置多个environment，通过default属性切换不同的environment</p>
<h3 id="typeAliases"><a href="#typeAliases" class="headerlink" title="typeAliases"></a>typeAliases</h3><p>指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.ithdb.pojo&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>为com.ithdb.pojo目录下的实体取别名，默认小写如：user</p>
<p><code>UserMapper.xml</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;selectAll&quot;</span> resultType=<span class="string">&quot;user&quot;</span>&gt;</span><br><span class="line">       select *</span><br><span class="line">       from tb_user;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<h2 id="增删改查环境准备"><a href="#增删改查环境准备" class="headerlink" title="增删改查环境准备"></a>增删改查环境准备</h2><p>准备tb_brand(mybatis数据库下)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除tb_brand表</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_brand;</span><br><span class="line"><span class="comment">-- 创建tb_brand表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_brand</span><br><span class="line">(</span><br><span class="line">    <span class="comment">-- id 主键</span></span><br><span class="line">    id           <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    <span class="comment">-- 品牌名称</span></span><br><span class="line">    brand_name   <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="comment">-- 企业名称</span></span><br><span class="line">    company_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="comment">-- 排序字段</span></span><br><span class="line">    ordered      <span class="type">int</span>,</span><br><span class="line">    <span class="comment">-- 描述信息</span></span><br><span class="line">    description  <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="comment">-- 状态：0：禁用  1：启用</span></span><br><span class="line">    status       <span class="type">int</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 添加数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_brand (brand_name, company_name, ordered, description, status)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;三只松鼠&#x27;</span>, <span class="string">&#x27;三只松鼠股份有限公司&#x27;</span>, <span class="number">5</span>, <span class="string">&#x27;好吃不上火&#x27;</span>, <span class="number">0</span>),</span><br><span class="line">       (<span class="string">&#x27;华为&#x27;</span>, <span class="string">&#x27;华为技术有限公司&#x27;</span>, <span class="number">100</span>, <span class="string">&#x27;华为致力于把数字世界带入每个人、每个家庭、每个组织，构建万物互联的智能世界&#x27;</span>, <span class="number">1</span>),</span><br><span class="line">       (<span class="string">&#x27;小米&#x27;</span>, <span class="string">&#x27;小米科技有限公司&#x27;</span>, <span class="number">50</span>, <span class="string">&#x27;are you ok&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_brand;</span><br></pre></td></tr></table></figure>
<h3 id="大小驼峰解决方案"><a href="#大小驼峰解决方案" class="headerlink" title="大小驼峰解决方案"></a>大小驼峰解决方案</h3><p>springboot有更好的方案</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;brandResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;brand&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;brand_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;brandName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;company_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;companyName&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from tb_brand;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="查看详情"><a href="#查看详情" class="headerlink" title="查看详情"></a>查看详情</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        * 参数占位符：</span></span><br><span class="line"><span class="comment">            1. #&#123;&#125;:会将其替换为 ?，为了防止SQL注入</span></span><br><span class="line"><span class="comment">            2. $&#123;&#125;：拼sql。会存在SQL注入问题</span></span><br><span class="line"><span class="comment">            3. 使用时机：</span></span><br><span class="line"><span class="comment">                * 参数传递的时候：#&#123;&#125;</span></span><br><span class="line"><span class="comment">                * 表名或者列名不固定的情况下：$&#123;&#125; 会存在SQL注入问题</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         * 参数类型：parameterType：可以省略</span></span><br><span class="line"><span class="comment">         * 特殊字符处理：</span></span><br><span class="line"><span class="comment">            1. 转义字符：</span></span><br><span class="line"><span class="comment">            2. CDATA区:</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">        select *</span><br><span class="line">        from tb_brand</span><br><span class="line">        where id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="特殊字符转义"><a href="#特殊字符转义" class="headerlink" title="特殊字符转义"></a>特殊字符转义</h3><p>法一，转义：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">        select *</span><br><span class="line">        from tb_brand</span><br><span class="line">        where id <span class="symbol">&amp;lt;</span> #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如&lt;对应<code>&amp;lt;</code></p>
<p>法二，CDATA</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">        select *</span><br><span class="line">        from tb_brand</span><br><span class="line">        where id</span><br><span class="line">            &lt;![CDATA[</span><br><span class="line">            &lt;</span><br><span class="line">            ]]&gt;</span><br><span class="line">            #&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 条件查询</span><br><span class="line">    * * 参数接收</span><br><span class="line">    * 1. 散装参数：如果方法中有多个参数，需要使用@Param(&quot;SQL参数占位符名称&quot;)</span><br><span class="line">    * 2. 对象参数:对象的属性名称要和参数占位符名称一致</span><br><span class="line">    * 3. map集合参数</span><br><span class="line">    */</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">companyName</span> <span class="operator">=</span> <span class="string">&quot;华为&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">brandName</span> <span class="operator">=</span> <span class="string">&quot;华为&quot;</span>;</span><br><span class="line"><span class="comment">// 处理参数</span></span><br><span class="line">companyName = <span class="string">&quot;%&quot;</span> + companyName + <span class="string">&quot;%&quot;</span>;</span><br><span class="line">brandName = <span class="string">&quot;%&quot;</span> + brandName + <span class="string">&quot;%&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//封装对象</span></span><br><span class="line"><span class="comment">//        Brand brand = new Brand();</span></span><br><span class="line"><span class="comment">//        brand.setStatus(status);</span></span><br><span class="line"><span class="comment">//        brand.setCompanyName(companyName);</span></span><br><span class="line"><span class="comment">//        brand.setBrandName(brandName);</span></span><br><span class="line"></span><br><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(<span class="string">&quot;status&quot;</span>, status);</span><br><span class="line">map.put(<span class="string">&quot;companyName&quot;</span>, companyName);</span><br><span class="line">map.put(<span class="string">&quot;brandName&quot;</span>, brandName);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//    List&lt;Brand&gt; selectByCondition(@Param(&quot;status&quot;) int status, @Param(&quot;companyName&quot;) String companyName, @Param(&quot;brandName&quot;) String brandName);</span></span><br><span class="line"><span class="comment">//    List&lt;Brand&gt; selectByCondition(Brand brand);</span></span><br><span class="line">    List&lt;Brand&gt; <span class="title function_">selectByCondition</span><span class="params">(Map map)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="动态多条件查询"><a href="#动态多条件查询" class="headerlink" title="动态多条件查询"></a>动态多条件查询</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">       动态条件查询</span></span><br><span class="line"><span class="comment">           * if: 条件判断</span></span><br><span class="line"><span class="comment">               * test：逻辑表达式</span></span><br><span class="line"><span class="comment">           * 问题：</span></span><br><span class="line"><span class="comment">               * 恒等式</span></span><br><span class="line"><span class="comment">               * &lt;where&gt; 替换 where 关键字</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByCondition&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from tb_brand</span><br><span class="line">    where</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;status!=null&quot;</span>&gt;</span></span><br><span class="line">        status = #&#123;status&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;companyName!=null and companyName!=&#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">        and company_name like #&#123;companyName&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;brandName!=null and brandName!=&#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">        and brand_name like #&#123;brandName&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果第一个status后面参数不为空就会存在sql语法错误</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByCondition&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span></span><br><span class="line">       select *</span><br><span class="line">       from tb_brand</span><br><span class="line">       /* where 1=1 */</span><br><span class="line">       <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;status!=null&quot;</span>&gt;</span></span><br><span class="line">               and status = #&#123;status&#125;</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;companyName!=null and companyName!=&#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">               and company_name like #&#123;companyName&#125;</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;brandName!=null and brandName!=&#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">               and brand_name like #&#123;brandName&#125;</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>存在无参数全查询问题</p>
</blockquote>
<h2 id="单条件动态查询"><a href="#单条件动态查询" class="headerlink" title="单条件动态查询"></a>单条件动态查询</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;selectByConditionSingle&quot;</span> resultMap=<span class="string">&quot;brandResultMap&quot;</span>&gt;</span><br><span class="line">    select *</span><br><span class="line">    from tb_brand</span><br><span class="line">    where</span><br><span class="line">    &lt;choose&gt;&lt;!--相当于<span class="keyword">switch</span>--&gt;</span><br><span class="line">        &lt;when test=<span class="string">&quot;status!=null&quot;</span>&gt;&lt;!--相当于<span class="keyword">case</span>--&gt;</span><br><span class="line">            status = #&#123;status&#125;</span><br><span class="line">        &lt;/when&gt;</span><br><span class="line">        &lt;when test=<span class="string">&quot;companyName!=null and companyName!=&#x27;&#x27;&quot;</span>&gt;</span><br><span class="line">            company_name like #&#123;companyName&#125;</span><br><span class="line">        &lt;/when&gt;</span><br><span class="line">        &lt;when test=<span class="string">&quot;brandName != null and brandName != &#x27;&#x27;&quot;</span>&gt;&lt;!--相当于<span class="keyword">case</span>--&gt;</span><br><span class="line">            brand_name like #&#123;brandName&#125;</span><br><span class="line">        &lt;/when&gt;</span><br><span class="line">        &lt;otherwise&gt;</span><br><span class="line">            <span class="number">1</span>=<span class="number">1</span></span><br><span class="line">        &lt;/otherwise&gt;</span><br><span class="line">    &lt;/choose&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p>otherwise可以通过<code>&lt;where&gt;</code>包裹进行替换</p>
<h2 id="添加或者修改"><a href="#添加或者修改" class="headerlink" title="添加或者修改"></a>添加或者修改</h2><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><p>BrandMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span>&gt;</span></span><br><span class="line">        insert into tb_brand (brand_name, company_name, ordered, description, status)</span><br><span class="line">        values (#&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;, #&#123;description&#125;, #&#123;status&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意需要提交或者开始处开启自动提交</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//3. 获取Mapper接口的代理对象</span></span><br><span class="line"><span class="type">BrandMapper</span> <span class="variable">brandMapper</span> <span class="operator">=</span> sqlSession.getMapper(BrandMapper.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 执行方法</span></span><br><span class="line">brandMapper.add(brand);</span><br><span class="line"><span class="comment">//提交事务,否则插入的数据会回滚</span></span><br><span class="line">sqlSession.commit();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//2. 获取SqlSession对象</span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<h3 id="添加项获取主键如id值"><a href="#添加项获取主键如id值" class="headerlink" title="添加项获取主键如id值"></a>添加项获取主键如id值</h3><p>使用useGeneratedKeys、keyProperty绑定插入数据的主键到id</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    insert into tb_brand (brand_name, company_name, ordered, description, status)</span><br><span class="line">    values (#&#123;brandName&#125;, #&#123;companyName&#125;, #&#123;ordered&#125;, #&#123;description&#125;, #&#123;status&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4. 执行方法</span></span><br><span class="line">brandMapper.add(brand);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> brand.getId();</span><br><span class="line">System.out.println(id);</span><br></pre></td></tr></table></figure>
<h2 id="修改-动态"><a href="#修改-动态" class="headerlink" title="修改-动态"></a>修改-动态</h2><p>使用set标签避免sql参数不全，多“，”造成语法错误</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span>&gt;</span></span><br><span class="line">    update tb_brand</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;brandName != null and brandName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            brand_name = #&#123;brandName&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;companyName != null and companyName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            company_name = #&#123;companyName&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ordered != null&quot;</span>&gt;</span></span><br><span class="line">            ordered = #&#123;ordered&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;description != null and description != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            description = #&#123;description&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;status != null&quot;</span>&gt;</span></span><br><span class="line">            status = #&#123;status&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    where id=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="单个"><a href="#单个" class="headerlink" title="单个"></a>单个</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteById&quot;</span>&gt;</span></span><br><span class="line">    delete</span><br><span class="line">    from tb_brand</span><br><span class="line">    where id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h3><p>sql原语</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb_brand <span class="keyword">where</span> id <span class="keyword">in</span> (?,?,?);</span><br></pre></td></tr></table></figure>
<p>mybatis改写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">deleteByIds</span><span class="params">(<span class="meta">@Param(&quot;ids&quot;)</span> <span class="type">int</span>[] ids)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        mybatis会将数组参数，封装为一个Map集合。</span></span><br><span class="line"><span class="comment">            * 默认：array = 数组</span></span><br><span class="line"><span class="comment">            * 使用@Param注解改变map集合的默认key的名称</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByIds&quot;</span>&gt;</span></span><br><span class="line">    delete</span><br><span class="line">    from tb_brand</span><br><span class="line">    where id in (</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    )</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>separator的目的是为了分隔多个id</p>
<p>还可以将where id in (?,?,?)中的括号用这种形式改变</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">    #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p><strong>多个参数：封装为Map集合,可以使用@Param注解，替换Map集合中默认的arg键名</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User <span class="title function_">select</span><span class="params">(<span class="meta">@Param(&quot;username&quot;)</span> String username, <span class="meta">@Param(&quot;password&quot;)</span> String password)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h2><p>简单的sql语句用注解，复杂的用xml配置方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from tb_user where id = #&#123;id&#125;;&quot;)</span></span><br><span class="line">User <span class="title function_">selectById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="springboot3使用MyBatis"><a href="#springboot3使用MyBatis" class="headerlink" title="springboot3使用MyBatis"></a>springboot3使用MyBatis</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>1、用spring initial创建module</p>
<p>2、选中初始依赖</p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/01/14/61655_image-20240114212007854.png" alt="image-20240114212007854"></p>
<p><code>MyBatis Framework</code>和<code>MySQL Driver</code>在SQL的依赖中</p>
<p>3、<code>application.properties</code>配置数据源</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.type</span>=<span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">hdb2205</span></span><br></pre></td></tr></table></figure>
<p>4、创建pojo类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TUser</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String loginName;</span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="keyword">private</span> String passwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、创建一个接口<code>UserMapper</code>，resource文件夹下创建<code>mapper</code>文件夹，利用MybatisX这个插件生产<code>UserMapper.xml</code>文件（选中接口点击 more actions，选中生产xml，选中xml文件生成的位置）</p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/01/14/28490_image-20240114213800163.png" alt="image-20240114213800163"></p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/01/14/43338_image-20240114213851958.png" alt="image-20240114213851958"></p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/01/14/98218_image-20240114214002500.png" alt="image-20240114214002500"></p>
<p>6、在接口中编辑方法，利用插件自动生成statement</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TUser <span class="title function_">getUserById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hdb.boot3mybatis.bean.TUser&quot;</span>&gt;</span></span><br><span class="line">        select *</span><br><span class="line">        from t_user</span><br><span class="line">        where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>7、主程序中加入<code>MapperScan</code>，扫描接口包的位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MapperScan(basePackages = &quot;com/hdb/boot3mybatis/mapper&quot;)</span></span><br></pre></td></tr></table></figure>
<p>8、配置xxxmapper.xml的位置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis.mapper-locations</span>=<span class="string">classpath:/mapper/*.xml</span></span><br></pre></td></tr></table></figure>
<p>9、配置驼峰命名</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>spirng6知识小点</title>
    <url>/2024/01/16/spring6/spring6_1/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="启用Log4j2日志框架"><a href="#启用Log4j2日志框架" class="headerlink" title="启用Log4j2日志框架"></a>启用Log4j2日志框架</h2><p><strong>（1）日志信息的优先级</strong>，日志信息的优先级从高到低有<strong>TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL</strong><br>                TRACE：追踪，是最低的日志级别，相当于追踪程序的执行<br>                DEBUG：调试，一般在开发中，都将其设置为最低的日志级别<br>                INFO：信息，输出重要的信息，使用较多<br>                WARN：警告，输出警告的信息<br>                ERROR：错误，输出错误信息<br>                FATAL：严重错误</p>
<span id="more"></span>
<p>这些级别分别用来指定这条日志信息的重要程度；级别高的会自动屏蔽级别低的日志，也就是说，设置了WARN的日志，则INFO、DEBUG的日志级别的日志不会显示</p>
<p><strong>（2）日志信息的输出目的地</strong>，日志信息的输出目的地指定了日志将打印到<strong>控制台</strong>还是<strong>文件中</strong>；</p>
<p><strong>（3）日志信息的输出格式</strong>，而输出格式则控制了日志信息的显示内容。</p>
<p>CryptoNets: Applying Neural Networks to Encrypted Data with High Throughput and Accuracy</p>
<h2 id="AOP概念及相关术语"><a href="#AOP概念及相关术语" class="headerlink" title="AOP概念及相关术语"></a>AOP概念及相关术语</h2><p>AOP（Aspect Oriented Programming）是一种设计思想，是软件设计领域中的面向切面编程，它是面向对象编程的一种补充和完善<strong>，它以通过预编译方式和运行期动态代理方式实现，在不修改源代码的情况下，给程序动态统一添加额外功能的一种技术</strong>。</p>
]]></content>
      <categories>
        <category>spring6</category>
      </categories>
      <tags>
        <tag>spring6</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习</title>
    <url>/2024/01/16/git%E5%AD%A6%E4%B9%A0/git_notes/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="初始化设置"><a href="#初始化设置" class="headerlink" title="初始化设置"></a>初始化设置</h2><p>配置⽤户名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;hollis7&quot;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>配置邮箱</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.email <span class="string">&quot;herryhollis@163.com&quot;</span></span><br></pre></td></tr></table></figure>
<p>查看配置信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure>
<blockquote>
<p>user.name=hollis<br>user.email=herryhollis@163.com<br>http.proxy=<a href="http://127.0.0.1:7890">http://127.0.0.1:7890</a><br>https.proxy=<a href="https://127.0.0.1:7890">https://127.0.0.1:7890</a></p>
</blockquote>
<h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>创建⼀个新的本地仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>当前目录下指定一个仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init my-repo</span><br></pre></td></tr></table></figure>
<p>查看.git信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -altr</span><br><span class="line"><span class="built_in">ls</span> -al</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">total 8</span><br><span class="line">drwxr-xr-x 1 hdb22 197610 0 Nov 29 16:58 ../</span><br><span class="line">drwxr-xr-x 1 hdb22 197610 0 Nov 29 16:58 ./</span><br><span class="line">drwxr-xr-x 1 hdb22 197610 0 Nov 29 16:58 .git/</span><br></pre></td></tr></table></figure>
<p>克隆⼀个远程仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;url&gt;</span><br></pre></td></tr></table></figure>
<h2 id="四个区域"><a href="#四个区域" class="headerlink" title="四个区域"></a>四个区域</h2><p><strong>工作区(Working Directory)</strong><br>就是你在电脑里能实际看到的目录。</p>
<p><strong>暂存区（Stage/Index）</strong><br>暂存区也叫索引? ⽤来临时存放未提交的内容。 ⼀般在.git⽬录下的index中。</p>
<p><strong>本地仓库(Repository)</strong><br>Git在本地的版本库，仓库信息存储在.git这个隐藏目录中。</p>
<p><strong>远程仓库(Remote Repository)</strong><br>托管在远程服务器上的仓库。常用的有GitHub、GitLab、Gitee。</p>
<h2 id="添加和提交"><a href="#添加和提交" class="headerlink" title="添加和提交"></a>添加和提交</h2><p>提交以.txt结尾的文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add *.txt</span><br></pre></td></tr></table></figure>
<p>提交记录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 965946e2d53df2d211bb4fa9ff357007815f9c3e (HEAD -&gt; master)</span><br><span class="line">Author: hollis &lt;herryhollis@163.com&gt;</span><br><span class="line">Date:   Wed Nov 29 17:20:58 2023 +0800</span><br><span class="line"></span><br><span class="line">    second commit</span><br><span class="line"></span><br><span class="line">commit fccd50cb2e25533a639b4bc6ef4fa0d6c4225de6</span><br><span class="line">Author: hollis &lt;herryhollis@163.com&gt;</span><br><span class="line">Date:   Wed Nov 29 17:14:23 2023 +0800</span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>简洁日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br></pre></td></tr></table></figure>
<h2 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h2><p><img src="C:\data\mysoftware\Typora\typoraPicture\image-20231129172540607.png" alt="image-20231129172540607" style="zoom: 25%;" /></p>
<h3 id="soft"><a href="#soft" class="headerlink" title="soft"></a>soft</h3><p>查看版本id</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br><span class="line">837739d (HEAD -&gt; master) 3</span><br><span class="line">e4b3f38 2</span><br><span class="line">8ef07df 1</span><br></pre></td></tr></table></figure>
<p>回退到指定版本id：<code>e4b3f38</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --soft e4b3f38</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">e4b3f38 (HEAD -&gt; master) 2</span><br><span class="line">8ef07df 1</span><br></pre></td></tr></table></figure>
<p>查看暂存区的内容，<code>file3.txt</code>仍在</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git ls-files</span><br><span class="line">file1.txt</span><br><span class="line">file2.txt</span><br><span class="line">file3.txt</span><br></pre></td></tr></table></figure>
<h3 id="hard"><a href="#hard" class="headerlink" title="hard"></a>hard</h3><p>回退到上一个版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure>
<blockquote>
<p>工作区和暂存区的file3.txt均不存在</p>
</blockquote>
<ul>
<li>[ ] 工作区</li>
<li>[ ] 暂存区</li>
</ul>
<h3 id="mixed"><a href="#mixed" class="headerlink" title="mixed"></a>mixed</h3><p>回退到上一个版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset HEAD^</span><br></pre></td></tr></table></figure>
<ul>
<li>[x] 工作区</li>
<li>[ ] 暂存区</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --soft <span class="built_in">id</span></span><br><span class="line">git reset --hard HEAD^</span><br><span class="line">git reset HEAD^</span><br></pre></td></tr></table></figure>
<p>常用<code>git reset HEAD^</code>和<code>git reset --soft id</code></p>
<p>:anger:慎用<code>git reset --hard HEAD^</code></p>
<h2 id="误操作"><a href="#误操作" class="headerlink" title="误操作"></a>误操作</h2><p>查看操作，回退到误操作之前：837739d</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">e4b3f38 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to HEAD^</span><br><span class="line">837739d HEAD@&#123;1&#125;: commit: 3</span><br><span class="line">e4b3f38 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: 2</span><br><span class="line">8ef07df HEAD@&#123;3&#125;: commit (initial): 1</span><br></pre></td></tr></table></figure>
<p>回退</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset 837739d</span><br></pre></td></tr></table></figure>
<h2 id="查看差异"><a href="#查看差异" class="headerlink" title="查看差异"></a>查看差异</h2><ol>
<li>查看工作区和暂存区的差异</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/11/29/93054_image-20231129201440960.png" alt="image-20231129201440960"></p>
<p>这里add一下，工作区和暂存区保持一致</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
<ol>
<li>比较工作区和版本库之间的差异</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff <span class="built_in">head</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/11/29/67476_image-20231129202024642.png" alt="image-20231129202024642"></p>
<ol>
<li>比较暂存区和版本库之间的差异</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/11/29/55545_image-20231129202403474.png" alt="image-20231129202403474"></p>
<ol>
<li>比较两个版本内容</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff 837739d e4b3f38</span><br><span class="line">git diff <span class="built_in">head</span> 837739d</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/11/29/13924_image-20231129203139207.png" alt="image-20231129203139207"></p>
<ol>
<li>最新两个版本之间</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff <span class="built_in">head</span>~ <span class="built_in">head</span></span><br></pre></td></tr></table></figure>
<p><code>head~</code>表示最新版本的上一版本，<code>head^</code>同理</p>
<p><code>head~2</code>表示head之前的2个版本</p>
<ol>
<li>查看指定文件版本之间的差异</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff <span class="built_in">head</span>~ <span class="built_in">head</span> file3.txt</span><br></pre></td></tr></table></figure>
<h2 id="git-rm删除文件"><a href="#git-rm删除文件" class="headerlink" title="git rm删除文件"></a>git rm删除文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> file1.txt</span><br></pre></td></tr></table></figure>
<p>暂存区中的内容没有被删掉</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git ls-files</span><br><span class="line">file1.txt</span><br><span class="line">file2.txt</span><br><span class="line">file3.txt</span><br></pre></td></tr></table></figure>
<p>需要add 和commit</p>
<h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h3><p>直接删除工作区和暂存区中的文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">rm</span> file2.txt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最后还是要提交，否则删除的文件还是在版本库中</p>
</blockquote>
<h3 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h3><p>递归删除某个目录下的所有子目录和文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">rm</span> -r *</span><br></pre></td></tr></table></figure>
<h2 id="学习-gitigonore"><a href="#学习-gitigonore" class="headerlink" title="学习.gitigonore"></a>学习.gitigonore</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;some log&quot;</span> &gt; access.log</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;other log &quot;</span> &gt; other.log</span><br></pre></td></tr></table></figure>
<p>将access.log放入<code>.gitigonore</code>文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> access.log &gt; .gitignore</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/11/29/13517_image-20231129205548067.png" alt="image-20231129205548067"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;ignore and other files&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="忽略所有日志文件"><a href="#忽略所有日志文件" class="headerlink" title="忽略所有日志文件"></a>忽略所有日志文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim .gitignore</span><br><span class="line">*.<span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<p>输入：<code>*.log</code>然后<code>wq</code>保存</p>
<h3 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> hello &gt; hello.log</span><br><span class="line">git status</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/11/29/38701_image-20231129210211915.png" alt="image-20231129210211915"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -am <span class="string">&quot;test ignore log&quot;</span></span><br><span class="line">git ls-files</span><br></pre></td></tr></table></figure>
<p>没有 <code>hello.log</code></p>
<h3 id="测试已经提交的other-log"><a href="#测试已经提交的other-log" class="headerlink" title="测试已经提交的other.log"></a>测试已经提交的other.log</h3><p>追加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot; modified&quot;</span> &gt;&gt; other.log</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   other.log</span><br></pre></td></tr></table></figure>
<p><code>.gitigonore</code>对已经添加的不能起作用</p>
<h3 id="删除暂存区的other-log"><a href="#删除暂存区的other-log" class="headerlink" title="删除暂存区的other.log"></a>删除暂存区的other.log</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached other.log</span><br></pre></td></tr></table></figure>
<ul>
<li>[ ] 暂存区</li>
<li>[x] 本地</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -am <span class="string">&quot;delete other.log&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>git commit -am &quot;delete other.log&quot;</code> 这个命令的作用是将所有已跟踪的文件的修改提交到版本库，并且使用 “delete other.log” 作为提交的消息。</p>
<p>需要注意的是，这种方式只适用于已经被 Git 跟踪的文件。对于新添加的文件，还是需要使用 <code>git add</code> 将其添加到暂存区，然后再使用 <code>git commit -m &quot;message&quot;</code> 提交。</p>
</blockquote>
<h3 id="忽略文件夹"><a href="#忽略文件夹" class="headerlink" title="忽略文件夹"></a>忽略文件夹</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; temp/hello.txt</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim .gitignore</span><br><span class="line">//追加temp/</span><br><span class="line">temp/</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> git add .</span><br><span class="line"> git commit -m <span class="string">&quot;test ignore fold&quot;</span></span><br><span class="line"> git ls-files</span><br><span class="line"> </span><br><span class="line"> $ git ls-files</span><br><span class="line">.gitignore</span><br><span class="line">file3.txt</span><br></pre></td></tr></table></figure>
<h2 id="关联本地仓库和远程仓库"><a href="#关联本地仓库和远程仓库" class="headerlink" title="关联本地仓库和远程仓库"></a>关联本地仓库和远程仓库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:Hollis7/git_testrepo.git</span><br><span class="line">git branch -M main</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>
<p>在GitHub上添加readme文件</p>
<p>本地仓库拉取远程仓库的修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add &lt;remote-name&gt; &lt;remote-url&gt;</span><br><span class="line">//添加远程仓库</span><br><span class="line">git remote -v</span><br><span class="line">//查看远程仓库?</span><br></pre></td></tr></table></figure>
<h2 id="⽂件状态"><a href="#⽂件状态" class="headerlink" title="⽂件状态"></a>⽂件状态</h2><ul>
<li>main/master 默认主分⽀</li>
<li>Origin 默认远程仓库</li>
<li>HEAD 指向当前分⽀的指针</li>
<li>HEAD^ 上⼀个版本</li>
<li>HEAD~ 上四个版本</li>
</ul>
<h2 id="vscode中使用git"><a href="#vscode中使用git" class="headerlink" title="vscode中使用git"></a>vscode中使用git</h2><p>在git中打开vscode</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">code .</span><br></pre></td></tr></table></figure>
<h2 id="分支简介和基本操作"><a href="#分支简介和基本操作" class="headerlink" title="分支简介和基本操作"></a>分支简介和基本操作</h2><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>
<h3 id="创建新的分支"><a href="#创建新的分支" class="headerlink" title="创建新的分支"></a>创建新的分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch dev</span><br></pre></td></tr></table></figure>
<p>查看分支，默认分支仍然为<code>master</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> git branch</span><br><span class="line">  dev</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>
<h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout dev（不建议，存在歧义）</span><br><span class="line">git switch master（建议）</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch <span class="string">&#x27;dev&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git switch master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="merge合并"><a href="#merge合并" class="headerlink" title="merge合并"></a>merge合并</h2><p>在<code>dev</code>分支下创建<code>dev1.txt dev2.txt</code>，并提交，在<code>master</code>分支下查看，并没有<code>dev1.txt dev2.txt</code></p>
<p>在创建main4.txt和main5.txt看到明显的分叉</p>
<p>:memo:合并分支,将<code>dev</code>分支合并到<code>master</code>（当前）分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hdb22@hollis7 MINGW64 /c/individualproject/git-learn/branch-demo (master)</span><br><span class="line">$ git merge dev</span><br></pre></td></tr></table></figure>
<p>查看分支图</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph --oneline --decorate --all</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --oneline --decorate --all</span><br><span class="line">*   554c860 (HEAD -&gt; master) Merge branch <span class="string">&#x27;dev&#x27;</span></span><br><span class="line">|\</span><br><span class="line">| * 01f908c (dev) dev:2</span><br><span class="line">| * 0db7fa1 dev:1</span><br><span class="line">* | 7e18db1 main:5</span><br><span class="line">* | 5d73401 main:4</span><br><span class="line">|/</span><br><span class="line">* 185b91e main:3</span><br><span class="line">* 823dd12 main:2</span><br><span class="line">* 262a6df main:1</span><br></pre></td></tr></table></figure>
<h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>合并后分支仍然存在，可以删除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure>
<p><code>-d</code>表示删除已经合并的分支</p>
<p><code>-D</code>表示强制删除</p>
<h2 id="合并分支解决冲突"><a href="#合并分支解决冲突" class="headerlink" title="合并分支解决冲突"></a>合并分支解决冲突</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch feat</span><br><span class="line">git swich feat</span><br><span class="line">vim main1.txt</span><br></pre></td></tr></table></figure>
<p>在<code>feat</code>分支下提交修改的main1.txt</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -a -m <span class="string">&quot;feat:1&quot;</span></span><br></pre></td></tr></table></figure>
<p>切回<code>master</code>分支，<code>main1.txt</code>的内容不变</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git switch master</span><br><span class="line"><span class="built_in">cat</span> main1.txt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>main1</p>
</blockquote>
<p>修改<code>main1.txt</code>并保存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim main1.txt</span><br><span class="line">git commit -am <span class="string">&quot;main:6&quot;</span></span><br></pre></td></tr></table></figure>
<p>:memo:<strong>直接合并出现冲突</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git merge feat</span><br><span class="line">Auto-merging main1.txt</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> main1.txt</span><br><span class="line">Automatic merge failed;fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure>
<p>使用<code>git diff</code>查看冲突内容</p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/12/01/66112_image-20231201153625765.png" alt="image-20231201153625765"></p>
<p><strong>手动修改main.txt文件，然后提交</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim main1.txt</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;merge conflict&quot;</span></span><br></pre></td></tr></table></figure>
<p>提交之前中断合并可以使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge --absort</span><br></pre></td></tr></table></figure>
<h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><ol>
<li>为了便于演示，先删除feat分支</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d feat</span><br></pre></td></tr></table></figure>
<ol>
<li>恢复dev分支</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b dev 01f908c</span><br></pre></td></tr></table></figure>
<p><code>01f908c</code>是提交dev2.txt的id</p>
<ol>
<li>切回master，并reset到状态提交<code>main.5</code>的状态</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git swtich master</span><br><span class="line">git reset --hard 7e18db1</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/12/01/64965_image-20231201155844275.png" alt="image-20231201155844275" style="zoom:67%;" /></p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/01/16/10240_image-20231201160041852.png" alt="image-20231201160041852" style="zoom: 67%;" /></p>
<ol>
<li><strong>回退目录，copy两次branch-demo分别演示</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> -rf branch-demo rebase1</span><br><span class="line"><span class="built_in">cp</span> -rf branch-demo rebase2</span><br></pre></td></tr></table></figure>
<ol>
<li>rebase1文件夹下，切换到<code>dev</code>分支进行<code>rebase</code>，dev变基到master</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git switch dev</span><br><span class="line">git rebase master</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/12/01/84395_image-20231201160653932.png" alt="image-20231201160653932" style="zoom: 67%;" /></p>
<ol>
<li>rebase2文件夹下，切换到<code>master</code>分支进行<code>rebase</code>，master变基到dev</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase dev</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/12/01/70958_image-20231201161355387.png" alt="image-20231201161355387" style="zoom:67%;" /></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>只是想要merge，不关系历史采用rebase（个人开发，清晰明了）</p>
<p>共享分支采用merge，不然会给别人带来困扰</p>
<h2 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h2><p>定义命令别名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> graph=<span class="string">&quot;git log --oneline --graph --decorate --all&quot;</span></span><br></pre></td></tr></table></figure>
<p>输入<code>graph</code>直接查看图像和提交记录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ graph</span><br><span class="line">*   9d6c599 (master) merge conflict</span><br><span class="line">|\</span><br><span class="line">| * 55416ce feat:1</span><br><span class="line">* | 5b8f4ef main:6</span><br><span class="line">|/</span><br><span class="line">*   554c860 Merge branch <span class="string">&#x27;dev&#x27;</span></span><br><span class="line">|\</span><br><span class="line">| * 01f908c (HEAD -&gt; dev) dev:2</span><br><span class="line">| * 0db7fa1 dev:1</span><br><span class="line">* | 7e18db1 main:5</span><br><span class="line">* | 5d73401 main:4</span><br><span class="line">|/</span><br><span class="line">* 185b91e main:3</span><br><span class="line">* 823dd12 main:2</span><br><span class="line">* 262a6df main:1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>redis_2</title>
    <url>/2024/01/18/redis/redis_2/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="内容包括"><a href="#内容包括" class="headerlink" title="内容包括"></a>内容包括</h2><ul>
<li>redis java 客户端</li>
<li>SpringDataRedis</li>
<li>自定义序列化</li>
<li>手动序列化</li>
</ul>
<span id="more"></span>
<h2 id="redis的java客户端"><a href="#redis的java客户端" class="headerlink" title="redis的java客户端"></a>redis的java客户端</h2><p>在Redis官网中提供了各种语言的客户端，地址：<a href="https://redis.io/docs/clients/">https://redis.io/docs/clients/</a></p>
<h2 id="Jedis客户端"><a href="#Jedis客户端" class="headerlink" title="Jedis客户端"></a>Jedis客户端</h2><p>Jedis的官网地址： <a href="https://github.com/redis/jedis">https://github.com/redis/jedis</a></p>
<p>略，重点学习SpringDataRedis</p>
<h2 id="SpringDataRedis"><a href="#SpringDataRedis" class="headerlink" title="SpringDataRedis"></a>SpringDataRedis</h2><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p>
<ul>
<li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li>
<li>提供了RedisTemplate统一API来操作Redis</li>
<li>支持Redis的发布订阅模型</li>
<li>支持Redis哨兵和Redis集群</li>
<li>支持基于Lettuce的响应式编程</li>
<li>支持基于JDK.JSON.字符串.Spring对象的数据序列化及反序列化</li>
<li>支持基于Redis的JDKCollection实现</li>
</ul>
<p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/01/18/24230_1652976773295.png" alt="1652976773295"></p>
<h2 id="SpringDataRedis项目创建"><a href="#SpringDataRedis项目创建" class="headerlink" title="SpringDataRedis项目创建"></a>SpringDataRedis项目创建</h2><p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/01/18/43447_image-20240118152046621.png" alt="image-20240118152046621"></p>
<p>1、加入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--common-pool--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2、配置yaml文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">ip</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">xxxxx</span></span><br><span class="line">      <span class="attr">lettuce:</span></span><br><span class="line">        <span class="attr">pool:</span></span><br><span class="line">          <span class="attr">max-active:</span> <span class="number">8</span>  <span class="comment">#最大连接</span></span><br><span class="line">          <span class="attr">max-idle:</span> <span class="number">8</span>   <span class="comment">#最大空闲连接</span></span><br><span class="line">          <span class="attr">min-idle:</span> <span class="number">0</span>   <span class="comment">#最小空闲连接</span></span><br><span class="line">          <span class="attr">max-wait:</span> <span class="string">100ms</span> <span class="comment">#连接等待时间</span></span><br></pre></td></tr></table></figure>
<p>3、RedisTemplate测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;彬哥&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String) redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、发现问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line"> 1) <span class="string">&quot;hdb:product:2&quot;</span></span><br><span class="line"> 5) <span class="string">&quot;users&quot;</span></span><br><span class="line"> 6) <span class="string">&quot;\xac\xed\x00\x05t\x00\x04name&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="数据序列化器"><a href="#数据序列化器" class="headerlink" title="数据序列化器"></a>数据序列化器</h3><p>RedisTemplate可以接收任意Object作为值写入Redis</p>
<p>只不过写入前会把Object序列化为字节形式，<strong>默认是采用JDK序列化</strong></p>
<h3 id="自定义RedisTemplate的序列化"><a href="#自定义RedisTemplate的序列化" class="headerlink" title="自定义RedisTemplate的序列化"></a>自定义RedisTemplate的序列化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 创建JSON序列化工具</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// 设置Key的序列化</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置Value的序列化</span></span><br><span class="line">        template.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="StringRedisTemplate"><a href="#StringRedisTemplate" class="headerlink" title="StringRedisTemplate"></a>StringRedisTemplate</h2><p>尽管JSON的序列化方式可以满足我们的需求，但依然存在一些问题，如图：</p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/01/18/57696_image-20240118194242562.png" alt="image-20240118194242562"></p>
<ul>
<li><code>&quot;@class&quot;: &quot;com.hdb.redisdemo.pojo.User&quot;,</code>占用的空间比对象本身还多，但是自动反序列化又需要。</li>
<li>为了减少内存的消耗，我们可以采用手动序列化的方式，换句话说，就是不借助默认的序列化器，而是我们自己来控制序列化的动作，同时，我们只采用String的序列化器，这样，在存储value时，我们就不需要在内存中就不用多存储数据，从而节约我们的内存空间</li>
<li>SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisStringTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;bin&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        <span class="comment">// 手动序列化</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line">        <span class="comment">// 写入数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:200&quot;</span>, json);</span><br><span class="line">        <span class="comment">// 获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonUser</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:200&quot;</span>);</span><br><span class="line">        <span class="comment">// 手动反序列化</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> mapper.readValue(jsonUser, User.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;user1 = &quot;</span> + user1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="存储hash"><a href="#存储hash" class="headerlink" title="存储hash"></a>存储hash</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">    stringRedisTemplate.opsForHash().put(<span class="string">&quot;user:400&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;bin&quot;</span>);</span><br><span class="line">    stringRedisTemplate.opsForHash().put(<span class="string">&quot;user:400&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Map&lt;Object, Object&gt; entries = stringRedisTemplate.opsForHash().entries(<span class="string">&quot;user:400&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;entries = &quot;</span> + entries);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>springMVC学习笔记</title>
    <url>/2024/01/16/springMVC/spinngMVC/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<span id="more"></span>
<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><ol>
<li>先创建空项目</li>
</ol>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/08/31/20184_image-20230831163022372.png" alt="image-20230831163022372"></p>
<ol>
<li>创建module</li>
</ol>
<p>等待创建过程</p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/08/31/78249_image-20230831163316649.png" alt="image-20230831163316649"></p>
<ol>
<li>新建java目录</li>
</ol>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/08/31/46834_image-20230831163503073.png" alt="image-20230831163503073"></p>
<ol>
<li>更改per-module bytecode</li>
</ol>
<p>否则会报：java: 错误: 不支持发行版本 5</p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/08/31/95133_image-20230831200656888.png" alt="image-20230831200656888"></p>
<blockquote>
<p>很显然这种方式很麻烦，每次修改pom.xml文件后，都需要再次去设置。</p>
</blockquote>
<p><strong>法二、在pom.xml文件中配置</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="local-tomcat配置"><a href="#local-tomcat配置" class="headerlink" title="local tomcat配置"></a>local tomcat配置</h2><p>提前安装tomcat，<code>application server</code>选择安装的目录</p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/08/31/11337_image-20230831202822348.png" alt="image-20230831202822348"></p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/08/31/84522_image-20230831144725474.png" alt="image-20230831144725474"></p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/08/31/83078_image-20230831144747097.png" alt="image-20230831144747097"></p>
<h2 id="tomcat乱码"><a href="#tomcat乱码" class="headerlink" title="tomcat乱码"></a>tomcat乱码</h2><h3 id="server-xml"><a href="#server-xml" class="headerlink" title="server.xml"></a>server.xml</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;Connector port=<span class="string">&quot;8080&quot;</span> protocol=<span class="string">&quot;HTTP/1.1&quot;</span></span><br><span class="line">               connectionTimeout=<span class="string">&quot;20000&quot;</span></span><br><span class="line">               redirectPort=<span class="string">&quot;8443&quot;</span></span><br><span class="line">               maxParameterCount=<span class="string">&quot;1000&quot;</span></span><br><span class="line">                URIEncoding=<span class="string">&quot;UTF-8&quot;</span></span><br><span class="line">               /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="logging-properties"><a href="#logging-properties" class="headerlink" title="logging.properties"></a>logging.properties</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.logging.ConsoleHandler.encoding =  GBK</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器DispatcherServlet处理。前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器，将请求地址和控制器中@RequestMapping注解的value属性值进行匹配，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最终转发到视图所对应页面</p>
<h2 id="新建module后操作"><a href="#新建module后操作" class="headerlink" title="新建module后操作"></a>新建module后操作</h2><p>删掉原有deployment，添加新的<code>springMVC-demo2:war exploded</code></p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/08/31/36330_image-20230831200416626.png" alt="image-20230831200416626"></p>
<h2 id="RequestMapping注解的value属性"><a href="#RequestMapping注解的value属性" class="headerlink" title="@RequestMapping注解的value属性"></a>@RequestMapping注解的value属性</h2><p>@RequestMapping注解的value属性通过请求的请求地址匹配请求映射</p>
<p>@RequestMapping注解的value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求</p>
<p>@RequestMapping注解的value属性必须设置，至少通过请求地址匹配请求映射</p>
<h2 id="RequestMapping注解的params属性"><a href="#RequestMapping注解的params属性" class="headerlink" title="@RequestMapping注解的params属性"></a>@RequestMapping注解的params属性</h2><p>@RequestMapping注解的params属性通过请求的请求参数匹配请求映射</p>
<p>@RequestMapping注解的params属性是一个字符串类型的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系</p>
<p>“param”：要求请求映射所匹配的请求必须携带param请求参数</p>
<p>“!param”：要求请求映射所匹配的请求必须不能携带param请求参数</p>
<p>“param=value”：要求请求映射所匹配的请求必须携带param请求参数且param=value</p>
<p>“param!=value”：要求请求映射所匹配的请求必须携带param请求参数但是param!=value</p>
<h2 id="SpringMVC支持ant风格的路径"><a href="#SpringMVC支持ant风格的路径" class="headerlink" title="SpringMVC支持ant风格的路径"></a>SpringMVC支持ant风格的路径</h2><p>？：表示任意的单个字符</p>
<blockquote>
<p>java代码中用<code>/a?a</code></p>
</blockquote>
<p>*：表示任意的0个或多个字符</p>
<p>**：表示任意的一层或多层目录</p>
<p>注意：在使用*<em>时，只能使用/*</em>/xxx的方式</p>
<h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="RequestParam"></a>RequestParam</h2><p>@RequestParam是将请求参数和控制器方法的形参创建映射关系</p>
<p>@RequestParam注解一共有三个属性：</p>
<p>value：指定为形参赋值的请求参数的参数名</p>
<p>required：设置是否必须传输此请求参数，默认值为true</p>
<p><strong>若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置defaultValue属性，则页面报错400</strong>：Required String parameter ‘xxx’ is not present；若设置为false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为null</p>
<h2 id="解决获取请求参数的乱码问题"><a href="#解决获取请求参数的乱码问题" class="headerlink" title="解决获取请求参数的乱码问题"></a>解决获取请求参数的乱码问题</h2><p>解决获取请求参数的乱码问题，可以使用SpringMVC提供的编码过滤器CharacterEncodingFilter，但是必须在web.xml中进行注册</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置springMVC的编码过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>SpringMVC中处理编码的过滤器一定要配置到其他过滤器之前，否则无效</p>
</blockquote>
<h2 id="域对象共享数据"><a href="#域对象共享数据" class="headerlink" title="域对象共享数据"></a>域对象共享数据</h2><p>ServletAPI, ModelAndView, Model, map, ModelMap</p>
<h3 id="Model-map-ModelMap关系"><a href="#Model-map-ModelMap关系" class="headerlink" title="Model, map, ModelMap关系"></a>Model, map, ModelMap关系</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Model</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ModelMap</span> <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;String, Object&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendedModelMap</span> <span class="keyword">extends</span> <span class="title class_">ModelMap</span> <span class="keyword">implements</span> <span class="title class_">Model</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BindingAwareModelMap</span> <span class="keyword">extends</span> <span class="title class_">ExtendedModelMap</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="jsp上下文路径"><a href="#jsp上下文路径" class="headerlink" title="jsp上下文路径"></a>jsp上下文路径</h2><p>更新后的版本，直接使用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;success&quot;</span>&gt;</span>success.jsp<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>不再使用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/success&quot;</span>&gt;</span>success.jsp<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="HiddenHttpMethodFilter"><a href="#HiddenHttpMethodFilter" class="headerlink" title="HiddenHttpMethodFilter"></a>HiddenHttpMethodFilter</h3><p>由于浏览器只支持发送get和post方式的请求，那么该如何发送put和delete请求呢？</p>
<p>SpringMVC 提供了 <strong>HiddenHttpMethodFilter</strong> 帮助我们<strong>将 POST 请求转换为 DELETE 或 PUT 请求</strong></p>
<p><strong>HiddenHttpMethodFilter</strong> 处理put和delete请求的条件：</p>
<p>a&gt;当前请求的请求方式必须为post</p>
<p>b&gt;当前请求必须传输请求参数_method</p>
<p>满足以上条件，<strong>HiddenHttpMethodFilter</strong> 过滤器就会将当前请求的请求方式转换为请求参数_method的值，因此请求参数_method的值才是最终的请求方式</p>
<p>在web.xml中注册<strong>HiddenHttpMethodFilter</strong> </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/user&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;PUT&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;修改&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>必须先注册CharacterEncodingFilter，再注册HiddenHttpMethodFilter</p>
</blockquote>
<h2 id="添加功能流程"><a href="#添加功能流程" class="headerlink" title="添加功能流程"></a>添加功能流程</h2><p>在employee_list中点击add功能，通过视图控制器（springMVC.xml)跳转到employee_add界面，输入信息，通过POST方法进入控制器，控制器保存新的员工，重定向到<code>/employee</code>重新进入查询所有的员工信息。</p>
<h2 id="get-post-delete-post"><a href="#get-post-delete-post" class="headerlink" title="get_post_delete_post"></a>get_post_delete_post</h2><div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>传统方式</th>
<th>REST风格</th>
</tr>
</thead>
<tbody>
<tr>
<td>查询操作</td>
<td>getUserById?id=1</td>
<td>user/1—&gt;get请求方式</td>
</tr>
<tr>
<td>保存操作</td>
<td>saveUser</td>
<td>user—&gt;post请求方式</td>
</tr>
<tr>
<td>删除操作</td>
<td>deleteUser?id=1</td>
<td>user/1—&gt;delete请求方式</td>
</tr>
<tr>
<td>更新操作</td>
<td>updateUser</td>
<td>user—&gt;put请求方式</td>
</tr>
</tbody>
</table>
</div>
<h2 id="更新功能流程"><a href="#更新功能流程" class="headerlink" title="更新功能流程"></a>更新功能流程</h2><p>在employee_list中点击update功能，跳转到控制器中的getEmployeeById（RequestMethod.GET）查询对应id的employee，将employee信息发送到employee_update网页，网页采用回显，提交信息后跳转到控制器中的updateEmployee（put），更新保存信息，重定向到控制器的getAllEmployee显示所有员工信息。</p>
<h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h2><p>@RequestBody可以获取请求体，需要在控制器方法设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/testRequestBody&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRequestBody&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequestBody</span><span class="params">(<span class="meta">@RequestBody</span> String requestBody)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;requestBody:&quot;</span>+requestBody);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="RequestEntity"><a href="#RequestEntity" class="headerlink" title="RequestEntity"></a>RequestEntity</h2><p>RequestEntity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过getHeaders()获取请求头信息，通过getBody()获取请求体信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRequestEntity&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequestEntity</span><span class="params">(RequestEntity&lt;String&gt; requestEntity)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;requestHeader:&quot;</span>+requestEntity.getHeaders());</span><br><span class="line">    System.out.println(<span class="string">&quot;requestBody:&quot;</span>+requestEntity.getBody());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h2><p>@ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器</p>
<blockquote>
<p>不再把success解析为html视图</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testResponseBody&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testResponseBody</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SpringMVC处理json"><a href="#SpringMVC处理json" class="headerlink" title="SpringMVC处理json"></a>SpringMVC处理json</h2><p>浏览器不能识别java响应的对象，需要转化为json格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testResponseUser&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">testResponseUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1001</span>, <span class="string">&quot;admin&quot;</span>, <span class="string">&quot;123456&quot;</span>, <span class="number">23</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>a&gt;导入jackson的依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.12</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>b&gt;在SpringMVC的核心配置文件中开启mvc的注解驱动，此时在HandlerAdaptor中会自动装配一个消息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的Java对象转换为Json格式的字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;mvc:annotation-driven /&gt;</span><br></pre></td></tr></table></figure>
<p>c&gt;在处理器方法上使用@ResponseBody注解进行标识</p>
<p>d&gt;将Java对象直接作为控制器方法的返回值返回，就会自动转换为<strong>Json格式的字符串</strong></p>
<h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><p>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，通常用于在不同系统之间传递和存储数据。JSON的设计目标是简单、易于阅读和编写，同时也易于解析和生成。它以文本形式表示数据，由键值对组成，具有以下特点：</p>
<ol>
<li>键值对：JSON 数据是由键值对组成的，每个键（也称为属性或字段）都是一个字符串，值可以是字符串、数字、布尔值、数组、对象、null等。键值对之间使用冒号（<code>:</code>）分隔，而不同的键值对之间使用逗号（<code>,</code>）分隔。</li>
<li>嵌套结构：JSON 支持嵌套结构，可以在值中包含其他键值对，从而构建复杂的数据结构。</li>
<li>数组：JSON 数组是一种有序的值的集合，使用方括号（<code>[]</code>）来表示。数组中的元素可以是任何合法的 JSON 数据类型，包括对象、字符串、数字等。</li>
<li>简洁性：JSON 的语法相对简单，易于阅读和编写。这使得它成为了在不同编程语言之间进行数据交换的理想选择。</li>
<li>自我描述性：JSON 数据本身包含数据类型信息，因此接收方可以很容易地理解数据的结构和内容。</li>
<li>广泛应用：JSON 在Web开发中非常常见，用于传输数据、配置文件、API通信等。它也得到了许多编程语言的支持，因此可以轻松地在不同平台上使用。<em>**</em></li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John Doe&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">30</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;isStudent&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;languages&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;JavaScript&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Python&quot;</span><span class="punctuation">,</span> <span class="string">&quot;C++&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;street&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123 Main St&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Anytown&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="重新打包"><a href="#重新打包" class="headerlink" title="重新打包"></a>重新打包</h2><p>再webapp下添加了static后，需要重新打包，找到maven中的lifestyle下的package，点击</p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/10/30/28028_image-20231030104445931.png" alt="image-20231030104445931" style="zoom: 50%;" /><img src="https://gitee.com/hollis7/pictures/raw/master/2023/10/30/88240_image-20231030104506076.png" alt="image-20231030104506076" style="zoom: 50%;" /></p>
<h2 id="RestController注解"><a href="#RestController注解" class="headerlink" title="@RestController注解"></a>@RestController注解</h2><p><code>@RestController</code>注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了<code>@Controller</code>注解，并且为其中的每个方法添加了<code>@ResponseBody</code>注解</p>
<h2 id="文件上传-下载"><a href="#文件上传-下载" class="headerlink" title="文件上传/下载"></a>文件上传/下载</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>获取ServletContext对象</p>
<p>获取服务器中文件的真实路径</p>
<p>创建输入流</p>
<p>创建字节数组</p>
<p>将流读到字节数组中</p>
<p>创建HttpHeaders对象设置响应头信息</p>
<p>设置要下载方式以及下载文件的名字</p>
<p>设置响应状态码</p>
<p>创建ResponseEntity对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testDown&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;<span class="type">byte</span>[]&gt; testResponseEntity(HttpSession session) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//获取ServletContext对象</span></span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> session.getServletContext();</span><br><span class="line">    <span class="comment">//获取服务器中文件的真实路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> servletContext.getRealPath(<span class="string">&quot;/static/img/1.jpg&quot;</span>);</span><br><span class="line">    <span class="comment">//创建输入流</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(realPath);</span><br><span class="line">    <span class="comment">//创建字节数组</span></span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[is.available()];</span><br><span class="line">    <span class="comment">//将流读到字节数组中</span></span><br><span class="line">    is.read(bytes);</span><br><span class="line">    <span class="comment">//创建HttpHeaders对象设置响应头信息</span></span><br><span class="line">    MultiValueMap&lt;String, String&gt; headers = <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">    <span class="comment">//设置要下载方式以及下载文件的名字</span></span><br><span class="line">    headers.add(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename=1.jpg&quot;</span>);</span><br><span class="line">    <span class="comment">//设置响应状态码</span></span><br><span class="line">    <span class="type">HttpStatus</span> <span class="variable">statusCode</span> <span class="operator">=</span> HttpStatus.OK;</span><br><span class="line">    <span class="comment">//创建ResponseEntity对象</span></span><br><span class="line">    ResponseEntity&lt;<span class="type">byte</span>[]&gt; responseEntity = <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(bytes, headers, statusCode);</span><br><span class="line">    <span class="comment">//关闭输入流</span></span><br><span class="line">    is.close();</span><br><span class="line">    <span class="keyword">return</span> responseEntity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>这两条都是对所有请求拦截（springMVC配置）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.hdb.mvc.interceptors.FirstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;firstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/testRequestEntity&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;firstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">	以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="拦截器的三个抽象方法"><a href="#拦截器的三个抽象方法" class="headerlink" title="拦截器的三个抽象方法"></a>拦截器的三个抽象方法</h3><p>SpringMVC中的拦截器有三个抽象方法：</p>
<p>preHandle：控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法</p>
<p>postHandle：控制器方法执行之后执行postHandle()</p>
<p>afterComplation：处理完视图和模型数据，渲染视图完毕之后执行afterComplation()</p>
<h2 id="基于配置的异常处理"><a href="#基于配置的异常处理" class="headerlink" title="基于配置的异常处理"></a>基于配置的异常处理</h2><p>SpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver<br>HandlerExceptionResolver接口的实现类有：DefaultHandlerExceptionResolver和SimpleMappingExceptionResolver. SpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver，使用方式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!--配置异常处理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionMappings&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;java.lang.ArithmeticException&quot;</span>&gt;</span>error<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        设置将异常信息共享在请求域中的键--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionAttribute&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">出现错误</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;ex&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="注解配置SpringMVC"><a href="#注解配置SpringMVC" class="headerlink" title="注解配置SpringMVC"></a>注解配置SpringMVC</h2><p>Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为<code>AbstractAnnotationConfigDispatcherServletInitializer</code>，当我们的类扩展了<code>AbstractAnnotationConfigDispatcherServletInitializer</code>并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebInit</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定spring的配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定SpringMVC的配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;WebConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定DispatcherServlet的映射规则，即url-pattern</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加过滤器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">        <span class="type">CharacterEncodingFilter</span> <span class="variable">encodingFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>();</span><br><span class="line">        encodingFilter.setEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        encodingFilter.setForceRequestEncoding(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">HiddenHttpMethodFilter</span> <span class="variable">hiddenHttpMethodFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HiddenHttpMethodFilter</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Filter</span>[]&#123;encodingFilter, hiddenHttpMethodFilter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="webconfig"><a href="#webconfig" class="headerlink" title="webconfig"></a>webconfig</h3><p>代替SpringMVC的配置文件：</p>
<p>1、扫描组件  2、视图解析器   3、view-controller   4、default-servlet-handler</p>
<p> 5、mvc注解驱动   6、文件上传解析器  7、异常处理    8、拦截器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hdb.mvc.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hdb.mvc.interceptor.TestInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.ContextLoader;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.WebApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.commons.CommonsMultipartResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerExceptionResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ViewResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.handler.SimpleMappingExceptionResolver;</span><br><span class="line"><span class="keyword">import</span> org.thymeleaf.spring5.SpringTemplateEngine;</span><br><span class="line"><span class="keyword">import</span> org.thymeleaf.spring5.view.ThymeleafViewResolver;</span><br><span class="line"><span class="keyword">import</span> org.thymeleaf.templatemode.TemplateMode;</span><br><span class="line"><span class="keyword">import</span> org.thymeleaf.templateresolver.ITemplateResolver;</span><br><span class="line"><span class="keyword">import</span> org.thymeleaf.templateresolver.ServletContextTemplateResolver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代替SpringMVC的配置文件：</span></span><br><span class="line"><span class="comment"> * 1、扫描组件   2、视图解析器     3、view-controller    4、default-servlet-handler</span></span><br><span class="line"><span class="comment"> * 5、mvc注解驱动    6、文件上传解析器   7、异常处理      8、拦截器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//1、扫描组件</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.hdb.mvc.controller&quot;)</span></span><br><span class="line"><span class="comment">//5、mvc注解驱动</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、default-servlet-handler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8、拦截器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="type">TestInterceptor</span> <span class="variable">testInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestInterceptor</span>();</span><br><span class="line">        registry.addInterceptor(testInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、view-controller</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addViewController(<span class="string">&quot;/hello&quot;</span>).setViewName(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6、文件上传解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MultipartResolver <span class="title function_">multipartResolver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CommonsMultipartResolver</span> <span class="variable">commonsMultipartResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonsMultipartResolver</span>();</span><br><span class="line">        <span class="keyword">return</span> commonsMultipartResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7、异常处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureHandlerExceptionResolvers</span><span class="params">(List&lt;HandlerExceptionResolver&gt; resolvers)</span> &#123;</span><br><span class="line">        <span class="type">SimpleMappingExceptionResolver</span> <span class="variable">exceptionResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMappingExceptionResolver</span>();</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        prop.setProperty(<span class="string">&quot;java.lang.ArithmeticException&quot;</span>,<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        <span class="comment">//出现ArithmeticException映射到error。html</span></span><br><span class="line">        exceptionResolver.setExceptionMappings(prop);</span><br><span class="line">        <span class="comment">//exception的值是ArithmeticException中对应的错误信息，共享到请求域中的键</span></span><br><span class="line">        exceptionResolver.setExceptionAttribute(<span class="string">&quot;exception&quot;</span>);</span><br><span class="line">        resolvers.add(exceptionResolver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置生成模板解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ITemplateResolver <span class="title function_">templateResolver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">WebApplicationContext</span> <span class="variable">webApplicationContext</span> <span class="operator">=</span> ContextLoader.getCurrentWebApplicationContext();</span><br><span class="line">        <span class="comment">// ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得</span></span><br><span class="line">        <span class="type">ServletContextTemplateResolver</span> <span class="variable">templateResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletContextTemplateResolver</span>(</span><br><span class="line">                webApplicationContext.getServletContext());</span><br><span class="line">        templateResolver.setPrefix(<span class="string">&quot;/WEB-INF/templates/&quot;</span>);</span><br><span class="line">        templateResolver.setSuffix(<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">        templateResolver.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        templateResolver.setTemplateMode(TemplateMode.HTML);</span><br><span class="line">        <span class="keyword">return</span> templateResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成模板引擎并为模板引擎注入模板解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SpringTemplateEngine <span class="title function_">templateEngine</span><span class="params">(ITemplateResolver templateResolver)</span> &#123;</span><br><span class="line">        <span class="type">SpringTemplateEngine</span> <span class="variable">templateEngine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringTemplateEngine</span>();</span><br><span class="line">        templateEngine.setTemplateResolver(templateResolver);</span><br><span class="line">        <span class="keyword">return</span> templateEngine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成视图解析器并未解析器注入模板引擎</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ViewResolver <span class="title function_">viewResolver</span><span class="params">(SpringTemplateEngine templateEngine)</span> &#123;</span><br><span class="line">        <span class="type">ThymeleafViewResolver</span> <span class="variable">viewResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThymeleafViewResolver</span>();</span><br><span class="line">        viewResolver.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        viewResolver.setTemplateEngine(templateEngine);</span><br><span class="line">        <span class="keyword">return</span> viewResolver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="SpringMVC常用组件"><a href="#SpringMVC常用组件" class="headerlink" title="SpringMVC常用组件"></a>SpringMVC常用组件</h2><ul>
<li>DispatcherServlet：<strong>前端控制器</strong>，不需要工程师开发，由框架提供</li>
</ul>
<p>作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求</p>
<ul>
<li>HandlerMapping：<strong>处理器映射器</strong>，不需要工程师开发，由框架提供</li>
</ul>
<p>作用：根据请求的url、method等信息查找Handler，即控制器方法</p>
<ul>
<li>Handler：<strong>处理器</strong>，需要工程师开发</li>
</ul>
<p>作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理</p>
<ul>
<li>HandlerAdapter：<strong>处理器适配器</strong>，不需要工程师开发，由框架提供</li>
</ul>
<p>作用：通过HandlerAdapter对处理器（控制器方法）进行执行</p>
<ul>
<li>ViewResolver：<strong>视图解析器</strong>，不需要工程师开发，由框架提供</li>
</ul>
<p>作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、RedirectView</p>
<ul>
<li>View：<strong>视图</strong></li>
</ul>
<p>作用：将模型数据通过页面展示给用户</p>
<h2 id="DispatcherServlet初始化过程"><a href="#DispatcherServlet初始化过程" class="headerlink" title="DispatcherServlet初始化过程"></a>DispatcherServlet初始化过程</h2><p>DispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度。</p>
<p>a&gt;初始化WebApplicationContext</p>
<p>b&gt;创建WebApplicationContext</p>
<p>c&gt;DispatcherServlet初始化策略</p>
<p>FrameworkServlet创建WebApplicationContext后，刷新容器，调用onRefresh(wac)，此方法在DispatcherServlet中进行了重写，调用了initStrategies(context)方法，初始化策略，即初始化DispatcherServlet的各个组件</p>
<h2 id="SpringMVC的执行流程"><a href="#SpringMVC的执行流程" class="headerlink" title="SpringMVC的执行流程"></a>SpringMVC的执行流程</h2><p>1) 用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获。</p>
<p>2) DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI），判断请求URI对应的映射：</p>
<p>a) 不存在</p>
<p>i. 再判断是否配置了mvc:default-servlet-handler</p>
<p>ii. 如果没配置，则控制台报映射查找不到，客户端展示404错误</p>
<p>iii. 如果有配置，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404错误</p>
<p>b) 存在则执行下面的流程</p>
<p>3) 根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain执行链对象的形式返回。</p>
<p>4) DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。</p>
<p>5) 如果成功获得HandlerAdapter，此时将开始执行拦截器的preHandler(…)方法【正向】</p>
<p>6) 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)方法，处理请求。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：</p>
<p>a) HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息</p>
<p>b) 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等</p>
<p>c) 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</p>
<p>d) 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</p>
<p>7) Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象。</p>
<p>8) 此时将开始执行拦截器的postHandle(…)方法【逆向】。</p>
<p>9) 根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver进行视图解析，根据Model和View，来渲染视图。</p>
<p>10) 渲染视图完毕执行拦截器的afterCompletion(…)方法【逆向】。</p>
<p>11) 将渲染结果返回给客户端。</p>
]]></content>
      <categories>
        <category>springMVC</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>SpirngMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot3 场景整合</title>
    <url>/2024/01/16/springboot3/springboot3_%E5%9C%BA%E6%99%AF%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="springboot3笔记资料地址"><a href="#springboot3笔记资料地址" class="headerlink" title="springboot3笔记资料地址"></a>springboot3笔记资料地址</h2><p><a href="https://www.yuque.com/leifengyang/springboot3">springboot3-notes</a></p>
<span id="more"></span>
<h1 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><ul>
<li>准备prometheus.yml，docker-compose.yml</li>
<li>启动环境</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker compose -f docker-compose.yml up -d</span><br></pre></td></tr></table></figure>
<p>停止服务而不删除相关容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker compose -f docker-compose.yml stop</span><br></pre></td></tr></table></figure>
<p>重新启动已经停止的服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker-compose -f docker-compose.yml start</span><br></pre></td></tr></table></figure>
<p>关闭通过 Docker Compose 启动的服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker-compose -f docker-compose.yml down</span><br></pre></td></tr></table></figure>
<h2 id="Redis整合"><a href="#Redis整合" class="headerlink" title="Redis整合"></a>Redis整合</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.data.redis.host</span>=<span class="string">server ip</span></span><br><span class="line"><span class="attr">spring.data.redis.port</span>=<span class="string">6379</span></span><br></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * set:     集合:       redisTemplate.opsForSet()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">String</span> <span class="variable">setName</span> <span class="operator">=</span> <span class="string">&quot;settest&quot;</span>;</span><br><span class="line">       <span class="comment">//1、给集合中添加元素</span></span><br><span class="line">       redisTemplate.opsForSet().add(setName,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;3&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="type">Boolean</span> <span class="variable">aBoolean</span> <span class="operator">=</span> redisTemplate.opsForSet().isMember(setName, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">       Assertions.assertTrue(aBoolean);</span><br><span class="line"></span><br><span class="line">       <span class="type">Boolean</span> <span class="variable">aBoolean1</span> <span class="operator">=</span> redisTemplate.opsForSet().isMember(setName, <span class="string">&quot;5&quot;</span>);</span><br><span class="line">       Assertions.assertFalse(aBoolean1);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="RedisTemplate定制化"><a href="#RedisTemplate定制化" class="headerlink" title="RedisTemplate定制化"></a>RedisTemplate定制化</h2><p>模仿官方的RedisTemplate进行改写默认序列化，在<code>RedisAutoConfiguration</code>中有<br>找到<code>RedisSerializer</code>接口，定位实现类（ctr+H），发现<code>GenericJackson2JsonRedisSerializer</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppRedisConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">//把对象转为json字符串的序列化工具</span></span><br><span class="line">        template.setDefaultSerializer(<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>());</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/01/09/78210_image-20240109102411367.png" alt="image-20240109102411367"></p>
<p>重新运行程序，会产生一个没有乱码的person的<code>&lt;key,value&gt;</code></p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/01/09/82329_image-20240109102745029.png" alt="image-20240109102745029"></p>
<h2 id="redis相关配置"><a href="#redis相关配置" class="headerlink" title="redis相关配置"></a>redis相关配置</h2><ul>
<li><p><strong>Redis客户端</strong></p>
</li>
<li><ul>
<li>Lettuce： 默认</li>
<li>Jedis：可以使用以下切换</li>
</ul>
</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#spring.data.redis.client-type=lettuce</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#设置lettuce的底层参数</span></span><br><span class="line"><span class="attr">spring.data.redis.lettuce.pool.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.data.redis.lettuce.pool.max-active</span>=<span class="string">8</span></span><br></pre></td></tr></table></figure>
<p>使用Jedis，在redis-starter中排除<code>lettuce</code>，再导入<code>jedis</code><br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--        切换 jedis 作为操作redis的底层客户端--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h1><p>Swagger 可以快速生成<strong>实时接口</strong>文档，方便前后开发人员进行协调沟通。遵循 <strong>OpenAPI</strong> 规范。</p>
<h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springdoc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdoc-openapi-starter-webmvc-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>进入<code>http://localhost:8080/swagger-ui/index.html</code></p>
<h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><div class="table-container">
<table>
<thead>
<tr>
<th>注解</th>
<th>标注位置</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Tag</td>
<td>controller 类</td>
<td>标识 controller 作用</td>
</tr>
<tr>
<td>@Parameter</td>
<td>参数</td>
<td>标识参数作用</td>
</tr>
<tr>
<td>@Parameters</td>
<td>参数</td>
<td>参数多重说明</td>
</tr>
<tr>
<td>@Schema</td>
<td>model 层的 JavaBean</td>
<td>描述模型作用及每个属性</td>
</tr>
<tr>
<td>@Operation</td>
<td>方法</td>
<td>描述方法作用</td>
</tr>
<tr>
<td>@ApiResponse</td>
<td>方法</td>
<td>描述响应状态码等</td>
</tr>
</tbody>
</table>
</div>
<h2 id="controller示例"><a href="#controller示例" class="headerlink" title="controller示例"></a>controller示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Tag(name=&quot;部门&quot;,description = &quot;部门的CRUD&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DeptService deptService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Knife4j</span></span><br><span class="line">    <span class="meta">@Operation(summary = &quot;查询&quot;,description = &quot;按照id查询部门&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/dept/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Dept <span class="title function_">getDept</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deptService.getDeptById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Operation(summary = &quot;查询所有部门&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/depts&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Dept&gt; <span class="title function_">getDept</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deptService.getDepts();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Operation(summary = &quot;保存部门&quot;,description = &quot;必须提交json&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/dept&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">saveDept</span><span class="params">(<span class="meta">@RequestBody</span> Dept dept)</span>&#123;</span><br><span class="line">        deptService.saveDept(dept);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Operation(summary = &quot;按照id删除部门&quot;,description = &quot;必须提交json&quot;)</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/dept/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deleteDept</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="meta">@Parameter(description = &quot;部门id&quot;)</span> Long id)</span>&#123;</span><br><span class="line">        deptService.deleteDept(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分组设置"><a href="#分组设置" class="headerlink" title="分组设置"></a>分组设置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiUiConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分组设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> GroupedOpenApi <span class="title function_">empApi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> GroupedOpenApi.builder()</span><br><span class="line">                .group(<span class="string">&quot;员工管理&quot;</span>)</span><br><span class="line">                .pathsToMatch(<span class="string">&quot;/emp/**&quot;</span>,<span class="string">&quot;/emps&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> GroupedOpenApi <span class="title function_">deptApi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> GroupedOpenApi.builder()</span><br><span class="line">                .group(<span class="string">&quot;部门管理&quot;</span>)</span><br><span class="line">                .pathsToMatch(<span class="string">&quot;/dept/**&quot;</span>,<span class="string">&quot;/depts&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> OpenAPI <span class="title function_">docsOpenAPI</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OpenAPI</span>()</span><br><span class="line">                .info(<span class="keyword">new</span> <span class="title class_">Info</span>()</span><br><span class="line">                        .title(<span class="string">&quot;SpringBoot3-CRUD API&quot;</span>)</span><br><span class="line">                        .description(<span class="string">&quot;专门测试接口文件&quot;</span>)</span><br><span class="line">                        .version(<span class="string">&quot;v0.0.1&quot;</span>)</span><br><span class="line">                        .license(<span class="keyword">new</span> <span class="title class_">License</span>().name(<span class="string">&quot;Apache 2.0&quot;</span>).url(<span class="string">&quot;http://springdoc.org&quot;</span>)))</span><br><span class="line">                .externalDocs(<span class="keyword">new</span> <span class="title class_">ExternalDocumentation</span>()</span><br><span class="line">                        .description(<span class="string">&quot;哈哈 Wiki Documentation&quot;</span>)</span><br><span class="line">                        .url(<span class="string">&quot;https://springshop.wiki.github.org/docs&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h1><h2 id="方法一：webclient"><a href="#方法一：webclient" class="headerlink" title="方法一：webclient"></a>方法一：webclient</h2><p>编写WeatherService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getByWebClient</span><span class="params">(String city)</span>&#123;</span><br><span class="line">       <span class="comment">//远程调用阿里云API</span></span><br><span class="line">       <span class="comment">//1、创建WebClient</span></span><br><span class="line">       <span class="type">WebClient</span> <span class="variable">client</span> <span class="operator">=</span> WebClient.create();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//2、准备数据</span></span><br><span class="line">       Map&lt;String,String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       params.put(<span class="string">&quot;area&quot;</span>,city);</span><br><span class="line">       <span class="comment">//3、定义发请求行为  CompletableFuture</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> client.get()</span><br><span class="line">               .uri(<span class="string">&quot;https://qryweather.market.alicloudapi.com/lundroid/queryweather?area=&#123;area&#125;&quot;</span>, params)</span><br><span class="line">               .accept(MediaType.APPLICATION_JSON)</span><br><span class="line">               .header(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;APPCODE 9a0a550ada0c4656a5777f8ef674cbca&quot;</span>)</span><br><span class="line">               .retrieve()</span><br><span class="line">               .bodyToMono(String.class)</span><br><span class="line">               .block();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> json;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>WeatherController调用WeatherService的getByWebClient函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/weather&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">weather</span><span class="params">(<span class="meta">@RequestParam(&quot;city&quot;)</span>String city)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">weather</span> <span class="operator">=</span> weatherService.getByWebClient(city);</span><br><span class="line">        <span class="keyword">return</span> weather;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二：HTTP-Interface"><a href="#方法二：HTTP-Interface" class="headerlink" title="方法二：HTTP Interface"></a>方法二：HTTP Interface</h2><p>Spring 允许我们通过定义接口的方式，给任意位置发送 http 请求，实现远程调用，可以用来简化 HTTP 远程访问。需要webflux场景才可</p>
<ol>
<li>定义配置类<code>AliyunApiConfiguration</code>，其中aliyun.appcode为阿里云的相关api的授权码，可在properties中设置</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliyunApiConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    HttpServiceProxyFactory <span class="title function_">httpServiceProxyFactory</span><span class="params">(<span class="meta">@Value(&quot;$&#123;aliyun.appcode&#125;&quot;)</span> String appCode)</span>&#123;</span><br><span class="line">        <span class="comment">//1、创建客户端</span></span><br><span class="line">        <span class="type">WebClient</span> <span class="variable">client</span> <span class="operator">=</span> WebClient.builder()</span><br><span class="line">                .defaultHeader(<span class="string">&quot;Authorization&quot;</span>,<span class="string">&quot;APPCODE &quot;</span>+appCode)</span><br><span class="line">                .codecs(clientCodecConfigurer -&gt; &#123;</span><br><span class="line">                    clientCodecConfigurer</span><br><span class="line">                            .defaultCodecs()</span><br><span class="line">                            .maxInMemorySize(<span class="number">256</span>*<span class="number">1024</span>*<span class="number">1024</span>);</span><br><span class="line">                    <span class="comment">//响应数据量太大有可能会超出BufferSize，所以这里设置的大一点</span></span><br><span class="line">                &#125;)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//2、创建工厂</span></span><br><span class="line">        <span class="type">HttpServiceProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> HttpServiceProxyFactory</span><br><span class="line">                .builderFor(WebClientAdapter.create(client))</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    WeatherInterface <span class="title function_">weatherInterface</span><span class="params">(HttpServiceProxyFactory httpServiceProxyFactory)</span>&#123;</span><br><span class="line">        <span class="comment">//3、获取代理对象</span></span><br><span class="line">        <span class="type">WeatherInterface</span> <span class="variable">weatherInterface</span> <span class="operator">=</span> httpServiceProxyFactory.createClient(WeatherInterface.class);</span><br><span class="line">        <span class="keyword">return</span> weatherInterface;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">aliyun.appcode</span>=<span class="string">9a0a550ada0c4656a5777f8ef674cbca</span></span><br></pre></td></tr></table></figure>
<ol>
<li>定义接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WeatherInterface</span> &#123;</span><br><span class="line">    <span class="meta">@GetExchange(url = &quot;https://qryweather.market.alicloudapi.com/lundroid/queryweather&quot;,accept = &quot;application/json&quot;)</span></span><br><span class="line">    String <span class="title function_">getWeather</span><span class="params">(<span class="meta">@RequestParam(&quot;area&quot;)</span> String city)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>controller调用相关服务</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeatherController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    WeatherService weatherService;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/weather&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">weather</span><span class="params">(<span class="meta">@RequestParam(&quot;city&quot;)</span>String city)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">weather</span> <span class="operator">=</span> weatherService.weather(city);</span><br><span class="line">        <span class="keyword">return</span> weather;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>当有新的阿里云api时，可以复用配置代码</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AliyunApiConfiguration</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    ExpressApi <span class="title function_">expressApi</span><span class="params">(HttpServiceProxyFactory httpServiceProxyFactory)</span>&#123;</span><br><span class="line">        <span class="type">ExpressApi</span> <span class="variable">client</span> <span class="operator">=</span> httpServiceProxyFactory.createClient(ExpressApi.class);</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//WeatherController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExpressApi</span> &#123;</span><br><span class="line">    <span class="meta">@GetExchange(url = &quot;https://qryweather.market.alicloudapi.com/lundroid/queryweather&quot;,accept = &quot;application/json&quot;)</span></span><br><span class="line">    String <span class="title function_">getExpress</span><span class="params">(<span class="meta">@RequestParam(&quot;number&quot;)</span> String number)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="消息服务"><a href="#消息服务" class="headerlink" title="消息服务"></a>消息服务</h1><h2 id="kafka原理"><a href="#kafka原理" class="headerlink" title="kafka原理"></a>kafka原理</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1683170677428-6ffa28b6-d522-435f-9e50-20fe3ddfd024.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_36%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fresize%2Cw_1125%2Climit_0" alt="image.png"></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol>
<li>新建module，勾选</li>
</ol>
<ul>
<li>[x] Lombok</li>
<li>[x] Spring Web</li>
<li>[x] Spring for Apache Kafka</li>
</ul>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/01/09/12022_image-20240109203533200.png" alt="image-20240109203533200"></p>
<ol>
<li>配置kafka服务器</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.kafka.bootstrap-servers</span>=<span class="string">server_ip:9092</span></span><br></pre></td></tr></table></figure>
<ol>
<li>在测试主程序中编写程序，需要修改hosts文件，文件地址：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hosts：</span><br><span class="line">C:\Windows\System32\drivers\etc</span><br></pre></td></tr></table></figure>
<p>:rage: 加入ip对应的名字，不是老师讲的kafka</p>
<p>修改hosts文件，先以管理员权限打开文本编辑器，再用文本编辑器打开hosts文件进行修改。</p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/01/09/86312_image-20240109213939272.png" alt="image-20240109213939272"  /></p>
<h2 id="测试（异步）"><a href="#测试（异步）" class="headerlink" title="测试（异步）"></a>测试（异步）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">        CompletableFuture[] futures = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">10000</span>];</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="type">CompletableFuture</span> <span class="variable">future</span> <span class="operator">=</span> kafkaTemplate.send(<span class="string">&quot;news&quot;</span>, <span class="string">&quot;pig&quot;</span>, <span class="string">&quot;你是猪&quot;</span>);</span><br><span class="line">            futures[i] = future;</span><br><span class="line">        &#125;</span><br><span class="line">        CompletableFuture.allOf(futures).join();</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="variable">millis</span> <span class="operator">=</span> stopWatch.getTotalTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;10000消息发送完成：ms时间：&quot;</span> + millis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="kafka存入类测试"><a href="#kafka存入类测试" class="headerlink" title="kafka存入类测试"></a>kafka存入类测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CompletableFuture</span> <span class="variable">future</span> <span class="operator">=</span> kafkaTemplate.send(<span class="string">&quot;news&quot;</span>, <span class="string">&quot;person&quot;</span>, <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1L</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;hjaha@qq.com&quot;</span>));</span><br><span class="line">        future.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;消息发送成功...&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>需要进行序列化配置，默认是<code>Serializer</code>，改为json</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.kafka.producer.value-serializer</span>=<span class="string">org.springframework.kafka.support.serializer.JsonSerializer</span></span><br></pre></td></tr></table></figure>
<h2 id="KafkaListener监听"><a href="#KafkaListener监听" class="headerlink" title="KafkaListener监听"></a>KafkaListener监听</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHahaTopicListener</span> &#123;</span><br><span class="line">    <span class="comment">//默认的监听是从消息队列最后一个消息开始拿。新消息才能拿到</span></span><br><span class="line">    <span class="meta">@KafkaListener(topics = &quot;news&quot;, groupId = &quot;haha&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenRecords</span><span class="params">(ConsumerRecord record)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> record.key();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> record.value();</span><br><span class="line">        System.out.println(<span class="string">&quot;收到消息：key【&quot;</span> + key + <span class="string">&quot;】 value【&quot;</span> + value + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拿到以前的完整消息;</span></span><br><span class="line">    <span class="meta">@KafkaListener(groupId = &quot;haha2&quot;,</span></span><br><span class="line"><span class="meta">            topicPartitions = &#123;</span></span><br><span class="line"><span class="meta">                    @TopicPartition(topic = &quot;news&quot;,</span></span><br><span class="line"><span class="meta">                            partitionOffsets = &#123;</span></span><br><span class="line"><span class="meta">                                    @PartitionOffset(partition = &quot;0&quot;, initialOffset = &quot;0&quot;)</span></span><br><span class="line"><span class="meta">                            &#125;)</span></span><br><span class="line"><span class="meta">            &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenAllRecords</span><span class="params">(ConsumerRecord record)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> record.key();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> record.value();</span><br><span class="line">        System.out.println(<span class="string">&quot;=============收到消息：key【&quot;</span> + key + <span class="string">&quot;】 value【&quot;</span> + value + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableKafka</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Boo312MessageApplication</span></span><br></pre></td></tr></table></figure>
<p>Kafka 的特点包括：</p>
<ul>
<li>高吞吐：Kafka 可以处理每秒数百万条消息。</li>
<li>低延迟：Kafka 可以将消息从生产者发送到消费者的延迟保持在毫秒级。</li>
<li>持久化：Kafka 将消息持久化到磁盘，即使生产者或消费者发生故障，消息也不会丢失。</li>
<li>扩展性：Kafka 可以水平扩展，以满足不断增长的需求。</li>
</ul>
]]></content>
      <categories>
        <category>springboot3</category>
      </categories>
      <tags>
        <tag>springboot3</tag>
      </tags>
  </entry>
  <entry>
    <title>redis_1</title>
    <url>/2024/01/18/redis/redis_1/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="内容包括"><a href="#内容包括" class="headerlink" title="内容包括"></a>内容包括</h2><ul>
<li>docker启动redis</li>
<li>docker进入redis-cli</li>
<li>认识NoSql</li>
<li>redis常用命令</li>
</ul>
<span id="more"></span>
<h2 id="docker运行redis"><a href="#docker运行redis" class="headerlink" title="docker运行redis"></a>docker运行redis</h2><h3 id="yaml文件准备"><a href="#yaml文件准备" class="headerlink" title="yaml文件准备"></a>yaml文件准备</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.9&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hdb_redis</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span> <span class="string">--requirepass</span> <span class="string">passwd</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">./redis_data:/data</span>  <span class="comment"># 将数据挂载到本地目录</span></span><br><span class="line">  <span class="attr">redis_backup:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">sh</span> <span class="string">-c</span> <span class="string">&#x27;exec redis-server --requirepass passwd --save 3600 1&#x27;</span>  <span class="comment"># 每小时备份一次</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./redis_data:/data</span>  <span class="comment"># 使用相同的挂载点</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br></pre></td></tr></table></figure>
<p>确保yaml文件同目录下有<code>redis_data</code>文件夹，备份将在<code>redis_data</code>下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> -it hdb_redis redis-cli -a passwd BGSAVE</span><br></pre></td></tr></table></figure>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>启动环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker compose -f docker-compose.yml up -d</span><br></pre></td></tr></table></figure>
<p>停止服务而不删除相关容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker compose -f docker-compose.yml stop</span><br></pre></td></tr></table></figure>
<p>重新启动已经停止的服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker-compose -f docker-compose.yml start</span><br></pre></td></tr></table></figure>
<p>关闭通过 Docker Compose 启动的服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker-compose -f docker-compose.yml down</span><br></pre></td></tr></table></figure>
<h3 id="进入Redis终端"><a href="#进入Redis终端" class="headerlink" title="进入Redis终端"></a>进入Redis终端</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec ：在运行的容器中执行命令</span><br><span class="line"># 语法</span><br><span class="line">-d :分离模式: 在后台运行</span><br><span class="line">-i :即使没有附加也保持STDIN 打开</span><br><span class="line">-t :分配一个伪终端</span><br></pre></td></tr></table></figure>
<p><code>redis-cli</code>表示运行一个redis客户端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 29f48e38c77b redis-cli</span><br><span class="line"><span class="comment"># 推荐</span></span><br><span class="line">sudo docker <span class="built_in">exec</span> -it hdb_redis redis-cli</span><br></pre></td></tr></table></figure>
<p>da45019bf760是redis的容器id</p>
<p>退出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctr+D</span><br></pre></td></tr></table></figure>
<h3 id="密码认证"><a href="#密码认证" class="headerlink" title="密码认证"></a>密码认证</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">auth passwd</span><br></pre></td></tr></table></figure>
<h2 id="认识NoSQL"><a href="#认识NoSQL" class="headerlink" title="认识NoSQL"></a>认识NoSQL</h2><h3 id="结构化与非结构化"><a href="#结构化与非结构化" class="headerlink" title="结构化与非结构化"></a>结构化与非结构化</h3><ul>
<li>传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名.字段数据类型.字段约束等等信息，插入的数据必须遵守这些约束：</li>
<li>而NoSql则对数据库格式没有严格约束，往往形式松散，自由。</li>
</ul>
<h3 id="关联和非关联"><a href="#关联和非关联" class="headerlink" title="关联和非关联"></a>关联和非关联</h3><ul>
<li>传统数据库的表与表之间往往存在关联，例如外键</li>
<li>而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合</li>
</ul>
<h3 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h3><p>传统关系型数据库会基于Sql语句做查询，语法有统一标准；</p>
<p>而不同的非关系数据库查询语法差异极大，五花八门各种各样。</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>统关系型数据库能满足事务ACID的原则。</p>
<p>而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，只能实现基本的一致性。</p>
<blockquote>
<ol>
<li><strong>原子性 (Atomicity):</strong> 事务是原子的，要么全部执行，要么全部不执行。如果事务中的任何一部分操作失败，整个事务将被回滚到初始状态。</li>
<li><strong>一致性 (Consistency):</strong> 事务使数据库从一个一致的状态转移到另一个一致的状态。这意味着事务执行后，数据库必须仍然满足所有的完整性约束。</li>
<li><strong>隔离性 (Isolation):</strong> 多个事务可以并发执行，但其结果必须与按某种顺序串行执行它们的结果一致。隔离性确保一个事务的执行不会受到其他事务的干扰。</li>
<li><strong>持久性 (Durability):</strong> 一旦事务提交，其结果应该是永久性的，即使在系统故障的情况下也不会丢失。</li>
</ol>
</blockquote>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/01/16/27857_Nosql.png" alt="Nosql"></p>
<h2 id="认识Redis"><a href="#认识Redis" class="headerlink" title="认识Redis"></a>认识Redis</h2><p>Redis诞生于2009年全称是<strong>Remote Dictionary Server</strong>，远程词典服务器，是一个基于<strong>内存</strong>的键值型NoSQL数据库</p>
<ul>
<li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li>
<li>单线程，每个命令具备原子性</li>
<li>低延迟，速度快（<strong>基于内存</strong>.IO多路复用.良好的编码-c语言）。</li>
<li>支持数据持久化（断电-定期备份磁盘）</li>
<li>支持主从集群.分片集群</li>
<li>支持多语言客户端</li>
</ul>
<h2 id="初始redis"><a href="#初始redis" class="headerlink" title="初始redis"></a>初始redis</h2><h3 id="设值取值"><a href="#设值取值" class="headerlink" title="设值取值"></a>设值取值</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> name jack</span><br><span class="line">get name</span><br></pre></td></tr></table></figure>
<h3 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="keyword">select</span> 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[2]&gt; <span class="built_in">set</span> age 24</span><br></pre></td></tr></table></figure>
<h2 id="redis命令文档"><a href="#redis命令文档" class="headerlink" title="redis命令文档"></a>redis命令文档</h2><p>Redis是典型的key-value数据库，key一般是字符串，而value包含很多不同的数据类型：</p>
<p>Redis为了方便我们学习，将操作不同数据类型的命令也做了分组，在<a href="https://redis.io/commands">官网</a>可以查看到不同的命令。</p>
<p>或者使用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">help</span> @<span class="built_in">hash</span></span><br></pre></td></tr></table></figure>
<h2 id="redis通用命令"><a href="#redis通用命令" class="headerlink" title="redis通用命令"></a>redis通用命令</h2><p>通用指令是部分数据类型的，都可以使用的指令，常见的有：</p>
<ul>
<li>KEYS：查看符合模板的所有key</li>
<li>DEL：删除一个指定的key</li>
<li>EXISTS：判断key是否存在</li>
<li>EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除</li>
<li>TTL：查看一个KEY的剩余有效期</li>
</ul>
<h3 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不建议</span></span><br><span class="line">127.0.0.1:6379&gt; keys a*</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="del"><a href="#del" class="headerlink" title="del"></a>del</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; del age</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get age</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<h3 id="mset"><a href="#mset" class="headerlink" title="mset"></a>mset</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 多键值对赋值</span></span><br><span class="line">mset k1 v1 k2 v2 k3 v3</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k3&quot;</span></span><br><span class="line">2) <span class="string">&quot;k1&quot;</span></span><br><span class="line">3) <span class="string">&quot;k2&quot;</span></span><br><span class="line">4) <span class="string">&quot;name&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="del-2"><a href="#del-2" class="headerlink" title="del 2"></a>del 2</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 批量删除</span></span><br><span class="line">127.0.0.1:6379&gt; del k1 k2 k3</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>
<h3 id="exists"><a href="#exists" class="headerlink" title="exists"></a>exists</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Determines whether one or more keys exist.</span></span><br><span class="line">127.0.0.1:6379&gt; exists age</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; exists name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>
<h3 id="expire"><a href="#expire" class="headerlink" title="expire"></a>expire</h3><p>设置key的过期时间（秒）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">expire k1 20</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示-2表示已经删除</span></span><br><span class="line">127.0.0.1:6379&gt; TTl k1</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br></pre></td></tr></table></figure>
<p><code>-1</code>代表永久有效</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; TTL age</span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br></pre></td></tr></table></figure>
<h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p>
<p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p>
<ul>
<li>string：普通字符串</li>
<li>int：整数类型，可以做自增、自减操作</li>
<li>float：浮点类型，可以做自增、自减操作</li>
</ul>
<p>不管是哪种格式，底层都是<strong>字节数组</strong>形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m.</p>
<h3 id="String的常见命令"><a href="#String的常见命令" class="headerlink" title="String的常见命令"></a>String的常见命令</h3><p>String的常见命令有：</p>
<ul>
<li>SET：添加或者修改已经存在的一个String类型的键值对</li>
<li>GET：根据key获取String类型的value</li>
<li>MSET：批量添加多个String类型的键值对</li>
<li>MGET：根据多个key获取多个String类型的value</li>
<li>INCR：让一个整型的key自增1</li>
<li>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</li>
<li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li>
<li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li>
<li>SETEX：添加一个String类型的键值对，并且指定有效期</li>
</ul>
<h3 id="INCR"><a href="#INCR" class="headerlink" title="INCR"></a>INCR</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INCR age</span><br></pre></td></tr></table></figure>
<h3 id="INCRBY"><a href="#INCRBY" class="headerlink" title="INCRBY"></a>INCRBY</h3><p>自增3</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; INCRBY age 3</span><br><span class="line">(<span class="built_in">integer</span>) 28</span><br><span class="line">127.0.0.1:6379&gt; INCRBY age 3</span><br><span class="line">(<span class="built_in">integer</span>) 31</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>
<p>自减直接负数</p>
<h3 id="INCRBYFLOAT"><a href="#INCRBYFLOAT" class="headerlink" title="INCRBYFLOAT"></a>INCRBYFLOAT</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> score 4.5</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; INCRBYFLOAT score 3.4</span><br><span class="line"><span class="string">&quot;7.9&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里注意score最好介于-128~128之间，超过的话，incrbyfloat会发生位数异常</p>
</blockquote>
<h3 id="SETNX"><a href="#SETNX" class="headerlink" title="SETNX"></a>SETNX</h3><p>添加一个String类型的键值对，前提是这个key不存在，否则不执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setnx name lush</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>
<h3 id="SETEX"><a href="#SETEX" class="headerlink" title="SETEX"></a>SETEX</h3><p>Sets the string value and expiration time of a key. </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SETEX name 30 jack</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 22</span><br></pre></td></tr></table></figure>
<h2 id="Key结构"><a href="#Key结构" class="headerlink" title="Key结构"></a>Key结构</h2><p><strong>Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？</strong></p>
<p>我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范：</p>
<p>Redis的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">项目名:业务名:类型:id</span><br></pre></td></tr></table></figure>
<p><strong>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>KEY</strong></th>
<th><strong>VALUE</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>heima:user:1</td>
<td>{“id”:1,  “name”: “Jack”, “age”: 21}</td>
</tr>
<tr>
<td>heima:product:1</td>
<td>{“id”:1,  “name”: “小米11”, “price”: 4999}</td>
</tr>
</tbody>
</table>
</div>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> hdb:user:1 <span class="string">&#x27;&#123;&quot;id&quot;:1, &quot;name&quot;:&quot;Jack&quot;, &quot;age&quot;: 21&#125;&#x27;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> hdb:user:2 <span class="string">&#x27;&#123;&quot;id&quot;:2, &quot;name&quot;:&quot;Rose&quot;, &quot;age&quot;: 18&#125;&#x27;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> hdb:product:1 <span class="string">&#x27;&#123;&quot;id&quot;:1, &quot;name&quot;:&quot;小米11&quot;, &quot;price&quot;: 4999&#125;&#x27;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> hdb:product:2 <span class="string">&#x27;&#123;&quot;id&quot;:2, &quot;name&quot;:&quot;荣耀6&quot;, &quot;price&quot;: 2999&#125;&#x27;</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/01/17/99830_image-20240117215605769.png" alt="image-20240117215605769" style="zoom:67%;" /></p>
<h2 id="hash类型"><a href="#hash类型" class="headerlink" title="hash类型"></a>hash类型</h2><p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便</p>
<p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD。</p>
<blockquote>
<p>Create、Read、Update和Delete</p>
</blockquote>
<p><strong>Hash的常见命令有：</strong></p>
<ul>
<li><p>HSET key field value：添加或者修改hash类型key的field的值</p>
</li>
<li><p>HGET key field：获取一个hash类型key的field的值</p>
</li>
<li><p>HMSET：批量添加多个hash类型key的field的值</p>
</li>
<li><p>HMGET：批量获取多个hash类型key的field的值</p>
</li>
<li><p>HGETALL：获取一个hash类型的key中的所有的field和value</p>
</li>
<li>HKEYS：获取一个hash类型的key中的所有的field</li>
<li>HINCRBY:让一个hash类型key的字段值自增并指定步长</li>
<li>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</li>
</ul>
<h3 id="HSET"><a href="#HSET" class="headerlink" title="HSET"></a>HSET</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset hdb:user:3 name lucy</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hset hdb:user:3 age 23</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>
<h3 id="HGET"><a href="#HGET" class="headerlink" title="HGET"></a>HGET</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hget hdb:user:3 age</span><br><span class="line"><span class="string">&quot;28&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="HMGET"><a href="#HMGET" class="headerlink" title="HMGET"></a>HMGET</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmget hdb:user:3 age name</span><br><span class="line">1) <span class="string">&quot;28&quot;</span></span><br><span class="line">2) <span class="string">&quot;lucy&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="hgetall"><a href="#hgetall" class="headerlink" title="hgetall"></a>hgetall</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hgetall hdb:user:3</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;lucy&quot;</span></span><br><span class="line">3) <span class="string">&quot;age&quot;</span></span><br><span class="line">4) <span class="string">&quot;28&quot;</span></span><br><span class="line">5) <span class="string">&quot;sex&quot;</span></span><br><span class="line">6) <span class="string">&quot;girl&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="hkeys"><a href="#hkeys" class="headerlink" title="hkeys"></a>hkeys</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hkeys hdb:user:3</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;age&quot;</span></span><br><span class="line">3) <span class="string">&quot;sex&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="hvals"><a href="#hvals" class="headerlink" title="hvals"></a>hvals</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hvals hdb:user:3</span><br><span class="line">1) <span class="string">&quot;lucy&quot;</span></span><br><span class="line">2) <span class="string">&quot;28&quot;</span></span><br><span class="line">3) <span class="string">&quot;girl&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="hincrby"><a href="#hincrby" class="headerlink" title="hincrby"></a>hincrby</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hincrby hdb:user:3 age 2</span><br><span class="line">(<span class="built_in">integer</span>) 30</span><br><span class="line">127.0.0.1:6379&gt; hincrby hdb:user:3 age 2</span><br><span class="line">(<span class="built_in">integer</span>) 32</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h2><p>特征也与LinkedList类似：</p>
<ul>
<li>有序</li>
<li>元素可以重复</li>
<li>插入和删除快</li>
<li>查询速度一般</li>
</ul>
<p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p>
<p>List的常见命令有：</p>
<ul>
<li>LPUSH key element … ：向列表左侧插入一个或多个元素</li>
<li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li>
<li>RPUSH key element … ：向列表右侧插入一个或多个元素</li>
<li>RPOP key：移除并返回列表右侧的第一个元素</li>
<li>LRANGE key star end：返回一段角标范围内的所有元素</li>
<li>BLPOP和BRPOP：（BLPOP）移除并返回列表中的第一个元素。否则会阻塞直到有元素可用。如果最后一个元素被弹出，则删除列表</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; LPUSH <span class="built_in">users</span> 1 2 3 4 5</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; RPUSH animals 1 2 3 4 5</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; LPOP <span class="built_in">users</span> 1</span><br><span class="line">1) <span class="string">&quot;5&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE <span class="built_in">users</span> 0 2</span><br><span class="line">1) <span class="string">&quot;4&quot;</span></span><br><span class="line">2) <span class="string">&quot;3&quot;</span></span><br><span class="line">3) <span class="string">&quot;2&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="BLPOP"><a href="#BLPOP" class="headerlink" title="BLPOP"></a>BLPOP</h3><p>没有deals，阻塞，等待100s</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">BLPOP deals 100</span><br></pre></td></tr></table></figure>
<p>新建终端，push一个元素</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush deals egg</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>
<p>查看原终端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; BLPOP deals 100</span><br><span class="line">1) <span class="string">&quot;deals&quot;</span></span><br><span class="line">2) <span class="string">&quot;egg&quot;</span></span><br><span class="line">(49.58s)</span><br></pre></td></tr></table></figure>
<p>如果最后一个元素被弹出，则删除列表<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys deals</span><br><span class="line">(empty array)</span><br></pre></td></tr></table></figure></p>
<h2 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h2><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p>
<ul>
<li><p>无序</p>
</li>
<li><p>元素不可重复</p>
</li>
<li><p>查找快</p>
</li>
<li><p>支持交集、并集、差集等功能</p>
</li>
</ul>
<p>Set的常见命令有：</p>
<ul>
<li>SADD key member … ：向set中添加一个或多个元素</li>
<li>SREM key member … : 移除set中的指定元素</li>
<li>SCARD key： 返回set中元素的个数</li>
<li>SISMEMBER key member：判断一个元素是否存在于set中</li>
<li>SMEMBERS：获取set中的所有元素</li>
<li>SINTER key1 key2 … ：求key1与key2的交集</li>
</ul>
<h3 id="SADD"><a href="#SADD" class="headerlink" title="SADD"></a>SADD</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SADD s1 a b c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>
<h3 id="SMEMBERS"><a href="#SMEMBERS" class="headerlink" title="SMEMBERS"></a>SMEMBERS</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SMEMBERS s1</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br><span class="line">3) <span class="string">&quot;c&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="SREM"><a href="#SREM" class="headerlink" title="SREM"></a>SREM</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SREM s1 a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>
<h3 id="SISMEMBER"><a href="#SISMEMBER" class="headerlink" title="SISMEMBER"></a>SISMEMBER</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SISMEMBER s1 a</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>
<h3 id="SCARD"><a href="#SCARD" class="headerlink" title="SCARD"></a>SCARD</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SCARD s1</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure>
<h3 id="交集SINTER"><a href="#交集SINTER" class="headerlink" title="交集SINTER"></a>交集SINTER</h3><p>数据准备</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SADD zs lisi wangwu zhouliu</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; SADD lisi wangwu mazi ergou</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SINTER zs lisi</span><br><span class="line">1) <span class="string">&quot;wangwu&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="差集SDIFF"><a href="#差集SDIFF" class="headerlink" title="差集SDIFF"></a>差集SDIFF</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SDIFF zs lisi</span><br><span class="line">1) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">2) <span class="string">&quot;zhouliu&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="并集SUNION"><a href="#并集SUNION" class="headerlink" title="并集SUNION"></a>并集SUNION</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUNION zs lisi</span><br><span class="line">1) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">2) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">3) <span class="string">&quot;zhouliu&quot;</span></span><br><span class="line">4) <span class="string">&quot;mazi&quot;</span></span><br><span class="line">5) <span class="string">&quot;ergou&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="SortedSet类型"><a href="#SortedSet类型" class="headerlink" title="SortedSet类型"></a>SortedSet类型</h2><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p>
<p>SortedSet具备下列特性：</p>
<ul>
<li>可排序</li>
<li>元素不重复</li>
<li>查询速度快</li>
</ul>
<p>因为SortedSet的可排序特性，<strong>经常被用来实现排行榜这样的功能</strong>。</p>
<p>SortedSet的常见命令有：</p>
<ul>
<li>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li>
<li>ZREM key member：删除sorted set中的一个指定元素</li>
<li>ZSCORE key member : 获取sorted set中的指定元素的score值</li>
<li>ZRANK key member：获取sorted set 中的指定元素的排名</li>
<li>ZCARD key：获取sorted set中的元素个数</li>
<li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li>
<li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li>
<li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li>
<li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li>
<li>ZDIFF、ZINTER、ZUNION：求差集、交集、并集</li>
</ul>
<p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p>
<ul>
<li><p><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</p>
</li>
<li><p><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</p>
</li>
</ul>
<h3 id="ZADD"><a href="#ZADD" class="headerlink" title="ZADD"></a>ZADD</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZADD students 85 jack 89 lucy 82 rose 95 tom 78 jerry 92 amy 76 miles</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br></pre></td></tr></table></figure>
<h3 id="ZREM"><a href="#ZREM" class="headerlink" title="ZREM"></a>ZREM</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZREM students tom</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>
<h3 id="ZSCORE"><a href="#ZSCORE" class="headerlink" title="ZSCORE"></a>ZSCORE</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zscore students amy</span><br><span class="line"><span class="string">&quot;92&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="ZRANK"><a href="#ZRANK" class="headerlink" title="ZRANK"></a>ZRANK</h3><p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/01/18/65612_image-20240118105909641.png" alt="image-20240118105909641" style="zoom: 80%;" /></p>
<p>从低到高排名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZRANK students amy</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br></pre></td></tr></table></figure>
<p>从高到底排名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZREVRANK students amy</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>
<h3 id="ZCARD"><a href="#ZCARD" class="headerlink" title="ZCARD"></a>ZCARD</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZCARD students</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br></pre></td></tr></table></figure>
<h3 id="ZCOUNT"><a href="#ZCOUNT" class="headerlink" title="ZCOUNT"></a>ZCOUNT</h3><p>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZCOUNT students 0 90</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br></pre></td></tr></table></figure>
<h3 id="ZINCRBY"><a href="#ZINCRBY" class="headerlink" title="ZINCRBY"></a>ZINCRBY</h3><p>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZINCRBY students 2  amy</span><br><span class="line"><span class="string">&quot;94&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="ZRANGE"><a href="#ZRANGE" class="headerlink" title="ZRANGE"></a>ZRANGE</h3><p>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素（升序）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZREVRANGE students 0 3</span><br><span class="line">1) <span class="string">&quot;amy&quot;</span></span><br><span class="line">2) <span class="string">&quot;lucy&quot;</span></span><br><span class="line">3) <span class="string">&quot;jack&quot;</span></span><br><span class="line">4) <span class="string">&quot;rose&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="ZRANGEBYSCORE"><a href="#ZRANGEBYSCORE" class="headerlink" title="ZRANGEBYSCORE"></a>ZRANGEBYSCORE</h3><p>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</p>
<p>查找80分以下的同学</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE students 0 80</span><br><span class="line">1) <span class="string">&quot;miles&quot;</span></span><br><span class="line">2) <span class="string">&quot;jerry&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot3 数据访问</title>
    <url>/2024/01/16/springboot3/springboot3_%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="springboot3笔记资料地址"><a href="#springboot3笔记资料地址" class="headerlink" title="springboot3笔记资料地址"></a>springboot3笔记资料地址</h2><p><a href="https://www.yuque.com/leifengyang/springboot3">springboot3-notes-尚硅谷</a></p>
<span id="more"></span>
<h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>
<h3 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hdb2205</span><br></pre></td></tr></table></figure>
<h2 id="新建module"><a href="#新建module" class="headerlink" title="新建module"></a>新建module</h2><p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/01/03/61239_image-20240103152054170.png" alt="image-20240103152054170"></p>
<h2 id="整合SSM场景"><a href="#整合SSM场景" class="headerlink" title="整合SSM场景"></a>整合SSM场景</h2><ol>
<li>创建SSM整合项目</li>
<li>配置数据源</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.type</span>=<span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">hdb2205</span></span><br></pre></td></tr></table></figure>
<p>安装MyBatisX 插件，帮我们生成Mapper接口的xml文件即可</p>
<ol>
<li><code>Boot305SsmApplication</code>加入<code>@MapperScan</code>注释</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MapperScan(basePackages = &quot;com/hdb/boot/boot3/ssm/mapper&quot;)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2、配置整合MyBatis</span></span><br><span class="line"><span class="attr">mybatis.mapper-locations</span>=<span class="string">classpath:/mapper/*.xml</span></span><br><span class="line"><span class="comment"># 打开驼峰命名规则，mysql和java中的变量名字命名规则不同</span></span><br><span class="line"><span class="attr">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
<h2 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h2><ol>
<li><strong>导入</strong> <code>mybatis-spring-boot-starter</code></li>
<li>配置<strong>数据源</strong>信息</li>
<li>配置mybatis的<code>**mapper接口扫描**</code>与<code>**xml映射文件扫描**</code></li>
<li>编写bean，mapper，生成xml，编写sql 进行crud。<strong>事务等操作依然和Spring中用法一样</strong></li>
<li><p>效果：</p>
</li>
<li><ol>
<li>所有sql写在xml中</li>
<li>所有<code>mybatis配置</code>写在<code>application.properties</code>下面</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>springboot3</category>
      </categories>
      <tags>
        <tag>springboot3</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot3 web开发</title>
    <url>/2024/01/16/springboot3/springboot3_web%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="springboot3笔记资料地址"><a href="#springboot3笔记资料地址" class="headerlink" title="springboot3笔记资料地址"></a>springboot3笔记资料地址</h2><p><a href="https://www.yuque.com/leifengyang/springboot3">springboot3-notes</a></p>
<span id="more"></span>
<h2 id="xmind文件打开网址"><a href="#xmind文件打开网址" class="headerlink" title="xmind文件打开网址"></a>xmind文件打开网址</h2><p><a href="https://mubu.com/app/edit/home/1IVQRB_zQ2b#m">幕布</a></p>
<h2 id="关闭占用端口的程序"><a href="#关闭占用端口的程序" class="headerlink" title="关闭占用端口的程序"></a>关闭占用端口的程序</h2><p>查看占用端口的程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -ano | findstr 8080</span><br></pre></td></tr></table></figure>
<p>使用命令关闭</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">taskkill -PID 进程号 -F</span><br></pre></td></tr></table></figure>
<h2 id="springboot3-识别不了新module"><a href="#springboot3-识别不了新module" class="headerlink" title="springboot3 识别不了新module"></a>springboot3 识别不了新module</h2><h3 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h3><ol>
<li>Remove Module</li>
<li>选中未识别的module</li>
</ol>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/11/30/60877_image-20231130103414289.png" alt="image-20231130103414289"></p>
<ol>
<li><code>import module from external model----&gt;maven</code></li>
</ol>
<h3 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h3><ol>
<li>右击 项目名，选择“ Add Framework Support”</li>
<li>选中<code>maven</code></li>
</ol>
<h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><p>SpringBoot 帮我们简单、快速地创建一个独立的、生产级别的 <strong>Spring 应用</strong></p>
<p><strong>特性：</strong></p>
<ul>
<li><p>快速创建独立 Spring 应用</p>
</li>
<li><ul>
<li>SSM：导包、写配置、启动运行</li>
</ul>
</li>
<li><p>直接嵌入Tomcat、Jetty or Undertow（无需部署 war 包）【Servlet容器】</p>
</li>
<li><ul>
<li>linux  java tomcat mysql： war 放到 tomcat 的 webapps下</li>
<li>jar： java环境；  java -jar</li>
</ul>
</li>
<li><p><strong>重点</strong>：提供可选的starter，简化应用<strong>整合</strong></p>
</li>
<li><ul>
<li><strong>场景启动器</strong>（starter）：web、json、邮件、oss（对象存储）、异步、定时任务、缓存…</li>
<li>导包一堆，控制好版本。</li>
<li>为每一种场景准备了一个依赖； <strong>web-starter。mybatis-starter</strong></li>
</ul>
</li>
<li><p><strong>重点：</strong>按需自动配置 Spring 以及 第三方库</p>
</li>
<li><ul>
<li>如果这些场景我要使用（生效）。这个场景的所有配置都会自动配置好。</li>
<li><strong>约定大于配置</strong>：每个场景都有很多默认配置。</li>
<li>自定义：配置文件中修改几项就可以</li>
</ul>
</li>
<li><p>提供生产级特性：如 监控指标、健康检查、外部化配置等</p>
</li>
<li><ul>
<li>监控指标、健康检查（k8s）、外部化配置</li>
</ul>
</li>
<li><p>无代码生成、无xml</p>
</li>
</ul>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ol>
<li>创建新module</li>
</ol>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/11/22/31077_image-20231122105332075.png" alt="image-20231122105332075"></p>
<ol>
<li>继承spring-boot-starter-parent，pom文件导入，刷新</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    所有springboot项目都必须继承自 spring-boot-starter-parent --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--        web开发的场景启动器 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/11/22/69206_image-20231122110019745.png" alt="image-20231122110019745"></p>
<ol>
<li>编写代码</li>
</ol>
<p>主程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span> <span class="comment">//这是一个SpringBoot应用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>编写controller</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello,Spring Boot 3!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>导入打包插件，并清空和打包</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    SpringBoot应用打包插件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/11/22/64700_image-20231122111309675.png" alt="image-20231122111309675" style="zoom:50%;" /></p>
<ol>
<li>找到打包文件，cmd命令输入<code>java -jar demo.jar</code>运行</li>
</ol>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/11/22/33036_image-20231122112346584.png" alt="image-20231122112346584" style="zoom:50%;" /></p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/11/22/13158_image-20231122112612576.png" alt="image-20231122112612576" style="zoom: 33%;" /></p>
<ol>
<li>修改端口8888，添加配置文件<code>application.properties</code>(模拟linux场景)</li>
</ol>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/11/22/67131_image-20231122113212064.png" alt="image-20231122113212064"></p>
<p><img src="C:\data\mysoftware\Typora\typoraPicture\image-20231122113233472.png" alt="image-20231122113233472" style="zoom:50%;" /></p>
<p>端口变为8888</p>
<blockquote>
<p>windows场景下，idea的resource资源里添加<code>application.properties</code>（集中配置）</p>
</blockquote>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/11/23/82336_image-20231123095704294.png" alt="image-20231123095704294" style="zoom:50%;" /></p>
<h2 id="Spring-Initializr-创建向导"><a href="#Spring-Initializr-创建向导" class="headerlink" title="Spring Initializr 创建向导"></a>Spring Initializr 创建向导</h2><p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/11/23/21135_image-20231123112601446.png" alt="image-20231123112601446" style="zoom:50%;" /></p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/11/23/77224_image-20231123100919524.png" alt="image-20231123100919524" style="zoom:50%;" /></p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/11/23/20035_image-20231123100938497.png" alt="image-20231123100938497" style="zoom:50%;" /></p>
<h2 id="自定义依赖版本号"><a href="#自定义依赖版本号" class="headerlink" title="自定义依赖版本号"></a>自定义依赖版本号</h2><ul>
<li><p>利用maven的就近原则</p>
</li>
<li><ul>
<li>直接在<strong>导入依赖的时候声明版本</strong></li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;version&gt;8.0.31&lt;/version&gt;--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.protobuf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第三方的jar包</p>
<ul>
<li>boot父项目没有管理的需要自行声明好</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="springboot的自动配置机制"><a href="#springboot的自动配置机制" class="headerlink" title="springboot的自动配置机制"></a>springboot的自动配置机制</h2><ol>
<li>springboot导入场景，容器中就会自动配置好这个场景的核心组件。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">ioc</span> <span class="operator">=</span> SpringApplication.run(Boot302DemoApplication.class, args);</span><br><span class="line">        String[] names = ioc.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>默认的包扫描规则</li>
</ol>
<ul>
<li><code>@SpringBootApplication</code> 标注的类就是主程序类</li>
<li><p><strong>SpringBoot只会扫描主程序所在的包及其下面的子包，自动的component-scan功能</strong></p>
</li>
<li><p>@SpringBootApplication(scanBasePackages = “com.hdb”)</p>
</li>
<li><p><code>@ComponentScan(&quot;com.hdb&quot;)</code> 直接指定扫描的路径</p>
</li>
</ul>
<ol>
<li>配置默认值</li>
</ol>
<ul>
<li><strong>配置文件</strong>的所有配置项是和某个<strong>类的对象</strong>值进行一一绑定的。</li>
<li><p>绑定了配置文件中每一项值的类： <strong>属性类</strong>。</p>
</li>
<li><p><strong>按需加载自动配置</strong></p>
</li>
</ul>
<blockquote>
<p>导入场景<code>spring-boot-starter-web</code>，场景启动器除了会导入相关功能依赖，导入一个<code>spring-boot-starter</code>，是所有<code>starter</code>的<code>starter</code>，基础核心starter。<code>spring-boot-starter</code>导入了一个包 <code>spring-boot-autoconfigure</code>。包里面都是各种场景的<code>AutoConfiguration</code><strong>自动配置类</strong>虽然全场景的自动配置都在 <code>spring-boot-autoconfigure</code>这个包，但是不是全都开启的。</p>
</blockquote>
<h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><h3 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h3><p>组件默认是单实例的，使用<code>@Scope(&quot;prototype&quot;)</code>表面多实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line">   <span class="meta">@Bean(&quot;userhaha&quot;)</span><span class="comment">//替代以前的Bean标签。 组件在容器中的名字默认是方法名，可以直接修改注解的值</span></span><br><span class="line">   <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">       user.setId(<span class="number">1L</span>);</span><br><span class="line">       user.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> user;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>SpringBootConfiguration和Configuration差别不大，为了便于区分</p>
<h3 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(FastsqlException.class)</span></span><br></pre></td></tr></table></figure>
<p>使用@Import 导入第三方的组件,给容器中放指定类型的组件，组件的名字默认是全类名</p>
<h2 id="条件注解"><a href="#条件注解" class="headerlink" title="条件注解"></a>条件注解</h2><p><strong>@ConditionalOnClass：如果类路径中存在这个类，则触发指定行为</strong></p>
<p><strong>@ConditionalOnMissingClass：如果类路径中不存在这个类，则触发指定行为</strong></p>
<p><strong>@ConditionalOnBean：如果容器中存在这个Bean（组件），则触发指定行为</strong></p>
<p><strong>@ConditionalOnMissingBean：如果容器中不存在这个Bean（组件），则触发指定行为</strong></p>
<h2 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h2><p> <strong>声明组件的属性和配置文件哪些前缀开始项进行绑定</strong></p>
<ol>
<li>@ConfigurationProperties(prefix = “pig”)使得通过配置文件可以给实列赋值（在Appconfig和Pig.java中均可加入）</li>
</ol>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/11/24/13940_image-20231124110420990.png" alt="image-20231124110420990" style="zoom:50%;" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Appconfig.class </span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Pig <span class="title function_">pig</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pig</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>@EnableConfigurationProperties：快速注册注解：</strong>在配置文件中标注</li>
</ol>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/11/24/21048_image-20231124111538865.png" alt="image-20231124111538865" style="zoom:80%;" /></p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/11/24/15073_image-20231124111604817.png" alt="image-20231124111604817" style="zoom:50%;" /></p>
<h2 id="中文乱码"><a href="#中文乱码" class="headerlink" title="中文乱码"></a>中文乱码</h2><p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/11/24/51687_image-20231124105349873.png" alt="image-20231124105349873" style="zoom: 33%;" /></p>
<h2 id="自动setter-getter—-gt-Data"><a href="#自动setter-getter—-gt-Data" class="headerlink" title="自动setter/getter—&gt;@Data"></a>自动setter/getter—&gt;@Data</h2><p>pom.xml中导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--        自动生成构造器、getter/setter、自动生成Builder模式等--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>类中加入注释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="properties的复杂对象标识"><a href="#properties的复杂对象标识" class="headerlink" title="properties的复杂对象标识"></a>properties的复杂对象标识</h2><p>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span></span><br><span class="line"><span class="meta">@Data</span> <span class="comment">//自动生成JavaBean属性的getter/setter</span></span><br><span class="line"><span class="comment">//@NoArgsConstructor //自动生成无参构造器</span></span><br><span class="line"><span class="comment">//@AllArgsConstructor //自动生成全参构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Date birthDay;</span><br><span class="line">    <span class="keyword">private</span> Boolean like;</span><br><span class="line">    <span class="keyword">private</span> Child child; <span class="comment">//嵌套对象</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Dog&gt; dogs; <span class="comment">//数组（里面是对象）</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Cat&gt; cats; <span class="comment">//表示Map</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件<code>application.properties</code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">person.name</span>=<span class="string">张三</span></span><br><span class="line"><span class="attr">person.age</span>=<span class="string">18</span></span><br><span class="line"><span class="attr">person.birthDay</span>=<span class="string">2010/10/12 12:12:12</span></span><br><span class="line"><span class="attr">person.like</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">person.child.name</span>=<span class="string">李四</span></span><br><span class="line"><span class="attr">person.child.age</span>=<span class="string">12</span></span><br><span class="line"><span class="attr">person.child.birthDay</span>=<span class="string">2018/10/12</span></span><br><span class="line"><span class="attr">person.child.text[0]</span>=<span class="string">abc</span></span><br><span class="line"><span class="attr">person.child.text[1]</span>=<span class="string">def</span></span><br><span class="line"><span class="attr">person.dogs[0].name</span>=<span class="string">小黑</span></span><br><span class="line"><span class="attr">person.dogs[0].age</span>=<span class="string">3</span></span><br><span class="line"><span class="attr">person.dogs[1].name</span>=<span class="string">小白</span></span><br><span class="line"><span class="attr">person.dogs[1].age</span>=<span class="string">2</span></span><br><span class="line"><span class="attr">person.cats.c1.name</span>=<span class="string">小蓝</span></span><br><span class="line"><span class="attr">person.cats.c1.age</span>=<span class="string">3</span></span><br><span class="line"><span class="attr">person.cats.c2.name</span>=<span class="string">小灰</span></span><br><span class="line"><span class="attr">person.cats.c2.age</span>=<span class="string">2</span></span><br></pre></td></tr></table></figure>
<p>配置文件二：<code>application.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">张三</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">  <span class="attr">birthDay:</span> <span class="number">2010</span><span class="string">/10/10</span> <span class="number">12</span><span class="string">:12:12</span></span><br><span class="line">  <span class="attr">like:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">child:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">李四</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">20</span></span><br><span class="line">    <span class="attr">birthDay:</span> <span class="number">2018</span><span class="string">/10/10</span></span><br><span class="line"><span class="comment">#    数组的两种表示</span></span><br><span class="line">    <span class="attr">text:</span> [<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>]</span><br><span class="line">  <span class="attr">dogs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">小黑</span></span><br><span class="line">      <span class="attr">age:</span> <span class="number">3</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">小白</span></span><br><span class="line">      <span class="attr">age:</span> <span class="number">2</span></span><br><span class="line"><span class="comment">#  map的两种表示</span></span><br><span class="line">  <span class="attr">cats:</span></span><br><span class="line">    <span class="attr">c1:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">小蓝</span></span><br><span class="line">      <span class="attr">age:</span> <span class="number">3</span></span><br><span class="line">    <span class="attr">c2:</span> &#123;<span class="attr">name:</span> <span class="string">小绿</span>,<span class="attr">age:</span> <span class="number">2</span>&#125; <span class="comment">#对象也可用&#123;&#125;表示</span></span><br></pre></td></tr></table></figure>
<h2 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>以后每次勾选lombok，自动设置是set/get方法</p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/11/30/22457_image-20231130100501188.png" alt="image-20231130100501188" style="zoom:50%;" /></p>
<p><strong>SpringBoot怎么把日志默认配置好的</strong></p>
<p>1、每个<code>starter</code>场景，都会导入一个核心场景<code>spring-boot-starter</code></p>
<p>2、核心场景引入了日志的所用功能<code>spring-boot-starter-logging</code></p>
<p>3、默认使用了<code>logback + slf4j</code> 组合作为默认底层日志</p>
<p>4、<code>日志是系统一启动就要用</code>，<code>xxxAutoConfiguration</code>是系统启动好了以后放好的组件，后来用的。</p>
<p>5、日志是利用<strong>监听器机制</strong>配置好的。<code>ApplicationListener</code>。</p>
<p>6、日志所有的配置都可以通过修改配置文件实现。以<code>logging</code>开始的所有配置。</p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/11/30/68896_image.png" alt="image"></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">2023-11-30T10:30:46.701+08:00  INFO 7012 --- [           main] o.a.catalina.core.AprLifecycleListener   : OpenSSL successfully initialized [OpenSSL 1.1.1v  1 Aug 2023]</span><br><span class="line">2023-11-30T10:30:46.707+08:00  INFO 7012 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]</span><br></pre></td></tr></table></figure>
<h3 id="修改日志格式"><a href="#修改日志格式" class="headerlink" title="修改日志格式"></a>修改日志格式</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging.pattern.console</span>=<span class="string">%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %-5level [%thread] %logger&#123;15&#125; ===&gt; %msg%n</span></span><br><span class="line"><span class="comment">#2023-11-30 10:45:00.046 INFO  [main] o.s.b.w.e.t.TomcatWebServer ===&gt; Tomcat initialized with port 8080 (http)</span></span><br></pre></td></tr></table></figure>
<p>只修改时间</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging.pattern.dateformat</span>=<span class="string">yyyy-MM-dd HH:mm:ss</span></span><br><span class="line"><span class="comment"># 2023-11-30 10:51:33  INFO 20376 --- [           main] o.a.catalina.core.AprLifecycleListener   : OpenSSL successfully initialized [OpenSSL 1.1.1v  1 Aug 2023]</span></span><br></pre></td></tr></table></figure>
<h3 id="插入日志"><a href="#插入日志" class="headerlink" title="插入日志"></a>插入日志</h3><h4 id="通过日志类"><a href="#通过日志类" class="headerlink" title="通过日志类"></a>通过日志类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;哈哈哈&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>使用<code>@Slf4j</code>和默认的log</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;嘿嘿嘿&quot;</span>);</span><br><span class="line"><span class="comment">//        logger.info(&quot;哈哈哈&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><ul>
<li><p>由低到高：<code>ALL,TRACE, DEBUG, INFO, WARN, ERROR,FATAL,OFF</code>；</p>
</li>
<li><ul>
<li><strong>只会打印指定级别及以上级别的日志</strong></li>
<li>ALL：打印所有日志</li>
<li>TRACE：追踪框架详细流程日志，一般不使用</li>
<li>DEBUG：开发调试细节日志</li>
<li>INFO：关键、感兴趣信息日志</li>
<li>WARN：警告但不是错误的信息日志，比如：版本过时</li>
<li>ERROR：业务错误日志，比如出现各种异常</li>
<li>FATAL：致命错误日志，比如jvm系统崩溃</li>
<li>OFF：<strong>关闭所有日志记录</strong></li>
</ul>
</li>
</ul>
<h4 id="修改日志默认级别"><a href="#修改日志默认级别" class="headerlink" title="修改日志默认级别"></a>修改日志默认级别</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#默认所有日志没有精确指定级别就使用root的默认级别(info)</span></span><br><span class="line"><span class="attr">logging.level.root</span>=<span class="string">debug</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#精确调整某个包下的日志级别</span></span><br><span class="line"><span class="attr">logging.level.com.atguigu.logging.controller</span>=<span class="string">warn</span></span><br></pre></td></tr></table></figure>
<h4 id="日志分组"><a href="#日志分组" class="headerlink" title="日志分组"></a>日志分组</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging.group.abc</span>=<span class="string">com.atguigu.logging.controller,com.atguigu.logging.service,com.aaa,com.bbb</span></span><br><span class="line"><span class="attr">logging.level.abc</span>=<span class="string">debug</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging.level.sql</span>=<span class="string">debug</span></span><br></pre></td></tr></table></figure>
<h4 id="指定日志文件的路径"><a href="#指定日志文件的路径" class="headerlink" title="指定日志文件的路径"></a>指定日志文件的路径</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging.file.path</span>=<span class="string"></span></span><br></pre></td></tr></table></figure>
<h4 id="指定日志文件的名"><a href="#指定日志文件的名" class="headerlink" title="指定日志文件的名"></a>指定日志文件的名</h4><p>指定日志文件的名： <strong>filename 和 path的配置同时存在只看filename</strong></p>
<p>1、只写名字： 就生成到当前项目同位置的 my.log</p>
<p>2、<strong>写名字+路径：生成到指定位置的指定文件</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging.file.name</span>=<span class="string">demo.log</span></span><br></pre></td></tr></table></figure>
<h2 id="文件归档与滚动切割"><a href="#文件归档与滚动切割" class="headerlink" title="文件归档与滚动切割"></a>文件归档与滚动切割</h2><p>归档：每天的日志单独存到一个文档中。</p>
<p>切割：每个文件10MB，超过大小切割成另外一个文件。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#日志归档、切割</span></span><br><span class="line"><span class="attr">logging.logback.rollingpolicy.file-name-pattern</span>=<span class="string">$&#123;LOG_FILE&#125;.%d&#123;yyyy-MM-dd&#125;.%i.gz</span></span><br><span class="line"><span class="comment">#存档前，每个日志文件的最大大小</span></span><br><span class="line"><span class="attr">logging.logback.rollingpolicy.max-file-size</span>=<span class="string">1MB</span></span><br></pre></td></tr></table></figure>
<p>上述皆为默认</p>
<h2 id="自定义日志"><a href="#自定义日志" class="headerlink" title="自定义日志"></a>自定义日志</h2><p><code>resource</code>下配置<code>logback-spring.xml</code>，会自动识别</p>
<h1 id="web开发"><a href="#web开发" class="headerlink" title="web开发"></a>web开发</h1><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>SpringBoot 已经默认配置好了<strong>Web开发</strong>场景常用功能。我们直接使用即可。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方式</th>
<th>用法</th>
<th>效果</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>全自动</strong></td>
<td>直接编写控制器逻辑</td>
<td></td>
<td>全部使用<strong>自动配置默认效果</strong></td>
</tr>
<tr>
<td><strong>手自一体</strong></td>
<td><code>@Configuration</code> +   配置<code>**WebMvcConfigurer**</code>+ <em>配置 WebMvcRegistrations</em></td>
<td><strong>不要标注</strong> <code>@**EnableWebMvc**</code></td>
<td><strong>保留自动配置效果</strong> <strong>手动设置部分功能</strong> 定义MVC底层组件</td>
</tr>
<tr>
<td><strong>全手动</strong></td>
<td><code>@Configuration</code> +   配置<code>**WebMvcConfigurer**</code></td>
<td><strong>标注</strong> <code>@**EnableWebMvc**</code></td>
<td><strong>禁用自动配置效果</strong> <strong>全手动设置</strong></td>
</tr>
</tbody>
</table>
</div>
<h2 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h2><h3 id="静态资源映射"><a href="#静态资源映射" class="headerlink" title="静态资源映射"></a>静态资源映射</h3><p>静态资源映射规则在 WebMvcAutoConfiguration 中进行了定义：</p>
<ol>
<li><code>/webjars/**</code> 的所有路径 资源都在 <code>classpath:/META-INF/resources/webjars/</code></li>
<li><code>/**</code> 的所有路径 资源都在 <code>classpath:/META-INF/resources/</code>、<code>classpath:/resources/</code>、<code>classpath:/static/</code>、<code>classpath:/public/</code></li>
</ol>
<blockquote>
<p>所有静态资源都定义了缓存规则。【浏览器访问过一次，就会缓存一段时间】，但此功能参数无默认值</p>
</blockquote>
<h3 id="Favicon"><a href="#Favicon" class="headerlink" title="Favicon"></a>Favicon</h3><p>在静态资源目录下找 favicon.ico，放入static目录下，网页自动变成对应ico，记住<code>ctr + F5</code>刷新缓存</p>
<h3 id="缓存实验"><a href="#缓存实验" class="headerlink" title="缓存实验"></a>缓存实验</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开启静态资源映射规则</span></span><br><span class="line"><span class="attr">spring.web.resources.add-mappings</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#设置缓存</span></span><br><span class="line"><span class="comment">#spring.web.resources.cache.period=3600</span></span><br><span class="line"><span class="comment">##缓存详细合并项控制，覆盖period配置：</span></span><br><span class="line"><span class="comment">## 浏览器第一次请求服务器，服务器告诉浏览器此资源缓存7200秒，7200秒以内的所有此资源访问不用发给服务器请求，7200秒以后发请求给服务器</span></span><br><span class="line"><span class="attr">spring.web.resources.cache.cachecontrol.max-age</span>=<span class="string">7200</span></span><br></pre></td></tr></table></figure>
<h3 id="静态资源自定义配置"><a href="#静态资源自定义配置" class="headerlink" title="静态资源自定义配置"></a>静态资源自定义配置</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 共享缓存</span></span><br><span class="line"><span class="attr">spring.web.resources.cache.cachecontrol.cache-public</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#自定义静态资源文件夹位置</span></span><br><span class="line"><span class="attr">spring.web.resources.static-locations</span>=<span class="string">classpath:/a/,classpath:/b/,classpath:/static/</span></span><br><span class="line"><span class="comment">### 2.1. 自定义webjars路径前缀</span></span><br><span class="line"><span class="attr">spring.mvc.webjars-path-pattern</span>=<span class="string">/wj/**</span></span><br><span class="line"><span class="comment">### 2.2. 静态资源访问路径前缀</span></span><br><span class="line"><span class="attr">spring.mvc.static-path-pattern</span>=<span class="string">/static/**</span></span><br></pre></td></tr></table></figure>
<h3 id="代码方式静态资源自定义配置"><a href="#代码方式静态资源自定义配置" class="headerlink" title="代码方式静态资源自定义配置"></a>代码方式静态资源自定义配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//保留以前规则</span></span><br><span class="line">        WebMvcConfigurer.<span class="built_in">super</span>.addResourceHandlers(registry);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自己写新的规则。</span></span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/static/**&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;classpath:/a/&quot;</span>,<span class="string">&quot;classpath:/b/&quot;</span>)</span><br><span class="line">                .setCacheControl(CacheControl.maxAge(<span class="number">1180</span>, TimeUnit.SECONDS));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>自己的规则，保留<code>/static/下</code>访问，同时支持自定义下<code>/a</code>、<code>/b</code>的访问，浏览器直接输入文件名，或者<code>static/3.jpg</code></p>
</blockquote>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/12/14/37416_image-20231214203646707.png" alt="image-20231214203646707"></p>
<h4 id="为什么容器中放一个WebMvcConfigurer就能配置底层行为"><a href="#为什么容器中放一个WebMvcConfigurer就能配置底层行为" class="headerlink" title="为什么容器中放一个WebMvcConfigurer就能配置底层行为"></a>为什么容器中放一个WebMvcConfigurer就能配置底层行为</h4><ol>
<li>WebMvcAutoConfiguration 是一个自动配置类，它里面有一个 <code>EnableWebMvcConfiguration</code></li>
<li><code>EnableWebMvcConfiguration</code>继承与 <code>DelegatingWebMvcConfiguration</code>，这两个都生效</li>
<li><code>DelegatingWebMvcConfiguration</code>利用 DI 把容器中 所有 <code>WebMvcConfigurer</code>注入进来</li>
<li>别人调用 <code>DelegatingWebMvcConfiguration</code> 的方法配置底层规则，而它调用所有 <code>WebMvcConfigurer</code>的配置底层方法。</li>
</ol>
<h2 id="PathPatternParser风格路径"><a href="#PathPatternParser风格路径" class="headerlink" title="PathPatternParser风格路径"></a>PathPatternParser风格路径</h2><ul>
<li><p>默认使用新版 <code>PathPatternParser</code>进行路径匹配<em>，</em>不能匹配 <code>**</code> 在中间的情况，剩下的和 <code>antPathMatcher</code>语法兼容</p>
</li>
<li><p>中间有<code>**</code> ，报错，<code>Fix this pattern in your application or switch to the legacy parser implementation with &#39;spring.mvc.pathmatch.matching-strategy=ant_path_matcher&#39;.</code></p>
<blockquote>
<p>spring.mvc.pathmatch.matching-strategy=ant_path_matcher</p>
</blockquote>
</li>
</ul>
<h2 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h2><p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/12/14/85200_image-1702559859264-1.png" alt="image" style="zoom: 80%;" /></p>
<p>  1.1. 基于请求头内容协商：<strong>（默认开启）</strong><br>    1.1.1. 客户端向服务端发送请求，携带HTTP标准的Accept请求头。<br>      1.1.1.1. Accept: application/json、text/xml、text/yaml<br>      1.1.1.2. 服务端根据客户端请求头期望的数据类型进行动态返回<br>  1.2. 基于请求参数内容协商：<strong>（需要开启）</strong><br>    1.2.1. 发送请求 GET /projects/spring-boot?<code>format=json</code><br>    1.2.2. 匹配到 @GetMapping(“/projects/spring-boot”)<br>    1.2.3. 根据参数协商，优先返回 json 类型数据【需要开启参数匹配设置】<br>    1.2.4. 发送请求 GET /projects/spring-boot?format=xml,优先返回 xml 类型数据</p>
<ol>
<li><p>引入支持写出xml内容依赖</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&lt;dependency&gt;</span></span><br><span class="line">    <span class="attr">&lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;</span></span><br><span class="line">    <span class="attr">&lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;</span></span><br><span class="line"><span class="attr">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>标注注解</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JacksonXmlRootElement</span>  <span class="comment">// 可以写出为xml文档</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>开启基于请求参数的内容协商</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开启基于请求参数的内容协商功能。 默认参数名：format</span></span><br><span class="line"><span class="attr">spring.mvc.contentnegotiation.favor-parameter</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 指定内容协商时使用的参数名。默认是 format</span></span><br><span class="line"><span class="attr">spring.mvc.contentnegotiation.parameter-name</span>=<span class="string">type</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/12/14/16124_image-20231214214334717.png" alt="image-20231214214334717"></p>
<h3 id="自定义内容返回"><a href="#自定义内容返回" class="headerlink" title="自定义内容返回"></a>自定义内容返回</h3><p><code>@ResponseBody</code>由<code>HttpMessageConverter</code>处理</p>
<ol>
<li><p>如果controller方法的返回值标注了 <code>@ResponseBody</code>注解</p>
</li>
<li><ol>
<li>请求进来先来到<code>DispatcherServlet</code>的<code>doDispatch()</code>进行处理</li>
<li>找到一个 <code>HandlerAdapter</code>适配器。利用适配器执行目标方法</li>
<li><code>RequestMappingHandlerAdapter</code>来执行，调用<code>invokeHandlerMethod（）</code>来执行目标方法</li>
<li>目标方法执行之前，准备好两个东西</li>
</ol>
</li>
<li><ol>
<li><ol>
<li><code>HandlerMethodArgumentResolver</code>：参数解析器，确定目标方法每个参数值</li>
<li><code>HandlerMethodReturnValueHandler</code>：返回值处理器，确定目标方法的返回值改怎么处理</li>
</ol>
</li>
</ol>
</li>
<li><ol>
<li><code>RequestMappingHandlerAdapter</code> 里面的<code>invokeAndHandle()</code>真正执行目标方法</li>
<li>目标方法执行完成，会返回<strong>返回值对象</strong></li>
<li><strong>找到一个合适的返回值处理器</strong> <code>HandlerMethodReturnValueHandler</code></li>
<li>最终找到 <code>RequestResponseBodyMethodProcessor</code>能处理 标注了 <code>@ResponseBody</code>注解的方法</li>
<li><code>RequestResponseBodyMethodProcessor</code> 调用<code>writeWithMessageConverters</code>,利用<code>MessageConverter</code>把返回值写出去</li>
</ol>
</li>
</ol>
<h3 id="使用yaml返回"><a href="#使用yaml返回" class="headerlink" title="使用yaml返回"></a>使用yaml返回</h3><p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-yaml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>把对象写出成YAML（<strong>展示，可忽略</strong>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.setId(<span class="number">1L</span>);</span><br><span class="line">        person.setUserName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        person.setEmail(<span class="string">&quot;aaa@qq.com&quot;</span>);</span><br><span class="line">        person.setAge(<span class="number">18</span>);</span><br><span class="line"><span class="comment">//        不写yaml文件开头</span></span><br><span class="line">        <span class="type">YAMLFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">YAMLFactory</span>().disable(YAMLGenerator.Feature.WRITE_DOC_START_MARKER);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>(factory);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> mapper.writeValueAsString(person);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>编写配置，新增一种内容形式</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#新增一种媒体类型</span></span><br><span class="line"><span class="attr">spring.mvc.contentnegotiation.media-types.yaml</span>=<span class="string">text/yaml</span></span><br></pre></td></tr></table></figure>
<p>增加<code>HttpMessageConverter</code>组件，专门负责把对象写出为yaml格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> WebMvcConfigurer <span class="title function_">webMvcConfigurer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurer</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">                <span class="comment">//自己写新的规则。</span></span><br><span class="line">                registry.addResourceHandler(<span class="string">&quot;/static/**&quot;</span>)</span><br><span class="line">                        .addResourceLocations(<span class="string">&quot;classpath:/a/&quot;</span>, <span class="string">&quot;classpath:/b/&quot;</span>)</span><br><span class="line">                        .setCacheControl(CacheControl.maxAge(<span class="number">1180</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span><span class="comment">//配置一个能把对象转为yaml的messageConverter</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">                <span class="comment">//这里是springboot默认配置的，如果不加@Bean注解，会报错。</span></span><br><span class="line">                converters.add(<span class="keyword">new</span> <span class="title class_">MyYamlHttpMessageConverter</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyYamlHttpMessageConverter</span> <span class="keyword">extends</span> <span class="title class_">AbstractHttpMessageConverter</span>&lt;Object&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//把对象转成yaml</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyYamlHttpMessageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//告诉SpringBoot这个MessageConverter支持哪种媒体类型  //媒体类型</span></span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">MediaType</span>(<span class="string">&quot;text&quot;</span>, <span class="string">&quot;yaml&quot;</span>, StandardCharsets.UTF_8));</span><br><span class="line">        <span class="type">YAMLFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">YAMLFactory</span>().disable(YAMLGenerator.Feature.WRITE_DOC_START_MARKER);</span><br><span class="line">        <span class="built_in">this</span>.mapper = <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>(factory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="comment">//只要是对象类型，不是基本类型</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">readInternal</span><span class="params">(Class&lt;?&gt; clazz, HttpInputMessage inputMessage)</span> <span class="keyword">throws</span> IOException, HttpMessageNotReadableException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//@ResponseBody 把对象怎么写出去</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">writeInternal</span><span class="params">(Object methodReturnValue, HttpOutputMessage outputMessage)</span> <span class="keyword">throws</span> IOException, HttpMessageNotWritableException &#123;</span><br><span class="line">        <span class="comment">//try-with写法，自动关流</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">OutputStream</span> <span class="variable">body</span> <span class="operator">=</span> outputMessage.getBody()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.mapper.writeValue(body, methodReturnValue);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>配置媒体类型支持: </p>
</li>
<li><ul>
<li><code>spring.mvc.contentnegotiation.media-types.yaml=text/yaml</code></li>
</ul>
</li>
<li><p>编写对应的<code>HttpMessageConverter</code>，要告诉Boot这个支持的媒体类型</p>
</li>
<li><ul>
<li>按照<code>MyYamlHttpMessageConverter</code>的示例</li>
</ul>
</li>
<li><p>把MessageConverter组件加入到底层</p>
</li>
<li><ul>
<li>容器中放一个<code>WebMvcConfigurer</code> 组件，并配置底层的<code>MessageConverter</code></li>
</ul>
</li>
</ul>
<h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/1613913/1681354523290-b89d7e0d-b9aa-40f5-8d22-d3d09d02b136.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_28%2Ctext_5bCa56GF6LC3IGF0Z3VpZ3UuY29t%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10" alt="image.png"></p>
<h3 id="thymeleaf初试"><a href="#thymeleaf初试" class="headerlink" title="thymeleaf初试"></a>thymeleaf初试</h3><p><strong>controller</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WelcomeController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;well&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span>String name, Model model)</span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>,name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;welcome&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>welcome.html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;msg&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>span 标签的作用是用于显示文本内容，并可以通过 th:text 指令将变量的值替换为文本内容。</p>
</blockquote>
<h3 id="thymeleaf基础语法"><a href="#thymeleaf基础语法" class="headerlink" title="thymeleaf基础语法"></a>thymeleaf基础语法</h3><ol>
<li><code>th:xxx</code>：动态渲染指定的 html 标签属性值、或者th指令（遍历、判断等）</li>
</ol>
<p>● th:text：将一切内容都识别为纯文本，不会对 HTML 标签进行解析。<br>  ○ th:utext：会对 HTML 标签进行解析，并将其生效。。<br>● th:属性：标签指定属性渲染<br>● th:attr：标签任意属性渲染<br>● th:ifth:each…：其他th指令</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;msg&#125;&quot;</span>&gt;</span>哈哈<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">th:utext</span>=<span class="string">&quot;$&#123;msg&#125;&quot;</span>&gt;</span>呵呵<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/12/18/27187_image-20231218105441046.png" alt="image-20231218105441046"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">th:任意html属性</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">th:src</span>=<span class="string">&quot;$&#123;imgUrl&#125;&quot;</span> <span class="attr">src</span>=<span class="string">&quot;4.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 300px;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.addAttribute(<span class="string">&quot;imgUrl&quot;</span>,<span class="string">&quot;static/3.jpg&quot;</span>);</span><br><span class="line">model.addAttribute(<span class="string">&quot;style&quot;</span>,<span class="string">&quot;width: 400px&quot;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">th：其他指令</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">th:src</span>=<span class="string">&quot;$&#123;imgUrl&#125;&quot;</span> <span class="attr">th:style</span>=<span class="string">&quot;$&#123;style&#125;&quot;</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;show&#125;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">model.addAttribute(<span class="string">&quot;show&quot;</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<h3 id="自动添加根路径"><a href="#自动添加根路径" class="headerlink" title="自动添加根路径"></a>自动添加根路径</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 项目的根路径</span></span><br><span class="line"><span class="attr">server.servlet.context-path</span>=<span class="string">/demo</span></span><br></pre></td></tr></table></figure>
<p>在浏览器输入url：<code>/demo/well</code>后，自动在路径下加载<code>/demo/static/3.jpg</code><br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">2.jpg  @&#123;&#125; 专门用来取各种路径</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/static/3.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:300px;&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/3.jpg&#125;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p><strong>controller</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">list</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">        List&lt;Person&gt; list = Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1L</span>, <span class="string">&quot;张三1&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">15</span>, <span class="string">&quot;pm&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">3L</span>, <span class="string">&quot;张三2&quot;</span>, <span class="string">&quot;zs2@qq.com&quot;</span>, <span class="number">16</span>, <span class="string">&quot;pm&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">4L</span>, <span class="string">&quot;张三333&quot;</span>, <span class="string">&quot;zs3@qq.com&quot;</span>, <span class="number">17</span>, <span class="string">&quot;pm&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">7L</span>, <span class="string">&quot;张三444&quot;</span>, <span class="string">&quot;zs4@qq.com&quot;</span>, <span class="number">18</span>, <span class="string">&quot;admin&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">8L</span>, <span class="string">&quot;张三5&quot;</span>, <span class="string">&quot;zs5@qq.com&quot;</span>, <span class="number">19</span>, <span class="string">&quot;hr&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">        model.addAttribute(<span class="string">&quot;persons&quot;</span>,list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        int i = 10/0;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;list&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">&quot;table&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;col&quot;</span>&gt;</span>#<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;col&quot;</span>&gt;</span>名字<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;col&quot;</span>&gt;</span>邮箱<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;col&quot;</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;col&quot;</span>&gt;</span>角色<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;col&quot;</span>&gt;</span>状态信息<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;person,stats:$&#123;persons&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;row&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;person.id&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;person.userName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>[[$&#123;person.email&#125;]]<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>[[$&#123;person.age&#125;]]<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;person.role&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">            index:[[$&#123;stats.index&#125;]]<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">            count:[[$&#123;stats.count&#125;]]<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">            size(总数量):[[$&#123;stats.size&#125;]]<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">            current(当前对象): [[$&#123;stats.current&#125;]] <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">            even(true)/odd(false): [[$&#123;stats.even&#125;]] <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">            first: [[$&#123;stats.first&#125;]] <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">            last: [[$&#123;stats.last&#125;]] <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/12/20/32173_image-20231220110146251.png" alt="image-20231220110146251" style="zoom: 67%;" /></p>
<blockquote>
<p>可以在bootstrap上复制渲染的css，js链接，点击docss查找</p>
</blockquote>
<p><strong>iterStat 有以下属性：</strong></p>
<ul>
<li>index：当前遍历元素的索引，从0开始</li>
<li>count：当前遍历元素的索引，从1开始</li>
<li>size：需要遍历元素的总数量</li>
<li>current：当前正在遍历的元素对象</li>
<li>even/odd：是否偶数/奇数行</li>
<li>first：是否第一个元素</li>
<li>last：是否最后一个元素</li>
</ul>
<h4 id="th-switch"><a href="#th-switch" class="headerlink" title="th:switch"></a>th:switch</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:switch</span>=<span class="string">&quot;$&#123;person.role&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">th:case</span>=<span class="string">&quot;&#x27;admin&#x27;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-danger&quot;</span>&gt;</span>管理员<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">th:case</span>=<span class="string">&quot;&#x27;pm&#x27;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span>&gt;</span>项目经理<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">th:case</span>=<span class="string">&quot;&#x27;hr&#x27;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-default&quot;</span>&gt;</span>人事<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="th-if"><a href="#th-if" class="headerlink" title="th:if"></a>th:if</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;#strings.isEmpty(person.email)&#125;&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;&#x27;联系不上&#x27;&quot;</span>&gt;</span>  <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;not #strings.isEmpty(person.email)&#125;&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;person.email&#125;&quot;</span>&gt;</span>  <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="属性优先级"><a href="#属性优先级" class="headerlink" title="属性优先级"></a>属性优先级</h4><ul>
<li>片段</li>
<li>遍历</li>
<li>判断</li>
</ul>
<h4 id="对象选择"><a href="#对象选择" class="headerlink" title="对象选择"></a>对象选择</h4><p>用<code>*</code>选择遍历的对象</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;person,stats:$&#123;persons&#125;&quot;</span> <span class="attr">th:object</span>=<span class="string">&quot;$&#123;person&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span> <span class="attr">scope</span>=<span class="string">&quot;row&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;person.id&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;td th:text=&quot;$&#123;person.userName&#125;&quot;&gt;&lt;/td&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;*&#123;userName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>需要在遍历那里加入 <code>th:object=&quot;$&#123;person&#125;</code>，然后用<code>*</code>代替：<code>th:text=&quot;*&#123;userName&#125;&quot;</code></p>
<h3 id="模板布局"><a href="#模板布局" class="headerlink" title="模板布局"></a>模板布局</h3><ul>
<li>定义模板： <code>th:fragment</code></li>
</ul>
<p><strong>commom.html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--抽取的判断，名字叫 myheader--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">th:fragment</span>=<span class="string">&quot;myheader&quot;</span> <span class="attr">class</span>=<span class="string">&quot;p-3 text-bg-dark&quot;</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>引用模板：<code>~&#123;templatename::selector&#125;</code></li>
</ul>
<p><strong>index.html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导航  使用公共部分进行替换--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  ~&#123; 模板名 :: 片段名&#125; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">&quot;~&#123;common::myheader&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="热启动"><a href="#热启动" class="headerlink" title="热启动"></a>热启动</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!--热启动功能 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2><p>Spring Boot 在类路径根下查找<code>messages</code>资源绑定文件。文件名为：<code>messages.properties</code></p>
<p>多语言可以定义多个消息文件，命名为messages_区域代码.properties。如：</p>
<ul>
<li>messages.properties：默认</li>
<li>messages_zh_CN.properties：中文环境</li>
<li>messages_en_US.properties：英语环境</li>
</ul>
<p>在程序中可以自动注入 MessageSource组件，获取国际化的配置项值</p>
<p>在页面中可以使用表达式  <code>#&#123;&#125;</code>获取国际化的配置项值</p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/12/25/99634_image-20231225111916158.png" alt="image-20231225111916158"></p>
<p><strong>message.properties</strong></p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/12/25/54508_image-20231225111952638.png" alt="image-20231225111952638"></p>
<p><strong>messages_zh_CN.properties</strong></p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/12/25/39480_image-20231225112104173.png" alt="image-20231225112104173"></p>
<p><strong>common.html</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text-end&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--国际化--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-outline-light me-2&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;#&#123;login&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-warning&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;#&#123;sign&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/svg/1613913/1681723795095-828d2034-1e6c-4d98-8e47-573dd6b5463b.svg" alt="未命名绘图.svg" style="zoom:67%;" /></p>
<h3 id="默认机制"><a href="#默认机制" class="headerlink" title="默认机制"></a>默认机制</h3><p><strong>错误处理的自动配置</strong>都在<code>ErrorMvcAutoConfiguration</code>中，两大核心机制：</p>
<ul>
<li><ol>
<li>SpringBoot 会<strong>自适应**</strong>处理错误<strong>，</strong>响应页面<strong>或</strong>JSON数据**</li>
</ol>
</li>
<li><ol>
<li><strong>SpringMVC的错误处理机制</strong>依然保留，<strong>MVC处理不了</strong>，才会<strong>交给boot进行处理</strong></li>
</ol>
</li>
</ul>
<ul>
<li><p>发生错误以后，转发给/error路径，SpringBoot在底层写好一个 BasicErrorController的组件，专门处理这个请求</p>
</li>
<li><p>错误页面是这么解析到的</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、解析错误的自定义视图地址</span></span><br><span class="line"><span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> resolveErrorView(request, response, status, model);</span><br><span class="line"><span class="comment">//2、如果解析不到错误页面的地址，默认的错误页就是 error</span></span><br><span class="line"><span class="keyword">return</span> (modelAndView != <span class="literal">null</span>) ? modelAndView : <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;error&quot;</span>, model);</span><br></pre></td></tr></table></figure>
<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ol>
<li><p><strong>解析一个错误页</strong></p>
</li>
<li><p>a. 如果发生了500、404、503、403 这些错误</p>
</li>
<li><ol>
<li><ol>
<li>如果有<strong>模板引擎</strong>，默认在 <code>classpath:/templates/error/**精确码.html**</code></li>
<li>如果没有模板引擎，在静态资源文件夹下找  <code>**精确码.html**</code></li>
</ol>
</li>
</ol>
</li>
<li><p>b. 如果匹配不到<code>精确码.html</code>这些精确的错误页，就去找<code>5xx.html</code>，<code>4xx.html</code><strong>模糊匹配</strong></p>
</li>
<li><ol>
<li><ol>
<li>如果有模板引擎，默认在 <code>classpath:/templates/error/5xx.html</code></li>
<li>如果没有模板引擎，在静态资源文件夹下找  <code>5xx.html</code></li>
</ol>
</li>
</ol>
</li>
<li><p>如果模板引擎路径<code>templates</code>下有 <code>error.html</code>页面，就直接渲染</p>
</li>
</ol>
<h2 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h2><ol>
<li><code>ServletWebServerFactoryAutoConfiguration</code> 自动配置了嵌入式容器场景</li>
<li>绑定了<code>ServerProperties</code>配置类，所有和服务器有关的配置 <code>server</code></li>
<li><p><code>ServletWebServerFactoryAutoConfiguration</code> 导入了 嵌入式的三大服务器 <code>Tomcat</code>、<code>Jetty</code>、<code>Undertow</code></p>
</li>
<li><ol>
<li>导入 <code>Tomcat</code>、<code>Jetty</code>、<code>Undertow</code> 都有条件注解。系统中有这个类才行（也就是导了包）</li>
<li>默认  <code>Tomcat</code>配置生效。给容器中放 TomcatServletWebServerFactory</li>
<li>都给容器中 <code>ServletWebServerFactory</code>放了一个 <strong>web服务器工厂（造web服务器的）</strong></li>
<li><strong>web服务器工厂 都有一个功能，</strong><code>getWebServer</code>获取web服务器</li>
<li>TomcatServletWebServerFactory 创建了 tomcat。</li>
</ol>
</li>
<li><p>ServletWebServerFactory 什么时候会创建 webServer出来。</p>
</li>
<li><code>ServletWebServerApplicationContext</code>ioc容器，启动的时候会调用创建web服务器</li>
<li>Spring<strong>容器刷新（启动）</strong>的时候，会预留一个时机，刷新子容器。<code>onRefresh()</code></li>
<li>refresh() 容器刷新 十二大步的刷新子容器会调用 <code>onRefresh()</code>；</li>
</ol>
<blockquote>
<p>Web场景的Spring容器启动，在onRefresh的时候，会调用创建web服务器的方法。</p>
<p>Web服务器的创建是通过WebServerFactory搞定的。容器中又会根据导了什么包条件注解，启动相关的 服务器配置，默认<code>EmbeddedTomcat</code>会给容器中放一个 <code>TomcatServletWebServerFactory</code>，导致项目启动，自动创建出Tomcat。</p>
</blockquote>
]]></content>
      <categories>
        <category>springboot3</category>
      </categories>
      <tags>
        <tag>springboot3</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot3 基础特性</title>
    <url>/2024/01/16/springboot3/springboot3_%E5%9F%BA%E7%A1%80%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="自定义-banner"><a href="#自定义-banner" class="headerlink" title="自定义 banner"></a>自定义 banner</h2><ol>
<li>类路径添加banner.txt或设置spring.banner.location就可以定制 banner</li>
<li>推荐网站：<a href="https://www.bootschool.net/ascii">Spring Boot banner 在线生成工具，制作下载英文 banner.txt，修改替换 banner.txt 文字实现自定义，个性化启动 banner-bootschool.net</a></li>
</ol>
<span id="more"></span>
<h2 id="环境隔离"><a href="#环境隔离" class="headerlink" title="环境隔离"></a>环境隔离</h2><p>1、标识环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1）、区分出几个环境： dev（开发环境）、test（测试环境）、prod（生产环境）</span><br><span class="line">2）、指定每个组件在哪个环境下生效； default环境：默认环境</span><br><span class="line">	通过： @Profile(&#123;&quot;test&quot;&#125;)标注</span><br><span class="line">	组件没有标注@Profile代表任意时候都生效</span><br><span class="line">3）、默认只有激活指定的环境，这些组件才会生效。</span><br></pre></td></tr></table></figure>
<p>2、激活环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置文件激活：spring.profiles.active=dev；</span><br><span class="line">命令行激活： java -jar xxx.jar  --spring.profiles.active=dev</span><br><span class="line">集成环境如下图</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/01/04/72330_image-20240104164250109.png" alt="image-20240104164250109" style="zoom: 50%;" /></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--spring.profiles.active=dev</span><br></pre></td></tr></table></figure>
<p>3、环境包含</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#包含指定环境，不管你激活哪个环境，这个都要有。总是要生效的环境</span></span><br><span class="line"><span class="attr">spring.profiles.include</span>=<span class="string">prod</span></span><br></pre></td></tr></table></figure>
<h3 id="最佳实战"><a href="#最佳实战" class="headerlink" title="最佳实战"></a>最佳实战</h3><ul>
<li><strong>生效的环境</strong> = <strong>激活的环境/默认环境</strong>  + <strong>包含的环境</strong></li>
<li><p>项目里面这么用</p>
</li>
<li><ul>
<li>基础的配置<code>mybatis</code>、<code>log</code>、<code>xxx</code>：写到<strong>包含环境中</strong></li>
<li>需要动态切换变化的 <code>db</code>、<code>redis</code>：写到<strong>激活的环境中</strong></li>
</ul>
</li>
</ul>
<h3 id="Profile-分组"><a href="#Profile-分组" class="headerlink" title="Profile 分组"></a>Profile 分组</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring.profiles.group.haha=db,<span class="built_in">log</span></span><br><span class="line">spring.profiles.group.hehe=mq</span><br></pre></td></tr></table></figure>
<h2 id="profile配置文件"><a href="#profile配置文件" class="headerlink" title="profile配置文件"></a>profile配置文件</h2><p>3、配置文件怎么使用Profile功能</p>
<p>1）、application.properties： 主配置文件。任何情况下都生效</p>
<p>2）、其他Profile环境下命名规范：  application-{profile标识}.properties：</p>
<p>比如：application-dev.properties</p>
<p>3）、激活指定环境即可：  配置文件激活、命令行激活</p>
<p>4）、效果：</p>
<p><strong>项目的所有生效配置项 = 激活环境配置文件的所有项 + 主配置文件和激活文件不冲突的所有项</strong></p>
<p><strong>如果发生了配置冲突，以激活的环境配置文件为准。</strong></p>
<p>application-{profile标识}.properties 优先级高于 application.properties</p>
<p>主配置和激活的配置都生效，优先以激活的配置为准</p>
<h2 id="配置优先级"><a href="#配置优先级" class="headerlink" title="配置优先级"></a>配置优先级</h2><p>命令行<code>&gt;</code>配置文件<code>&gt;</code>springapplication配置</p>
<p><strong>配置文件优先级</strong>如下：(<strong>后面覆盖前面</strong>)</p>
<ol>
<li><strong>jar 包内</strong>的application.properties/yml</li>
<li><strong>jar 包内</strong>的application-{profile}.properties/yml</li>
<li><strong>jar 包外</strong>的application.properties/yml</li>
<li><strong>jar 包外</strong>的application-{profile}.properties/yml</li>
</ol>
<p>最终效果：优先级由高到低，前面覆盖后面</p>
<p>命令行 &gt; 包外config直接子目录 &gt; 包外config目录 &gt; 包外根目录 &gt; 包内目录</p>
<p><img src="C:\data\mysoftware\Typora\typoraPicture\未命名绘图.svg" alt="未命名绘图"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/svg/1613913/1682073869709-2cba18c8-55bd-4bf1-a9df-ac784e30d89a.svg" alt="未命名绘图.svg"></p>
<h2 id="属性占位符"><a href="#属性占位符" class="headerlink" title="属性占位符"></a>属性占位符</h2><p>配置文件中可以使用 <code>$&#123;name:default&#125;</code>形式取出之前配置过的值。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">app.name</span>=<span class="string">MyApp</span></span><br><span class="line"><span class="attr">app.description</span>=<span class="string">$&#123;app.name&#125; is a Spring Boot application written by $&#123;username:Unknown&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;app.name:中国mooc&#125;&quot;)</span></span><br><span class="line">String appName;</span><br></pre></td></tr></table></figure>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>@SpringBootTest</p>
]]></content>
      <categories>
        <category>springboot3</category>
      </categories>
      <tags>
        <tag>springboot3</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搭建小技巧</title>
    <url>/2024/01/16/tips/blogs/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="图片显示"><a href="#图片显示" class="headerlink" title="图片显示"></a>图片显示</h2><p>只需要输入命令：<code>&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;</code></p>
<span id="more"></span>
<h3 id="博客预览"><a href="#博客预览" class="headerlink" title="博客预览"></a>博客预览</h3><p>加入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>
<p>实现预览分割</p>
]]></content>
      <categories>
        <category>tips</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>picture</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot3 核心原理</title>
    <url>/2024/01/16/springboot3/springboot3_%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="springboot3笔记资料地址"><a href="#springboot3笔记资料地址" class="headerlink" title="springboot3笔记资料地址"></a>springboot3笔记资料地址</h2><p><a href="https://www.yuque.com/leifengyang/springboot3">springboot3-notes</a></p>
<span id="more"></span>
<h2 id="事件和监听器"><a href="#事件和监听器" class="headerlink" title="事件和监听器"></a>事件和监听器</h2><ol>
<li><p>自定义<code>SpringApplicationRunListener</code>来<strong>监听事件</strong>；</p>
</li>
<li><ol>
<li>编写<code>SpringApplicationRunListener</code> <strong>实现类</strong></li>
<li>在 <code>META-INF/spring.factories</code> 中配置 <code>org.springframework.boot.SpringApplicationRunListener=自己的Listener</code>，还可以指定一个<strong>有参构造器</strong>，接受两个参数<code>(SpringApplication application, String[] args)</code></li>
</ol>
</li>
<li><pre><code class="lang-properties"># spring.factories
org.springframework.boot.SpringApplicationRunListener=com.hdb.core.listener.MyAppListener
</code></pre>
</li>
<li><ol>
<li>springboot 在<code>spring-boot.jar</code>中配置了默认的 事件监听器</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Listener 先要从 META-INF/spring.factories 读到</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1、引导： 利用 BootstrapContext 引导整个项目启动</span></span><br><span class="line"><span class="comment"> *      starting：              应用开始，SpringApplication的run方法一调用，只要有了 BootstrapContext 就执行</span></span><br><span class="line"><span class="comment"> *      environmentPrepared：   环境准备好（把启动参数等绑定到环境变量中），但是ioc还没有创建；【调一次】</span></span><br><span class="line"><span class="comment"> * 2、启动：</span></span><br><span class="line"><span class="comment"> *      contextPrepared：       ioc容器创建并准备好，但是sources（主配置类）没加载。并关闭引导上下文；组件都没创建  【调一次】</span></span><br><span class="line"><span class="comment"> *      contextLoaded：         ioc容器加载。主配置类加载进去了。但是ioc容器还没刷新（我们的bean没创建）。</span></span><br><span class="line"><span class="comment"> *      =======截止以前，ioc容器里面还没造bean呢=======</span></span><br><span class="line"><span class="comment"> *      started：               ioc容器刷新了（所有bean造好了），但是 runner 没调用。</span></span><br><span class="line"><span class="comment"> *      ready:                  ioc容器刷新了（所有bean造好了），所有runner调用完了。</span></span><br><span class="line"><span class="comment"> * 3、运行</span></span><br><span class="line"><span class="comment"> *     以前步骤都正确执行，代表容器running。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="生命周期全流程"><a href="#生命周期全流程" class="headerlink" title="生命周期全流程"></a>生命周期全流程</h3><p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/01/04/28084_image-1704377032144-1.png" alt="image"></p>
<h2 id="事件触发时机"><a href="#事件触发时机" class="headerlink" title="事件触发时机"></a>事件触发时机</h2><ul>
<li><p><strong>ApplicationListener：    感知全阶段：基于事件机制，感知事件。 一旦到了哪个阶段可以做别的事</strong></p>
</li>
<li><ul>
<li><code>@Bean</code>或<code>@EventListener</code>： <code>事件驱动</code></li>
<li><code>SpringApplication.addListeners(…)</code>或 <code>SpringApplicationBuilder.listeners(…)</code></li>
<li><code>META-INF/spring.factories</code></li>
</ul>
</li>
<li><p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/01/05/68286_image-1704437922998-1.png" alt="image"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ApplicationEvent&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====事件====到达====&quot;</span>+event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">org.springframework.context.ApplicationListener</span>=<span class="string">com.hdb.core.listener.MyListener</span></span><br></pre></td></tr></table></figure>
<p>应用事件发送顺序如下：</p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/01/05/52391_image 2.png" alt="image 2"></p>
<h2 id="SpringBoot-事件驱动开发"><a href="#SpringBoot-事件驱动开发" class="headerlink" title="SpringBoot 事件驱动开发"></a>SpringBoot 事件驱动开发</h2><p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/01/05/31052_image3.png" alt="image3"></p>
<h3 id="事件发布者"><a href="#事件发布者" class="headerlink" title="事件发布者"></a>事件发布者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventPublisher</span> <span class="keyword">implements</span> <span class="title class_">ApplicationEventPublisherAware</span> &#123;</span><br><span class="line">    ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有事件都可以发</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">//调用底层API发送事件</span></span><br><span class="line">        applicationEventPublisher.publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 会被自动调用，把真正发事件的底层组组件给我们注入进来</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> applicationEventPublisher event publisher to be used by this object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationEventPublisher = applicationEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="登录成功事件"><a href="#登录成功事件" class="headerlink" title="登录成功事件"></a>登录成功事件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登录成功事件。所有事件都推荐继承 ApplicationEvent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginSuccessEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  代表是谁登录成了</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginSuccessEvent</span><span class="params">(UserEntity source)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="service监听"><a href="#service监听" class="headerlink" title="service监听"></a>service监听</h3><p>方法一实现ApplicationListener接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountService</span>  <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;LoginSuccessEvent&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAccountScore</span><span class="params">(String username)</span>&#123;</span><br><span class="line">        System.out.println(username +<span class="string">&quot; 加了1分&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(LoginSuccessEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====  AccountService  收到事件 =====&quot;</span>);</span><br><span class="line">        <span class="type">UserEntity</span> <span class="variable">source</span> <span class="operator">=</span> (UserEntity) event.getSource();</span><br><span class="line">        addAccountScore(source.getUsername());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二，<code>@EventListener</code>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CouponService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(LoginSuccessEvent loginSuccessEvent)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===== CouponService ====感知到事件&quot;</span>+loginSuccessEvent);</span><br><span class="line">        <span class="type">UserEntity</span> <span class="variable">source</span> <span class="operator">=</span> (UserEntity) loginSuccessEvent.getSource();</span><br><span class="line">        sendCoupon(source.getUsername());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendCoupon</span><span class="params">(String username)</span>&#123;</span><br><span class="line">        System.out.println(username + <span class="string">&quot; 随机得到了一张优惠券&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LoginController"><a href="#LoginController" class="headerlink" title="LoginController"></a>LoginController</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    CouponService couponService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    SysService sysService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    EventPublisher eventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String username,</span></span><br><span class="line"><span class="params">                        <span class="meta">@RequestParam(&quot;passwd&quot;)</span>String passwd)</span>&#123;</span><br><span class="line">        <span class="comment">//业务处理登录</span></span><br><span class="line">        System.out.println(<span class="string">&quot;业务处理登录完成....&quot;</span>);</span><br><span class="line">        <span class="comment">//TODO 发送事件.</span></span><br><span class="line">        <span class="comment">//1、创建事件信息</span></span><br><span class="line">        <span class="type">LoginSuccessEvent</span> <span class="variable">event</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginSuccessEvent</span>(<span class="keyword">new</span> <span class="title class_">UserEntity</span>(username, passwd));</span><br><span class="line">        <span class="comment">//2、发送事件</span></span><br><span class="line">        eventPublisher.sendEvent(event);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> username+<span class="string">&quot;登录成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SPI机制"><a href="#SPI机制" class="headerlink" title="SPI机制"></a>SPI机制</h2><p>在Java中，<strong>SPI</strong>的实现方式是通过在<code>META-INF/services</code>目录下创建一个以服务接口全限定名为名字的文件，文件中包含实现该服务接口的类的全限定名。当应用程序启动时，Java的SPI机制会自动扫描classpath中的这些文件，并根据文件中指定的类名来加载实现类。</p>
<p>在SpringBoot中，<code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code></p>
<h2 id="功能开关"><a href="#功能开关" class="headerlink" title="功能开关"></a>功能开关</h2><ul>
<li><p>自动配置：全部都配置好，什么都不用管。   自动批量导入</p>
</li>
<li><ul>
<li>项目一启动，spi文件中指定的所有都加载。</li>
</ul>
</li>
<li><p><code>@EnableXxxx</code>：手动控制哪些功能的开启； 手动导入。</p>
</li>
<li><ul>
<li>开启xxx功能</li>
<li>都是利用 @Import 把此功能要用的组件导入进去</li>
</ul>
</li>
</ul>
<h2 id="理解-SpringBootApplication"><a href="#理解-SpringBootApplication" class="headerlink" title="理解@SpringBootApplication"></a>理解@SpringBootApplication</h2><p><code>@SpringBootConfiguration</code></p>
<p>就是： @Configuration ，容器中的组件，配置类。spring ioc启动就会加载创建这个类对象</p>
<p><code>@AutoConfigurationPackage</code>：扫描主程序包：加载自己的组件</p>
<blockquote>
<ul>
<li>利用 <code>@Import(AutoConfigurationPackages.Registrar.class)</code> 想要给容器中导入组件。</li>
<li>把主程序所在的<strong>包</strong>的所有组件导入进来。</li>
</ul>
</blockquote>
<p><code>@Import(AutoConfigurationImportSelector.class)</code>：加载所有自动配置类：加载starter导入的组件</p>
<p><code>@ComponentScan</code><br>组件扫描：排除一些组件（哪些不要）<br>排除前面已经扫描进来的配置类、和自动配置类。</p>
<h2 id="完整启动加载流程"><a href="#完整启动加载流程" class="headerlink" title="完整启动加载流程"></a>完整启动加载流程</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/svg/1613913/1682569555020-b6cbc750-3171-44c6-810f-1c59e590b792.svg" alt="自动配置进阶原理.svg"></p>
<h2 id="自定义starter"><a href="#自定义starter" class="headerlink" title="自定义starter"></a>自定义starter</h2><h3 id="1-配置处理器（省略）"><a href="#1-配置处理器（省略）" class="headerlink" title="1. 配置处理器（省略）"></a>1. 配置处理器（省略）</h3><p>导入配置处理器，配置文件自定义的properties配置都会有提示</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">&lt;dependency&gt;</span></span><br><span class="line">            <span class="attr">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">            <span class="attr">&lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span></span><br><span class="line">            <span class="attr">&lt;optional&gt;true&lt;/optional&gt;</span></span><br><span class="line"><span class="attr">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>2023版默认已经有提示了</p>
</blockquote>
<h3 id="2-业务代码"><a href="#2-业务代码" class="headerlink" title="2. 业务代码"></a>2. 业务代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;robot&quot;)</span>  <span class="comment">//此属性类和配置文件指定前缀绑定</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RobotProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-基本抽取"><a href="#3-1-基本抽取" class="headerlink" title="3.1 基本抽取"></a>3.1 基本抽取</h3><ul>
<li>创建starter项目，把公共代码需要的所有依赖导入</li>
</ul>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/01/08/22745_image-20240108195339109.png" alt="image-20240108195339109" style="zoom:67%;" /></p>
<ul>
<li>把公共代码复制进来</li>
<li><p>自己写一个 <code>RobotAutoConfiguration</code>，给容器中导入这个场景需要的所有组件</p>
</li>
<li><ul>
<li>为什么这些组件默认不会扫描进去？</li>
<li><strong>starter所在的包和引入它的项目的主程序所在的包不是父子层级</strong></li>
</ul>
</li>
<li><p>别人引用这个<code>starter</code>，直接导入这个 <code>RobotAutoConfiguration</code>,就能把这个场景的组件导入进来</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!--        自定义starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.hdb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>boot3-08-robot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>RobotAutoConfiguration</code>用<code>Import</code>导入了相关的组件，Boot306FeaturesApplication通过<code>Import</code>导入了<code>RobotAutoConfiguration</code>就可以使用robot相关服务了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>导入了(&#123;RobotController.class, RobotProperties.class, RobotService.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RobotAutoConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(RobotAutoConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Boot306FeaturesApplication</span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-使用-EnableXxx机制"><a href="#3-2-使用-EnableXxx机制" class="headerlink" title="3.2 使用@EnableXxx机制"></a>3.2 使用@EnableXxx机制</h3><p>在robot-starter的包里再写一个申明接口，模仿<code>EnableWebMvc</code>写法，在Boot306FeaturesApplication上添加注释<code>@EnableRobot</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(&#123;RobotAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableRobot &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/01/08/32500_image-20240108200942226.png" alt="image-20240108200942226" style="zoom:67%;" /></p>
<h3 id="3-3-完全自动配置"><a href="#3-3-完全自动配置" class="headerlink" title="3.3 完全自动配置"></a>3.3 完全自动配置</h3><ul>
<li>依赖SpringBoot的SPI机制</li>
<li>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports 文件中编写好我们自动配置类的全类名即可</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># org.springframework.boot.autoconfigure.AutoConfiguration.imports </span></span><br><span class="line"><span class="attr">com.hdb.boot3.starter.robot.RobotAutoConfiguration</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>springboot3</category>
      </categories>
      <tags>
        <tag>springboot3</tag>
      </tags>
  </entry>
  <entry>
    <title>git小技巧</title>
    <url>/2024/01/16/tips/git/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="git设置代理"><a href="#git设置代理" class="headerlink" title="git设置代理"></a>git设置代理</h2><span id="more"></span>
<h3 id="git中设置代理"><a href="#git中设置代理" class="headerlink" title="git中设置代理"></a>git中设置代理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:7890</span><br><span class="line">git config --global https.proxy http://127.0.0.1:7890</span><br></pre></td></tr></table></figure>
<h3 id="git取消代理"><a href="#git取消代理" class="headerlink" title="git取消代理"></a>git取消代理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure>
<h3 id="查询是否使用"><a href="#查询是否使用" class="headerlink" title="查询是否使用"></a>查询是否使用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy </span><br><span class="line">git config --global https.proxy </span><br></pre></td></tr></table></figure>
<h2 id="git更新命令"><a href="#git更新命令" class="headerlink" title="git更新命令"></a>git更新命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git update-git-for-windows</span><br></pre></td></tr></table></figure>
<h3 id="idea中配置代理（可选？）"><a href="#idea中配置代理（可选？）" class="headerlink" title="idea中配置代理（可选？）"></a>idea中配置代理（可选？）</h3><p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/11/27/42136_image-20231127202015854.png" alt="image-20231127202015854" style="zoom: 67%;" /></p>
<p>7890是clash的端口</p>
]]></content>
      <categories>
        <category>tips</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>clion小技巧</title>
    <url>/2024/01/16/tips/clion/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="How-to-link-ws2-32-in-Clion"><a href="#How-to-link-ws2-32-in-Clion" class="headerlink" title="How to link ws2_32 in Clion"></a>How to link ws2_32 in Clion</h2><p>The following CMakeLists.txt compiled error-less. Only 1 line is really required: <code>link_libraries(ws2_32 wsock32)</code></p>
<span id="more"></span>]]></content>
      <categories>
        <category>tips</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>clion</tag>
      </tags>
  </entry>
  <entry>
    <title>idea小技巧</title>
    <url>/2024/01/18/tips/idea/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<p>idea一些小技巧和设置</p>
<span id="more"></span>
<h2 id="保存自动格式化"><a href="#保存自动格式化" class="headerlink" title="保存自动格式化"></a>保存自动格式化</h2><p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/01/18/76210_image-20240118190445354.png" alt="image-20240118190445354" style="zoom: 50%;" /></p>
<h2 id="idea中配置代理"><a href="#idea中配置代理" class="headerlink" title="idea中配置代理"></a>idea中配置代理</h2><p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/11/27/42136_image-20231127202015854.png" alt="image-20231127202015854" style="zoom: 67%;" /></p>
<p>7890是clash的端口</p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><h3 id="try…catch"><a href="#try…catch" class="headerlink" title="try…catch"></a>try…catch</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CTRL +ALT + t</span><br></pre></td></tr></table></figure>
<h3 id="Override"><a href="#Override" class="headerlink" title="Override"></a>Override</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CTRL + I</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">CTRL + O</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>tips</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>word小技巧</title>
    <url>/2024/01/17/tips/word/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<p>关于word写作时的一些小技巧记录。</p>
<span id="more"></span>
<h2 id="word交叉引用多个参考文献"><a href="#word交叉引用多个参考文献" class="headerlink" title="word交叉引用多个参考文献"></a>word交叉引用多个参考文献</h2><p>1、在交叉应用多个文件后：<code>[4][5][6][7]</code></p>
<p>2、选中参考文献，右击选择切换域代码</p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/01/17/85877_image-20240117163758364.png" alt="image-20240117163758364"></p>
<p>3、在第一篇文献后添加 <code>\#“[0”</code>，最后一篇添加 <code>\#“0]”</code>，位于中间的文献添加 <code>#“”</code>，如上图</p>
<p>4、更新域</p>
<p>5、手动添加<code>-</code></p>
]]></content>
      <categories>
        <category>word</category>
      </categories>
      <tags>
        <tag>文书</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录-数组-链表-哈希表-指针-字符串-栈和队列-二叉树1</title>
    <url>/2024/01/16/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%951/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p><strong>本节包含：</strong></p>
<ul>
<li><strong>数组</strong></li>
<li><strong>链表</strong></li>
<li><strong>哈希表</strong></li>
<li><strong>字符串</strong></li>
<li><strong>双指针</strong></li>
<li><strong>栈和队列</strong></li>
<li><strong>二叉树（部分）</strong></li>
</ul>
<span id="more"></span>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 避免当 target 小于nums[0] nums[nums.length - 1]时多次循环运算</span></span><br><span class="line"><span class="keyword">if</span> (target &lt; nums[<span class="number">0</span>] || target &gt; nums[right]) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><h3 id="错误示例"><a href="#错误示例" class="headerlink" title="错误示例"></a>错误示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">displacement</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i+displacement &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] = nums[i + displacement];</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">                ++displacement;</span><br><span class="line">                <span class="keyword">if</span>(i+displacement&lt;nums.length)&#123;</span><br><span class="line">                    <span class="comment">//未考虑nums[i + displacement]=val</span></span><br><span class="line">                    nums[i] = nums[i + displacement];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            System.out.println(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.length - displacement;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用while循环"><a href="#使用while循环" class="headerlink" title="使用while循环"></a>使用while循环</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(nums[i] == val) &#123;</span><br><span class="line">                ++displacement;</span><br><span class="line">                <span class="keyword">if</span>(i+displacement&lt;nums.length)&#123;</span><br><span class="line">                    nums[i] = nums[i + displacement];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用快慢指针"><a href="#使用快慢指针" class="headerlink" title="使用快慢指针"></a>使用快慢指针</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">removeElementFastLowPoint</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slowIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fastIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (fastIndex = <span class="number">0</span>; fastIndex &lt; nums.length; fastIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fastIndex] != val) &#123;</span><br><span class="line">                nums[slowIndex] = nums[fastIndex];</span><br><span class="line">                slowIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h2><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p>
<h3 id="法一：中间向两边"><a href="#法一：中间向两边" class="headerlink" title="法一：中间向两边"></a>法一：中间向两边</h3><p>找到平方值最小的数的index，向左右两边遍历比较</p>
<h3 id="法二：两边向中间遍历"><a href="#法二：两边向中间遍历" class="headerlink" title="法二：两边向中间遍历"></a>法二：两边向中间遍历</h3><p>比较左右两边的平方值，res[]从最后开始填充</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] sortedSquaresTwo(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r= nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span>  <span class="operator">=</span> nums.length-<span class="number">1</span>;<span class="comment">//新数组从最后开始填充</span></span><br><span class="line">        <span class="type">int</span> []res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">while</span> (l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>((nums[l]*nums[l])&lt;=nums[r]*nums[r])&#123;</span><br><span class="line">                res[k] = nums[r]*nums[r];</span><br><span class="line">                k--;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res[k] = nums[l]*nums[l];</span><br><span class="line">                k--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h2><p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p>
<p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 <strong>连续子数组</strong> <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> </p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p>
<p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p>
<p>窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）—-&gt;i++。</p>
<p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引——&gt;j++。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 滑动窗口起始位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 滑动窗口数值之和</span></span><br><span class="line">        <span class="type">int</span> subStrLen;<span class="comment">// 滑动窗口的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="comment">// 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件</span></span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">                subStrLen = j - i + <span class="number">1</span>;</span><br><span class="line">                res = subStrLen &lt; res ? subStrLen : res;</span><br><span class="line">                sum -= nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res == Integer.MAX_VALUE)</span><br><span class="line">            res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h2><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>循环不变量原则</strong></p>
<p>模拟顺时针画矩阵的过程:</p>
<ul>
<li>填充上行从左到右</li>
<li>填充右列从上到下</li>
<li>填充下行从右到左</li>
<li>填充左列从下到上</li>
</ul>
<p>由外向内一圈一圈这么画下去。</p>
<p>这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开右闭的原则，这样这一圈才能按照统一的规则画下来。</p>
<p>按照左闭右开的原则代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//转的圈数</span></span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">while</span> (loop++ &lt; n / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">//上：从左向右填充</span></span><br><span class="line">            <span class="keyword">for</span> (j = start; j &lt; n - loop; j++) &#123;</span><br><span class="line">                res[start][j] = value++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//右：从上往下填充</span></span><br><span class="line">            <span class="keyword">for</span> (i = start; i &lt; n - loop; i++) &#123;</span><br><span class="line">                res[i][j] = value++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//下：从右往左填充</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt; loop - <span class="number">1</span>; j--) &#123;</span><br><span class="line">                res[i][j] = value++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (; i &gt; loop - <span class="number">1</span>; i--) &#123;</span><br><span class="line">                res[i][j] = value++;</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            res[start][start] = value;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h2><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line"><span class="comment">//判断头节点是否是val，一定要先判断空，不然后报错</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span> &amp;&amp; head.val == val) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p.next != <span class="literal">null</span> &amp;&amp; p.next.val == val) &#123;</span><br><span class="line">                p.next = p.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>两个指针，同时还要单独考虑头节点删除，其余情况下直接返回原头节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="comment">//删除的前指针和最终将会指向最后一个节点的指针</span></span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> head;</span><br><span class="line">       pre.next = head;</span><br><span class="line">       <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">       <span class="comment">//pre和tail拉开间隔n</span></span><br><span class="line">       <span class="keyword">while</span> (tail!=<span class="literal">null</span> &amp;&amp; count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           tail = tail.next;</span><br><span class="line">           count--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//指针一直相对距离不变，tali变为尾节点</span></span><br><span class="line">       <span class="keyword">while</span> (tail.next != <span class="literal">null</span>)&#123;</span><br><span class="line">           tail = tail.next;</span><br><span class="line">           pre = pre.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//删除头节点</span></span><br><span class="line">       <span class="keyword">if</span>(pre.next==head)</span><br><span class="line">       &#123;</span><br><span class="line">           head =head.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//删除del节点</span></span><br><span class="line">       pre.next = pre.next.next;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> head;</span><br></pre></td></tr></table></figure>
<h3 id="代码随想录解题思路"><a href="#代码随想录解题思路" class="headerlink" title="代码随想录解题思路"></a>代码随想录解题思路</h3><p>定义了一个虚拟头节点<code>dummyNode</code>，返回的头节点是<code>dummyNode.next</code></p>
<h2 id="环形链表II"><a href="#环形链表II" class="headerlink" title="环形链表II"></a>环形链表II</h2><p>题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>假设从头结点到环形入口节点 的节点数为x。 环形入口节点到 fast指针与slow指针相遇节点 节点数为y。 从相遇节点 再到环形入口节点节点数为 z。 如图所示：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220925103433.png" alt="img"></p>
<p>那么相遇时： slow指针走过的节点数为: <code>x + y</code>， fast指针走过的节点数：<code>x + y + n (y + z)</code>，n为fast指针在环内走了n圈才遇到slow指针， （y+z）为 一圈内节点的个数A。</p>
<p>因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 = slow指针走过的节点数 * 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(x + y) * 2 = x + y + n (y + z)</span><br></pre></td></tr></table></figure>
<p>两边消掉一个（x+y）: <code>x + y = n (y + z)</code></p>
<p>因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。</p>
<p>所以要求x ，将x单独放在左面：<code>x = n (y + z) - y</code> ,</p>
<p>再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：<code>x = (n - 1) (y + z) + z</code> 注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。</p>
<p>这个公式说明什么呢？</p>
<p>先拿n为1的情况来举例，意味着fast指针在环形里转了一圈之后，就遇到了 slow指针了。</p>
<p>当 n为1的时候，公式就化解为 <code>x = z</code>，</p>
<p>这就意味着，<strong>从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点</strong>。</p>
<p>也就是在相遇节点处，定义一个指针index1，在头结点处定一个指针index2。</p>
<p>让index1和index2同时移动，每次移动一个节点， 那么他们相遇的地方就是 环形入口的节点。</p>
<p>那么 n如果大于1是什么情况呢，就是fast指针在环形转n圈之后才遇到 slow指针。</p>
<p>其实这种情况和n为1的时候 效果是一样的，一样可以通过这个方法找到 环形的入口节点，只不过，index1 指针在环里 多转了(n-1)圈，然后再遇到index2，相遇点依然是环形的入口节点。</p>
<h3 id="自己的方法"><a href="#自己的方法" class="headerlink" title="自己的方法"></a>自己的方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span> || head.next.next == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">low</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span> &amp;&amp; fast != low) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            low = low.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fast.next == <span class="literal">null</span> || fast.next.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        low = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast != low) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            low = low.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>判断太多，内存占用过多</p>
<h3 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;<span class="comment">// 有环</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index1</span> <span class="operator">=</span> fast;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index2</span> <span class="operator">=</span> head;</span><br><span class="line">                <span class="comment">// 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口</span></span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1.next;</span><br><span class="line">                    index2 = index2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>哈希表是根据关键码的值而直接进行访问的数据结构。</p>
<h2 id="三种哈希结构"><a href="#三种哈希结构" class="headerlink" title="三种哈希结构"></a>三种哈希结构</h2><ul>
<li>数组</li>
<li>set （集合）</li>
<li>map(映射)</li>
</ul>
<blockquote>
<p>std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>映射</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody>
<tr>
<td>std::map</td>
<td>红黑树</td>
<td>key有序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::multimap</td>
<td>红黑树</td>
<td>key有序</td>
<td>key可重复</td>
<td>key不可修改</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::unordered_map</td>
<td>哈希表</td>
<td>key无序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
</div>
<p>当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。</p>
<p>在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。</p>
<h2 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h2><p><strong>而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</strong></p>
<p>此时就要使用另一种结构体了，set </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">       <span class="keyword">if</span> (nums1 == <span class="literal">null</span> || nums1.length == <span class="number">0</span> || nums2 == <span class="literal">null</span> || nums2.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">       Set&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">           set1.add(i);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i : nums2) &#123;</span><br><span class="line">           <span class="keyword">if</span> (set1.contains(i))</span><br><span class="line">           &#123;</span><br><span class="line">               res.add(i);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> res.stream().mapToInt(x -&gt; x).toArray();</span><br></pre></td></tr></table></figure>
<h2 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h2><p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p>
<p><strong>「快乐数」</strong> 定义为：</p>
<ul>
<li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li>
<li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li>
<li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li>
</ul>
<p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题目使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。</p>
<h2 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h2><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。</p>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>首先定义 一个Map，key放a和b两数之和，value 放a和b两数之和出现的次数。</li>
<li>遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。</li>
<li>定义int变量count，用来统计 a+b+c+d = 0 出现的次数。</li>
<li>在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。</li>
<li>最后返回统计值 count 就可以了</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> sum;</span><br><span class="line">       Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> j : nums2) &#123;</span><br><span class="line">               sum = i + j;</span><br><span class="line">               <span class="comment">//如果map中存在sum这个键，则返回map中对应的键对应的值，如果不存在，则返回0</span></span><br><span class="line">               map.put(sum,map.getOrDefault(sum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i : nums3) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> j : nums4) &#123;</span><br><span class="line">               sum =<span class="number">0</span>- i - j;</span><br><span class="line">               res = res+ map.getOrDefault(sum,<span class="number">0</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h2><p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code> ，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。</p>
<p>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。</p>
<p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= ransomNote.length, magazine.length &lt;= 105</code></li>
<li><code>ransomNote</code> 和 <code>magazine</code> 由小写英文字母组成</li>
</ul>
<h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为题目说只有小写字母，那可以采用空间换取时间的哈希策略，用一个长度为26的数组来记录magazine里字母出现的次数。然后依次读取ransomNote的字母次数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ransomNote.length() &gt; magazine.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] records = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; magazine.length(); i++) &#123;</span><br><span class="line">            records[magazine.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ransomNote.length(); i++) &#123;</span><br><span class="line">            records[ransomNote.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> record : records) &#123;</span><br><span class="line">            <span class="keyword">if</span>(record&lt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>字符串转化为字符数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">char</span> c : magazine.toCharArray())&#123;</span><br><span class="line">           record[c - <span class="string">&#x27;a&#x27;</span>] += <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><p>首先将数组排序，然后有一层for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。</p>
<p>依然还是在数组中找到 abc 使得a + b +c =0，我们这里相当于 a = nums[i]，b = nums[left]，c = nums[right]。</p>
<ul>
<li>如果nums[i] + nums[left] + nums[right] &gt; 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。</li>
<li>如果 nums[i] + nums[left] + nums[right] &lt; 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。</li>
</ul>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif" alt="15.三数之和"></p>
<h3 id="难点一：a的去重"><a href="#难点一：a的去重" class="headerlink" title="难点一：a的去重"></a>难点一：a的去重</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//去除num[i]重复的三元组</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) &#123; <span class="comment">// 去重操作</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//三元组中出现重复元素的情况直接pass掉了，如&#123;-1，-1，2&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="难点二：bc去重"><a href="#难点二：bc去重" class="headerlink" title="难点二：bc去重"></a>难点二：bc去重</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right-<span class="number">1</span>]) right--;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left+<span class="number">1</span>]) left++;</span><br><span class="line">right--;</span><br><span class="line">left++;</span><br></pre></td></tr></table></figure>
<h3 id="总的代码"><a href="#总的代码" class="headerlink" title="总的代码"></a>总的代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//去除num[i]重复的三元组</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//采用双指针，left=i+1，right从末尾开始排</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> temp;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                temp = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//将三元组加入res，并尝试找剩下的符合的三元组</span></span><br><span class="line">                    res.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right-<span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left+<span class="number">1</span>]) left++;</span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符反转"><a href="#字符反转" class="headerlink" title="字符反转"></a>字符反转</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须<strong><a href="https://baike.baidu.com/item/原地算法">原地</a>修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。</p>
<h3 id="自己"><a href="#自己" class="headerlink" title="自己"></a>自己</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> tmp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            tmp = s[i];</span><br><span class="line">            s[i] = s[r - i];</span><br><span class="line">            s[r - i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="法二-1"><a href="#法二-1" class="headerlink" title="法二"></a>法二</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">           s[l] ^= s[r];  <span class="comment">//构造 a ^ b 的结果，并放在 a 中</span></span><br><span class="line">           s[r] ^= s[l];  <span class="comment">//将 a ^ b 这一结果再 ^ b ，存入b中，此时 b = a, a = a ^ b</span></span><br><span class="line">           s[l] ^= s[r];  <span class="comment">//a ^ b 的结果再 ^ a ，存入 a 中，此时 b = a, a = b 完成交换</span></span><br><span class="line">           l++;</span><br><span class="line">           r--;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h2 id="翻转字符串里的单词"><a href="#翻转字符串里的单词" class="headerlink" title="翻转字符串里的单词"></a>翻转字符串里的单词</h2><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p>
<p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p>
<p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p>
<p><strong>注意：</strong>输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>
<h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><ul>
<li>移除多余空格</li>
<li>将整个字符串反转</li>
<li>将每个单词反转</li>
</ul>
<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>创建新字符数组填充。时间复杂度O(n)</p>
<p>从后往前找到单词，需要两个指针，新的数组将单词从0开始装入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] originArray = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] newArray = <span class="keyword">new</span> <span class="title class_">char</span>[originArray.length + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//newArray position</span></span><br><span class="line">        <span class="comment">//从orinArray最右边开始从左遍历，将单词一个一个读入到newArray</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> originArray.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> left, right;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//去除右边空格</span></span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; originArray[i] == <span class="string">&#x27; &#x27;</span>) i--;</span><br><span class="line">            right = i;</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; originArray[i] != <span class="string">&#x27; &#x27;</span>) i--;</span><br><span class="line">            left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = left; j &lt;= right; j++) &#123;</span><br><span class="line">                newArray[pos++] = originArray[j];</span><br><span class="line">                <span class="comment">//很关键，这里每次都给一个但单词加一个空格，</span></span><br><span class="line">                <span class="comment">//若String最前面是空格，for循环条件left=0，right=-1</span></span><br><span class="line">                <span class="keyword">if</span> (j == right)</span><br><span class="line">                    newArray[pos++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        现在pos由于最后++是包含最后一个空格加1的位置处，pos-2+1=pos-1才是字符串的长度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(newArray, <span class="number">0</span>, pos-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="前缀表"><a href="#前缀表" class="headerlink" title="前缀表"></a>前缀表</h2><p>KMP（Knuth-Morris-Pratt）算法是一种用于在<strong>文本中查找子串</strong>的字符串匹配算法。该算法的核心思想是利用已经匹配过的部分信息来避免不必要的字符比较，从而提高匹配效率。KMP算法的一个关键部分是构建和使用”前缀表”（prefix table）或称为”部分匹配表”（partial match table）。</p>
<p>前缀是指不包含最后一个字符的<strong>所有</strong>以第一个字符开头的连续子串；后缀是指不包含第一个字符的<strong>所有</strong>以最后一个字符结尾的连续子串</p>
<p><img src="C:\data\mysoftware\Typora\typoraPicture\KMP8-1700019395365-3-1700019524869-5.png" alt="KMP8"></p>
<p><strong>初始化：j指向前缀末尾位置，i指向后缀末尾位置。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span>[] next, String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s.charAt(j) != s.charAt(i)) </span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(j) == s.charAt(i)) </span><br><span class="line">                j++;</span><br><span class="line">            next[i] = j; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[needle.length()];</span><br><span class="line">        getNext(next, needle);</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//匹配的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; haystack.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack.charAt(i) != needle.charAt(j)) j = next[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (haystack.charAt(i) == needle.charAt(j)) j++;</span><br><span class="line">            <span class="keyword">if</span> (j == needle.length()) <span class="keyword">return</span> i - needle.length() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h2><ol>
<li>java中栈的初始化</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack&lt;Integer&gt;  stackOut = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;()；</span><br></pre></td></tr></table></figure>
<ol>
<li><p><code>push，pop，peek，isEmpty</code>函数</p>
</li>
<li><p>封装栈之间的转移函数</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inToOut</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (stackOut.empty()) &#123;</span><br><span class="line">           <span class="keyword">while</span> (!stackIn.empty()) &#123;</span><br><span class="line">               stackOut.push(stackIn.pop());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h2><ol>
<li><p><strong>队列是先进先出，两个队列之间直接转移数据，数据的排序不变</strong></p>
</li>
<li><p>一个队列的方法是每次将队尾元素平移到队首</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveSize_1</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; queue.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">           queue.offer(queue.poll());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>peek方法需要注意，调用<code>moveSize_1</code>后，留存第一个结果后需要再次移动一次复原队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        moveSize_1();</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> queue.peek();</span><br><span class="line">        queue.offer(queue.poll());</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>队列初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p><code>offer(element)</code>: 该方法用于将指定的元素插入到队列的末尾（类似于<code>add</code>方法），如果队列已满则返回<code>false</code>，否则返回<code>true</code>。</p>
<p><code>add(element)</code>: 将元素添加到链表的末尾。</p>
<p><code>size()</code>: 获取链表中元素的数量。</p>
<p><code>clear()</code>: 清空链表中的所有元素。</p>
<p><code>toArray()</code>: 将链表转换为数组。</p>
<p><code>peek()</code>: 该方法返回队列的头部（第一个元素），但不移除该元素。如果队列为空，则返回<code>null</code>。</p>
<p><code>poll</code>是一个用于队列操作的方法，它用于检索并删除队列的头部（第一个元素）。如果队列为空，则<code>poll</code>方法返回<code>null</code>。</p>
<p>使用迭代器（<code>Iterator</code>）进行遍历。</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = linkedList.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h2><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ol>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>往栈中只压入压入左括号，匹配到右括号时必须与栈顶元素相同，否则<code>return false</code>，最后查看栈是否为空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            c = transParentheis(s.charAt(i));</span><br><span class="line">            <span class="comment">//左括号压入栈</span></span><br><span class="line">            <span class="keyword">if</span> (c != s.charAt(i))</span><br><span class="line">                stack.push(c);</span><br><span class="line">                <span class="comment">//匹配到右括号，弹出栈</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; stack.peek() == c)</span><br><span class="line">                stack.pop();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> Character <span class="title function_">transParentheis</span><span class="params">(Character s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">switch</span> (s) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span> -&gt; <span class="string">&#x27;]&#x27;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span> -&gt; <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span> -&gt; <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            <span class="keyword">default</span> -&gt; s;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047.删除字符串中的所有相邻重复项"></a>1047.删除字符串中的所有相邻重复项</h2><p>给出由小写字母组成的字符串 <code>S</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ol>
<li>用栈，判断栈顶和新加入的元素是否相同，但是多了一步将栈转化为字符串</li>
<li>直接用字符串</li>
<li>用双指针</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; s.length())&#123;</span><br><span class="line">            <span class="comment">// 直接用fast指针覆盖slow指针的值</span></span><br><span class="line">            ch[slow] = ch[fast];</span><br><span class="line">            <span class="comment">// 遇到前后相同值的，就跳过，即slow指针后退一步，下次循环就可以直接被覆盖掉了</span></span><br><span class="line">            <span class="keyword">if</span>(slow &gt; <span class="number">0</span> &amp;&amp; ch[slow] == ch[slow - <span class="number">1</span>])&#123;</span><br><span class="line">                slow--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch,<span class="number">0</span>,slow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h2><p>逆波兰表达式：是一种后缀表达式，所谓后缀就是指运算符写在后面。</p>
<p>平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。</p>
<p>该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。</p>
<p>逆波兰表达式主要有以下两个优点：</p>
<ul>
<li>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。</li>
<li>适合用栈操作运算：遇到数字则入栈；遇到运算符则取出栈顶两个数字进行计算，并将结果压入栈中。</li>
</ul>
<p><strong>其实逆波兰表达式相当于是二叉树中的后序遍历</strong></p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p><img src="https://code-thinking.cdn.bcebos.com/gifs/150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.gif" alt="150.逆波兰表达式求值"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Deque&lt;Integer&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">            stackOperation(token);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stackOperation</span><span class="params">(String c)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span> -&gt; stack.push(stack.pop() + stack.pop());</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span> -&gt; stack.push(-stack.pop() + stack.pop());</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span> -&gt; stack.push(stack.pop() * stack.pop());</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span> -&gt; &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                stack.push(num2 / num1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span> -&gt; stack.push(Integer.valueOf(c));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Deque详解"><a href="#Deque详解" class="headerlink" title="Deque详解"></a>Deque详解</h2><p><a href="https://blog.csdn.net/devnn/article/details/82716447">参考博客</a></p>
<p>Deque有三种用途：</p>
<ol>
<li>普通队列(一端进另一端出:<br><code>Queue queue = new LinkedList()</code>或<code>Deque deque = new LinkedList()</code></li>
<li>双端队列(两端都可进出)<br><code>Deque deque = new LinkedList()</code></li>
<li>堆栈<br><code>Deque deque = new LinkedList()</code></li>
</ol>
<p>Deque接口扩展(继承)了 <code>Queue</code> 接口。在将双端队列用作队列时，将得到 FIFO（先进先出）行为。将元素添加到双端队列的末尾，从双端队列的开头移除元素。从 Queue 接口继承的方法完全等效于 Deque 方法，如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><strong>Queue方法</strong></th>
<th style="text-align:center"><strong>等效Deque方法</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">add(e)</td>
<td style="text-align:center">addLast(e)</td>
</tr>
<tr>
<td style="text-align:center">offer(e)</td>
<td style="text-align:center">offerLast(e)</td>
</tr>
<tr>
<td style="text-align:center">remove()</td>
<td style="text-align:center">removeFirst()</td>
</tr>
<tr>
<td style="text-align:center">poll()</td>
<td style="text-align:center">pollFirst()</td>
</tr>
<tr>
<td style="text-align:center">element()</td>
<td style="text-align:center">getFirst()</td>
</tr>
<tr>
<td style="text-align:center">peek()</td>
<td style="text-align:center">peekFirst()</td>
</tr>
</tbody>
</table>
</div>
<p>双端队列也可用作 LIFO（后进先出）堆栈。应优先使用此接口而不是遗留 <code>Stack</code> 类。在将双端队列用作堆栈时，元素被推入双端队列的开头并从双端队列开头弹出。堆栈方法完全等效于 Deque 方法，如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>堆栈方法</strong></th>
<th><strong>等效Deque方法</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>push(e)</td>
<td>addFirst(e)</td>
</tr>
<tr>
<td>pop()</td>
<td>removeFirst()</td>
</tr>
<tr>
<td>peek()</td>
<td>peekFirst()</td>
</tr>
</tbody>
</table>
</div>
<h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239.滑动窗口最大值"></a>239.滑动窗口最大值</h2><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回 <em>滑动窗口中的最大值</em> 。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol>
<li>我们需要一个队列，这个队列呢，放进去窗口里的元素，然后随着窗口的移动，队列也一进一出，每次移动之后，队列告诉我们里面的最大值是什么。</li>
<li>队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素<strong>数值是由大到小</strong>的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">poll</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!queue.isEmpty() &amp;&amp; val == queue.getFirst())</span><br><span class="line">            queue.pollFirst();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; queue.peekLast() &lt; val) &#123;</span><br><span class="line">            queue.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        queue.addLast(val);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="前K个高频元素"><a href="#前K个高频元素" class="headerlink" title="前K个高频元素"></a>前K个高频元素</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>用小根堆求解前k个最大值</p>
<p>采用优先队列实现小根堆</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;<span class="type">int</span>[]&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.comparingInt(pair -&gt; pair[<span class="number">1</span>]));</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">PriorityQueue&lt;<span class="type">int</span>[]&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.comparingInt((pair1,pair2)-&gt;pair1[<span class="number">1</span>]-pair2[<span class="number">1</span>]));</span><br></pre></td></tr></table></figure>
<p>若想初始化大根堆，则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;<span class="type">int</span>[]&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((pair1,pair2)-&gt;pair2[<span class="number">1</span>]-pair1[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<p><code>int[]</code>第一个值存<code>nums[i]</code>即key，第二个值存次数，即<code>value</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet())</span><br></pre></td></tr></table></figure>
<p>迭代取map中的<code>&lt;key,value&gt;</code></p>
<p><strong>PriorityQueue常用函数</strong></p>
<ul>
<li><code>add(E e)</code> 或 <code>offer(E e)</code>：向队列中添加元素。</li>
<li><code>poll()</code>：检索并删除队列中的最小元素。</li>
<li><code>peek()</code>：检索但不删除队列中的最小元素。</li>
<li><code>remove(Object o)</code>：从队列中删除指定的元素。</li>
<li><code>size()</code>：返回队列中的元素个数。</li>
</ul>
<h2 id="二叉树理论"><a href="#二叉树理论" class="headerlink" title="二叉树理论"></a>二叉树理论</h2><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/12/18/99820_20200806185805576.png" alt="20200806185805576" style="zoom:50%;" /></p>
<p>这棵二叉树为满二叉树，也可以说深度为k，有2^k-1个节点的二叉树。</p>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/12/18/19370_20200920221638903.png" alt="20200920221638903" style="zoom:50%;" /></p>
<h3 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h3><p>平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/12/21/45815_20200806190511967.png" alt="20200806190511967"></p>
<h3 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h3><p><strong>二叉树可以链式存储，也可以顺序存储。</strong></p>
<p>那么链式存储方式就用指针， 顺序存储的方式就是用数组。</p>
<p>用数组来存储二叉树如何遍历的呢？</p>
<p><strong>如果父节点的数组下标是 i，那么它的左孩子就是 i <em> 2 + 1，右孩子就是 i </em> 2 + 2。</strong></p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/12/21/13082_20200920200429452.png" alt="20200920200429452" style="zoom:50%;" /></p>
<h2 id="前序遍历（递归）"><a href="#前序遍历（递归）" class="headerlink" title="前序遍历（递归）"></a>前序遍历（递归）</h2><p>节点为空，返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        preorder(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode treeNode, List&lt;Integer&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (treeNode == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        res.add(treeNode.val);</span><br><span class="line">        preorder(treeNode.left, res);</span><br><span class="line">        preorder(treeNode.right, res);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的统一迭代法"><a href="#二叉树的统一迭代法" class="headerlink" title="二叉树的统一迭代法"></a>二叉树的统一迭代法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序遍历（迭代法），栈进入顺序：右左前null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> res</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) st.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> st.peek();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">                st.pop(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) st.push(node.right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line">                <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) st.push(node.left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">                st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.push(<span class="literal">null</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.pop();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.peek();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.pop();</span><br><span class="line">                result.add(node.val); <span class="comment">// 加入到结果集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><h3 id="BFS-迭代方式"><a href="#BFS-迭代方式" class="headerlink" title="BFS-迭代方式"></a>BFS-迭代方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkFun02</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;  <span class="comment">// 如果节点为空，则直接返回</span></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();  <span class="comment">// 创建一个队列，用于层序遍历树</span></span><br><span class="line">    queue.offer(node);  <span class="comment">// 将根节点加入队列</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;  <span class="comment">// 队列不为空时循环</span></span><br><span class="line">        List&lt;Integer&gt; levelList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  <span class="comment">// 创建一个列表，用于存储当前层的节点值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> queue.size();  <span class="comment">// 获取当前层的节点数量</span></span><br><span class="line">        <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;  <span class="comment">// 当前层的节点遍历</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">tmpNode</span> <span class="operator">=</span> queue.poll();  <span class="comment">// 从队列中取出一个节点</span></span><br><span class="line">            levelList.add(tmpNode.val);  <span class="comment">// 将节点的值添加到当前层的列表中</span></span><br><span class="line">            <span class="keyword">if</span> (tmpNode.left != <span class="literal">null</span>) queue.offer(tmpNode.left);  <span class="comment">// 如果有左子节点，则将左子节点加入队列</span></span><br><span class="line">            <span class="keyword">if</span> (tmpNode.right != <span class="literal">null</span>) queue.offer(tmpNode.right);  <span class="comment">// 如果有右子节点，则将右子节点加入队列</span></span><br><span class="line">            len--;  <span class="comment">// 节点数量减一</span></span><br><span class="line">        &#125;</span><br><span class="line">        res.add(levelList);  <span class="comment">// 将当前层的节点值列表添加到结果中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DFS-递归方式"><a href="#DFS-递归方式" class="headerlink" title="DFS-递归方式"></a>DFS-递归方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkFunc01</span><span class="params">(TreeNode node, Integer deep)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">       deep++;</span><br><span class="line">       <span class="keyword">if</span> (res.size() &lt; deep) &#123;<span class="comment">//为二叉树每一层分配空间存储</span></span><br><span class="line">           List&lt;Integer&gt; levelList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">           res.add(levelList);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//对应层存储元素</span></span><br><span class="line">       res.get(deep - <span class="number">1</span>).add(node.val);</span><br><span class="line"></span><br><span class="line">       checkFunc01(node.left, deep);</span><br><span class="line">       checkFunc01(node.right, deep);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="层序遍历2"><a href="#层序遍历2" class="headerlink" title="层序遍历2"></a>层序遍历2</h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值 <strong>自底向上的层序遍历</strong> 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<h3 id="法1"><a href="#法1" class="headerlink" title="法1"></a>法1</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//法一，用Collections.reverse方法反转</span><br><span class="line">Collections.reverse(res);</span><br></pre></td></tr></table></figure>
<h3 id="法2"><a href="#法2" class="headerlink" title="法2"></a>法2</h3><p>在<code>BFS-迭代方式</code>的函数基础上，将res的每层数据插入的顺序变为头插入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkFun02Dual</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;  <span class="comment">// 如果节点为空，则直接返回</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();  <span class="comment">// 创建一个队列，用于层序遍历树</span></span><br><span class="line">        queue.offer(node);  <span class="comment">// 将根节点加入队列</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;  <span class="comment">// 队列不为空时循环</span></span><br><span class="line">            List&lt;Integer&gt; levelList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  <span class="comment">// 创建一个列表，用于存储当前层的节点值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> queue.size();  <span class="comment">// 获取当前层的节点数量</span></span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;  <span class="comment">// 当前层的节点遍历</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">tmpNode</span> <span class="operator">=</span> queue.poll();  <span class="comment">// 从队列中取出一个节点</span></span><br><span class="line">                levelList.add(tmpNode.val);  <span class="comment">// 将节点的值添加到当前层的列表中</span></span><br><span class="line">                <span class="keyword">if</span> (tmpNode.left != <span class="literal">null</span>) queue.offer(tmpNode.left);  <span class="comment">// 如果有左子节点，则将左子节点加入队列</span></span><br><span class="line">                <span class="keyword">if</span> (tmpNode.right != <span class="literal">null</span>) queue.offer(tmpNode.right);  <span class="comment">// 如果有右子节点，则将右子节点加入队列</span></span><br><span class="line">                len--;  <span class="comment">// 节点数量减一</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//每层倒叙插入</span></span><br><span class="line">            res.add(<span class="number">0</span>, levelList);  <span class="comment">// 将当前层的节点值列表添加到结果中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="N叉树的层序遍历"><a href="#N叉树的层序遍历" class="headerlink" title="N叉树的层序遍历"></a>N叉树的层序遍历</h2><h3 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h3><p>采用递归方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">levelOrderN</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; resList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        recursiveNTree(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recursiveNTree</span><span class="params">(Node node, Integer deep)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        deep++;</span><br><span class="line">        <span class="keyword">if</span> (resList.size() &lt; deep) &#123;</span><br><span class="line">            List&lt;Integer&gt; curLevel = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            resList.add(curLevel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加入当前的节点</span></span><br><span class="line">        resList.get(deep - <span class="number">1</span>).add(node.val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历子节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node child : node.children) &#123;</span><br><span class="line">            recursiveNTree(child, deep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h2><p>推荐方法，递归法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>左子树和右子树的最大深度 <em>l</em> 和 <em>r</em>，那么该二叉树的最大深度即为</p>
<script type="math/tex; mode=display">
m a x ( l , r ) + 1</script>]]></content>
      <categories>
        <category>code_Musing</category>
      </categories>
      <tags>
        <tag>arrays</tag>
        <tag>linkList</tag>
        <tag>hashMap</tag>
        <tag>point</tag>
        <tag>String</tag>
        <tag>Stack</tag>
        <tag>Queue</tag>
        <tag>binaryTree</tag>
      </tags>
  </entry>
  <entry>
    <title>pycharm小技巧</title>
    <url>/2024/01/16/tips/pycharm/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<span id="more"></span>
<h2 id="开启show-comand-queue-gt-gt-gt"><a href="#开启show-comand-queue-gt-gt-gt" class="headerlink" title="开启show comand queue(&gt;&gt;&gt;)"></a>开启show comand queue(&gt;&gt;&gt;)</h2><p><code>Build, Execution, Deployment</code>-&gt;<code>Console</code> -&gt;<code>Command queue for Python Console</code></p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/03/21/69433_image-20240321195659243.png" alt="image-20240321195659243"></p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2023/10/23/43666_image-20231023163651677.png" alt="image-20231023163651677" style="zoom: 50%;" /></p>
<h2 id="查看模型结构"><a href="#查看模型结构" class="headerlink" title="查看模型结构"></a>查看模型结构</h2><p>法一：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(model)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      (11): RobertaLayer(</span><br><span class="line">        (attention): RobertaAttention(</span><br><span class="line">          (self): RobertaSelfAttention(</span><br><span class="line">            (query): Linear(in_features=768, out_features=768, bias=True)</span><br><span class="line">            (key): Linear(in_features=768, out_features=768, bias=True)</span><br><span class="line">            (value): Linear(in_features=768, out_features=768, bias=True)</span><br><span class="line">            (dropout): Dropout(p=0.1, inplace=False)</span><br><span class="line">          )</span><br><span class="line">          (output): RobertaSelfOutput(</span><br><span class="line">            (dense): Linear(in_features=768, out_features=768, bias=True)</span><br><span class="line">            (LayerNorm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)</span><br><span class="line">            (dropout): Dropout(p=0.1, inplace=False)</span><br><span class="line">          )</span><br><span class="line">        )</span><br><span class="line">        (intermediate): RobertaIntermediate(</span><br><span class="line">          (dense): Linear(in_features=768, out_features=3072, bias=True)</span><br><span class="line">          (intermediate_act_fn): GELUActivation()</span><br><span class="line">        )</span><br><span class="line">        (output): RobertaOutput(</span><br><span class="line">          (dense): Linear(in_features=3072, out_features=768, bias=True)</span><br><span class="line">          (LayerNorm): LayerNorm((768,), eps=1e-05, elementwise_affine=True)</span><br><span class="line">          (dropout): Dropout(p=0.1, inplace=False)</span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  (pooler): RobertaPooler(</span><br><span class="line">    (dense): Linear(in_features=768, out_features=768, bias=True)</span><br><span class="line">    (activation): Tanh()</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>法二：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> name, parameters <span class="keyword">in</span> model.named_parameters():</span><br><span class="line">    <span class="built_in">print</span>(name, <span class="string">&#x27;:&#x27;</span>, parameters.size())</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">encoder.layer.11.attention.self.query.bias : torch.Size([768])</span><br><span class="line">encoder.layer.11.attention.self.key.weight : torch.Size([768, 768])</span><br><span class="line">encoder.layer.11.attention.self.key.bias : torch.Size([768])</span><br><span class="line">encoder.layer.11.attention.self.value.weight : torch.Size([768, 768])</span><br><span class="line">encoder.layer.11.attention.self.value.bias : torch.Size([768])</span><br><span class="line">encoder.layer.11.attention.output.dense.weight : torch.Size([768, 768])</span><br><span class="line">encoder.layer.11.attention.output.dense.bias : torch.Size([768])</span><br><span class="line">encoder.layer.11.attention.output.LayerNorm.weight : torch.Size([768])</span><br><span class="line">encoder.layer.11.attention.output.LayerNorm.bias : torch.Size([768])</span><br><span class="line">encoder.layer.11.intermediate.dense.weight : torch.Size([3072, 768])</span><br><span class="line">encoder.layer.11.intermediate.dense.bias : torch.Size([3072])</span><br><span class="line">encoder.layer.11.output.dense.weight : torch.Size([768, 3072])</span><br><span class="line">encoder.layer.11.output.dense.bias : torch.Size([768])</span><br><span class="line">encoder.layer.11.output.LayerNorm.weight : torch.Size([768])</span><br><span class="line">encoder.layer.11.output.LayerNorm.bias : torch.Size([768])</span><br><span class="line">pooler.dense.weight : torch.Size([768, 768])</span><br><span class="line">pooler.dense.bias : torch.Size([768])</span><br></pre></td></tr></table></figure>
<h2 id="关闭占用端口的程序"><a href="#关闭占用端口的程序" class="headerlink" title="关闭占用端口的程序"></a>关闭占用端口的程序</h2><p>查看占用端口的程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -ano | findstr 8080</span><br></pre></td></tr></table></figure>
<p>使用命令关闭</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">taskkill -PID 进程号 -F</span><br></pre></td></tr></table></figure>
<h2 id="plt-imshow不显示图片"><a href="#plt-imshow不显示图片" class="headerlink" title="plt.imshow不显示图片"></a>plt.imshow不显示图片</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pylab</span><br><span class="line">f = <span class="string">&quot;data/tmp/Cats_Test49.jpg&quot;</span></span><br><span class="line">f2 = <span class="string">&quot;data/tmp/golf.jpg&quot;</span></span><br><span class="line">im = plt.imread(f)</span><br><span class="line">im2 = plt.imread(f2)</span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">plt.imshow(im)</span><br><span class="line">plt.title(<span class="string">&quot;dogs&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">plt.imshow(im2)</span><br><span class="line">plt.title(<span class="string">&quot;golf&quot;</span>)</span><br><span class="line">pylab.show()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>tips</category>
      </categories>
      <tags>
        <tag>pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title>redis_实战篇_短信登录</title>
    <url>/2024/01/18/redis/redis%E5%AE%9E%E6%88%98%E7%AF%871/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul>
<li>前后端项目导入与部署</li>
<li>基于Session实现登录流程</li>
<li>基于redis实现登录流程</li>
</ul>
<span id="more"></span>
<h1 id="短息登录"><a href="#短息登录" class="headerlink" title="短息登录"></a>短息登录</h1><h2 id="配置准备"><a href="#配置准备" class="headerlink" title="配置准备"></a>配置准备</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.31<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">redisdb</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/redisdb?useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">xxxx</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">ip</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">xxxxx</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">time-between-eviction-runs:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">jackson:</span></span><br><span class="line">    <span class="attr">default-property-inclusion:</span> <span class="string">non_null</span> <span class="comment"># JSON处理时忽略非空字段</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.hmdp.entity</span> <span class="comment"># 别名扫描包</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.hmdp:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>
<h2 id="部署前端"><a href="#部署前端" class="headerlink" title="部署前端"></a>部署前端</h2><ol>
<li>部署ngix文件夹</li>
<li>在文件夹下打开终端</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">start .\nginx.exe</span><br></pre></td></tr></table></figure>
<ol>
<li>打开chrome浏览器，在空白页面点击鼠标右键，选择检查，即可打开开发者工具</li>
<li>打开手机模式</li>
</ol>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/01/19/82038_image-20240119101138767.png" alt="image-20240119101138767"></p>
<ol>
<li>选择一款手机模式</li>
</ol>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/01/19/22649_image-20240119101305874.png" alt="image-20240119101305874" style="zoom:67%;" /></p>
<ol>
<li>访问8080端口进入app界面</li>
<li>关闭前端</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">taskkill /F /IM nginx.exe</span><br></pre></td></tr></table></figure>
<h2 id="基于Session实现登录流程"><a href="#基于Session实现登录流程" class="headerlink" title="基于Session实现登录流程"></a>基于Session实现登录流程</h2><p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/01/19/19398_1653066208144.png" alt="1653066208144"></p>
<h2 id="实现发送短信验证码功能"><a href="#实现发送短信验证码功能" class="headerlink" title="实现发送短信验证码功能"></a>实现发送短信验证码功能</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.校验手机号</span></span><br><span class="line">        <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">            <span class="comment">// 2.如果不符合，返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.符合，生成验证码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 4.保存验证码到 session</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;code&quot;</span>, code);</span><br><span class="line">        <span class="comment">// 5.发送验证码</span></span><br><span class="line">        log.debug(<span class="string">&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;</span>, code);</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意第五步由于第三方接口的原因，没有实际发送短信</p>
<h2 id="短信验证码登录、注册】"><a href="#短信验证码登录、注册】" class="headerlink" title="短信验证码登录、注册】"></a>短信验证码登录、注册】</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.校验手机号</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">        <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">            <span class="comment">// 2、如果不符合，返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.校验验证码</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">cacheCode</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">        <span class="keyword">if</span> (cacheCode == <span class="literal">null</span> || !cacheCode.toString().equals(code)) &#123;</span><br><span class="line">            <span class="comment">// 不一致，报错</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.一致，根据手机号查询用户 select * from tb_user where phone = ?</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 6.不存在，创建新用户并保存</span></span><br><span class="line">            user = createUserWithPhone(phone);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        session.setAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User <span class="title function_">createUserWithPhone</span><span class="params">(String phone)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setPhone(phone);</span><br><span class="line">        user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomString(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        save(user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="登录拦截功能"><a href="#登录拦截功能" class="headerlink" title="登录拦截功能"></a>登录拦截功能</h2><h3 id="拦截器代码"><a href="#拦截器代码" class="headerlink" title="拦截器代码"></a>拦截器代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">//1.获取session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="comment">//2.获取session中的用户</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="comment">//3.判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">              <span class="comment">//4.不存在，拦截，返回401状态码</span></span><br><span class="line">              response.setStatus(<span class="number">401</span>);</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.存在，保存用户信息到Threadlocal</span></span><br><span class="line">        UserHolder.saveUser((User)user);</span><br><span class="line">        <span class="comment">//6.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="配置让拦截器生效"><a href="#配置让拦截器生效" class="headerlink" title="配置让拦截器生效"></a>配置让拦截器生效</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="隐藏用户敏感信息"><a href="#隐藏用户敏感信息" class="headerlink" title="隐藏用户敏感信息"></a>隐藏用户敏感信息</h3><p>我们通过浏览器观察到此时用户的全部信息都在，这样极为不靠谱，所以我们应当在返回用户信息之前，将用户的敏感信息进行隐藏，采用的核心思路就是书写一个UserDto对象，这个UserDto对象就没有敏感信息了，我们在返回前，将有用户敏感信息的User对象转化成没有敏感信息的UserDto对象，那么就能够避免这个尴尬的问题了</p>
<p><strong>在登录方法处修改</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//7.保存用户信息到session中</span></span><br><span class="line">session.setAttribute(<span class="string">&quot;user&quot;</span>, BeanUtils.copyProperties(user,UserDTO.class));</span><br></pre></td></tr></table></figure>
<p><strong>在拦截器处：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5.存在，保存用户信息到Threadlocal</span></span><br><span class="line">UserHolder.saveUser((UserDTO) user);</span><br></pre></td></tr></table></figure>
<p><strong>在UserHolder处：将user对象换成UserDTO</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserDTO&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(UserDTO user)</span>&#123;</span><br><span class="line">        tl.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDTO <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">()</span>&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基于Redis实现短信登录"><a href="#基于Redis实现短信登录" class="headerlink" title="基于Redis实现短信登录"></a>基于Redis实现短信登录</h2><h3 id="session共享问题"><a href="#session共享问题" class="headerlink" title="session共享问题"></a>session共享问题</h3><p><strong>核心思路分析：</strong></p>
<p>每个tomcat中都有一份属于自己的session,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是session拷贝，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了</p>
<p>但是这种方案具有两个大问题</p>
<p>1、每台服务器中都有完整的一份session数据，服务器压力过大。</p>
<p>2、session拷贝数据时，可能会出现延迟</p>
<p>所以咱们后来采用的方案都是基于redis来完成，我们把session换成redis，redis数据本身就是共享的，就可以避免session共享的问题了</p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/02/02/21128_1653069893050-1706863382239-1.png" alt="1653069893050"></p>
<h3 id="整体访问流程"><a href="#整体访问流程" class="headerlink" title="整体访问流程"></a>整体访问流程</h3><p>当注册完成后，用户去登录会去校验用户提交的手机号和验证码，是否一致，如果一致，则根据手机号查询用户信息，不存在则新建，最后将用户数据保存到redis，并且生成token作为redis的key，当我们校验用户是否登录时，会去携带着token进行访问，从redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到threadLocal中，并且放行。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://gitee.com/hollis7/pictures/raw/master/2024/02/02/92077_image-20240202163831342.png" alt="image-20240202163831342"></h2><h3 id="设计key的具体细节"><a href="#设计key的具体细节" class="headerlink" title="设计key的具体细节"></a>设计key的具体细节</h3><p>如果我们采用<code>phone：手机号</code>这个的数据来存储当然是可以的，但是如果把这样的敏感数据存储到redis中并且从页面中带过来毕竟不太合适，所以我们在后台生成一个随机串token，然后让前端带来这个token就能完成我们的整体逻辑了。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/02/27/91177_1653320822964.png" alt="1653320822964" style="zoom: 50%;" /></p>
<h4 id="发送code-保存到redis"><a href="#发送code-保存到redis" class="headerlink" title="发送code 保存到redis"></a>发送code 保存到redis</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.校验手机号</span></span><br><span class="line">        <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">            <span class="comment">// 2.如果不符合，返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.符合，生成验证码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 4.保存验证码到 redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY + phone, code, LOGIN_CODE_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">// 5.发送验证码</span></span><br><span class="line">        log.debug(<span class="string">&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;</span>, code);</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h4><p>在7.2中将查询到的hash数据转为UserDTO时，需要将id（Long型）手动转化为String类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.校验手机号</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">        <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">            <span class="comment">// 2、如果不符合，返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.从redis获取验证码并校验</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cacheCode</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line">        <span class="keyword">if</span> (cacheCode == <span class="literal">null</span> || !cacheCode.equals(code)) &#123;</span><br><span class="line">            <span class="comment">// 不一致，报错</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.一致，根据手机号查询用户 select * from tb_user where phone = ?</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 6.不存在，创建新用户并保存</span></span><br><span class="line">            user = createUserWithPhone(phone);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 7.保存用户信息到 redis中</span></span><br><span class="line">        <span class="comment">// 7.1.随机生成token，作为登录令牌</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 7.2.将User对象转为HashMap存储</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">        Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">                CopyOptions.create()</span><br><span class="line">                        .setIgnoreNullValue(<span class="literal">true</span>)</span><br><span class="line">                        .setFieldValueEditor((fieldName, filedValue) -&gt; filedValue.toString()));</span><br><span class="line">        <span class="comment">// 7.3.存储 LOGIN_USER_KEY:&quot;login:token:&quot;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">        stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);</span><br><span class="line">        <span class="comment">// 7.4.设置token有效期</span></span><br><span class="line">        stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(token);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><p>StringRedisTemplate需要手动注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>(stringRedisTemplate))</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.获取请求头中的token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(token)) &#123;</span><br><span class="line">            <span class="comment">//不存在，拦截，返回401状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.基于TOKEN获取redis中的用户</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);</span><br><span class="line">        <span class="comment">//3.判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (userMap.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//4.不存在，拦截，返回401状态码</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.将查询到的hash数据转为UserDTO</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 6.存在，保存用户信息到 ThreadLocal</span></span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line">        <span class="comment">// 7.刷新token有效期</span></span><br><span class="line">        stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">// 8.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>只有访问到拦截路径才会刷新</p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/02/27/66997_1653320764547.png" alt="1653320764547"></p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//登录拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/upload/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">                ).order(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//拦截所有，token刷新拦截器</span></span><br><span class="line">        <span class="comment">//order越大，执行越后</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshTokenInterceptor</span>(stringRedisTemplate)).addPathPatterns(<span class="string">&quot;/**&quot;</span>).order(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis_实战篇_商户查询缓存</title>
    <url>/2024/02/29/redis/redis%E5%AE%9E%E6%88%98%E7%AF%872/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul>
<li>缓存</li>
<li>商铺查询（单一）</li>
<li>商铺类型查询（List）</li>
<li>缓存穿透</li>
<li>数据库和缓存不一致</li>
<li>缓存穿透</li>
<li>缓存雪崩</li>
<li>缓存击穿</li>
<li>封装redis工具类</li>
</ul>
<span id="more"></span>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p><strong>缓存(</strong>Cache),就是数据交换的<strong>缓冲区</strong>,俗称的缓存就是<strong>缓冲区内的数据</strong>,一般从数据库中获取,存储于本地代码。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>降低后端负载</li>
<li>提高读写效率，降低响应时间</li>
</ul>
<h3 id="缓存的成本"><a href="#缓存的成本" class="headerlink" title="缓存的成本"></a>缓存的成本</h3><ul>
<li>数据一致性成本</li>
<li>代码维护成本</li>
<li>运维成本</li>
</ul>
<h1 id="商户查询缓存"><a href="#商户查询缓存" class="headerlink" title="商户查询缓存"></a>商户查询缓存</h1><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/02/27/68828_1653322097736.png" alt="1653322097736" style="zoom: 45%;" /></p>
<h2 id="商铺查询"><a href="#商铺查询" class="headerlink" title="商铺查询"></a>商铺查询</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>从redis查询商铺缓存</li>
<li>判断是否存在</li>
<li>存在，直接返回</li>
<li>不存在，根据1d查询数据库</li>
<li>不存在，返回错误</li>
<li>存在，写入redis</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShopServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;ShopMapper, Shop&gt; <span class="keyword">implements</span> <span class="title class_">IShopService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">//CACHE_SHOP_KEY---&gt;&quot;cache:shop:&quot;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">        <span class="comment">//1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">         <span class="comment">//2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">            <span class="comment">//3.存在，直接返回</span></span><br><span class="line">            <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.不存在，根据1d查询数据库</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">        <span class="comment">//5.不存在，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.存在，写入redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop));</span><br><span class="line">        <span class="comment">//7.返回</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="作业-shoptype缓存"><a href="#作业-shoptype缓存" class="headerlink" title="作业 shoptype缓存"></a>作业 shoptype缓存</h2><h3 id="controller源码"><a href="#controller源码" class="headerlink" title="controller源码"></a>controller源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;list&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">queryTypeList</span><span class="params">()</span> &#123;</span><br><span class="line">       List&lt;ShopType&gt; typeList = typeService</span><br><span class="line">               .query().orderByAsc(<span class="string">&quot;sort&quot;</span>).list();</span><br><span class="line">       <span class="keyword">return</span> Result.ok(typeList);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShopTypeServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;ShopTypeMapper, ShopType&gt; <span class="keyword">implements</span> <span class="title class_">IShopTypeService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryByRedis</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">shopTypeListJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(CACHE_SHOP_TYPE_LIST);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(shopTypeListJson)) &#123;</span><br><span class="line">            List&lt;ShopType&gt; shopTypeLists = JSONUtil.toList(shopTypeListJson, ShopType.class);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(shopTypeLists);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;ShopType&gt; shopTypeLists = query().orderByAsc(<span class="string">&quot;sort&quot;</span>).list();</span><br><span class="line">        <span class="keyword">if</span> (shopTypeLists.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;没有店铺类型&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(CACHE_SHOP_TYPE_LIST, JSONUtil.toJsonStr(shopTypeLists));</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shopTypeLists);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h2><p>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。</p>
<p><strong>内存淘汰：</strong>redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</p>
<p><strong>超时剔除：</strong>当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存</p>
<p><strong>主动更新：</strong>我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题</p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/02/28/80353_1653322506393.png" alt="1653322506393" style="zoom:40%;" /></p>
<h2 id="数据库和缓存不一致采用什么方案"><a href="#数据库和缓存不一致采用什么方案" class="headerlink" title="数据库和缓存不一致采用什么方案"></a>数据库和缓存不一致采用什么方案</h2><p><strong>Cache Aside Pattern 人工编码方式</strong>：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案</p>
<ul>
<li><p>删除缓存还是更新缓存？</p>
<ul>
<li>更新缓存：每次更新数据库都更新缓存，无效写操作较多</li>
<li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</li>
</ul>
</li>
<li><p>如何保证缓存与数据库的操作的同时成功或失败？</p>
<ul>
<li>单体系统，将缓存与数据库操作放在一个事务</li>
<li>分布式系统，利用TCC等分布式事务方案</li>
</ul>
</li>
</ul>
<ul>
<li><p>先操作缓存还是先操作数据库？</p>
<ul>
<li><p>先删除缓存，再操作数据库</p>
</li>
<li><p>先操作数据库，再删除缓存</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/02/29/26130_1653323595206.png" alt="1653323595206" style="zoom:50%;" /></p>
<p>更新数据库业务耗时更长，查询和写入redis缓存可能在更新数据库前完成</p>
<p>写入缓存时间短，再次期间更新数据库和删除缓存的可能性小</p>
<h3 id="代码修改"><a href="#代码修改" class="headerlink" title="代码修改"></a>代码修改</h3><p><strong>设置超时</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure>
<p><strong>updata代码</strong>：先操作数据库，再删除缓存</p>
<p><code>ShopServiceImpl</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">update</span><span class="params">(Shop shop)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> shop.getId();</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺id不能为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1.更新数据库</span></span><br><span class="line">        updateById(shop);</span><br><span class="line">        <span class="comment">// 2.删除缓存</span></span><br><span class="line">        stringRedisTemplate.delete(CACHE_SHOP_KEY + shop.getId());</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中的 <code>@Transactional</code> 注解用于标识这个方法应该在一个事务中执行。事务是数据库操作的一种机制，它确保了一组数据库操作要么全部成功执行，要么全部失败回滚，以保持数据的一致性和完整性。</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p>
<p>常见的解决方案有两种：</p>
<ul>
<li>缓存空对象<ul>
<li>优点：实现简单，维护方便</li>
<li>缺点：<ul>
<li>额外的内存消耗</li>
<li>可能造成短期的不一致</li>
</ul>
</li>
</ul>
</li>
<li>布隆过滤<ul>
<li>优点：内存占用较少，没有多余key</li>
<li>缺点：<ul>
<li>实现复杂</li>
<li>存在误判可能</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/02/28/94607_1653326156516.png" alt="1653326156516" style="zoom: 67%;" /></p>
<h3 id="代码实现-缓存空对象"><a href="#代码实现-缓存空对象" class="headerlink" title="代码实现-缓存空对象"></a>代码实现-缓存空对象</h3><p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/02/28/77659_1653327124561.png" alt="1653327124561" style="zoom: 45%;" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">       <span class="comment">//CACHE_SHOP_KEY---&gt;&quot;cache:shop:&quot;</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">       <span class="comment">//1.从redis查询商铺缓存</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">       <span class="comment">//2.判断是否存在</span></span><br><span class="line">       <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">           <span class="comment">//3.存在，直接返回</span></span><br><span class="line">           <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">           <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//空字符串</span></span><br><span class="line">       <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">//返回错误信息</span></span><br><span class="line">           <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在！&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//4.不存在，根据1d查询数据库</span></span><br><span class="line">       <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">       <span class="comment">//5.不存在，返回错误</span></span><br><span class="line">       <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">//将空值写入redis</span></span><br><span class="line">           stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">           <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺不存在！&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//6.存在，写入redis</span></span><br><span class="line">       stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">       <span class="comment">//7.返回</span></span><br><span class="line">       <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p>
<p>解决方案：</p>
<ul>
<li><strong>给不同的Key的TTL添加随机值</strong></li>
<li>利用Redis集群提高服务的可用性</li>
<li>给缓存业务添加降级限流策略</li>
<li>给业务添加多级缓存</li>
</ul>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿问题也叫热点Key问题，就是一个被<strong>高并发访问</strong>并且<strong>缓存重建业务较复杂</strong>的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p>
<p>常见的解决方案有两种：</p>
<ul>
<li>互斥锁</li>
<li>逻辑过期</li>
</ul>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/02/28/96191_1653328288627.png" alt="1653328288627" style="zoom:67%;" /></p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/02/28/59776_1653328663897.png" alt="1653328663897" style="zoom:67%;" /></p>
<blockquote>
<p>我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p>
<p>这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。</p>
</blockquote>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/02/28/88931_1653357860001.png" alt="1653357860001" style="zoom: 50%;" /></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p><code>ShopServiceImpl</code></p>
<p>isLock那里一定要return</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">   <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">       <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> queryWithMutex(id);</span><br><span class="line">       <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">           Result.fail(<span class="string">&quot;店铺不存在！！！&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Shop <span class="title function_">queryWithMutex</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">       <span class="comment">//CACHE_SHOP_KEY---&gt;&quot;cache:shop:&quot;</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">       <span class="comment">//1.从redis查询商铺缓存</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">       <span class="comment">//2.判断是否存在</span></span><br><span class="line">       <span class="keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">           <span class="comment">//3.存在，直接返回</span></span><br><span class="line">           <span class="keyword">return</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//空字符串</span></span><br><span class="line">       <span class="keyword">if</span> (shopJson != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">//返回错误信息</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 4.实现缓存重构</span></span><br><span class="line">       <span class="comment">//4.1 获取互斥锁</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;lock:shop:&quot;</span> + id;</span><br><span class="line">       <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">           <span class="comment">// 4.2 判断否获取成功</span></span><br><span class="line">           <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">               <span class="comment">//4.3 失败，则休眠重试</span></span><br><span class="line">               Thread.sleep(<span class="number">50</span>);</span><br><span class="line">               <span class="comment">//这里一定要return，否则会多次查询数据库</span></span><br><span class="line">               <span class="keyword">return</span> queryWithMutex(id);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//4.4 成功，根据id查询数据库</span></span><br><span class="line">           shop = getById(id);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//模拟重建延迟</span></span><br><span class="line">           Thread.sleep(<span class="number">200</span>);</span><br><span class="line">           <span class="comment">//5.不存在，返回错误</span></span><br><span class="line">           <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="comment">//将空值写入redis</span></span><br><span class="line">               stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//6.存在，写入redis</span></span><br><span class="line">           stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//7.释放互斥锁</span></span><br><span class="line">           unLock(lockKey);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//8.返回</span></span><br><span class="line">       <span class="keyword">return</span> shop;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="meta">@Transactional</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">update</span><span class="params">(Shop shop)</span> &#123;</span><br><span class="line">       <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> shop.getId();</span><br><span class="line">       <span class="keyword">if</span> (id == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺id不能为空！&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 1.更新数据库</span></span><br><span class="line">       updateById(shop);</span><br><span class="line">       <span class="comment">// 2.删除缓存</span></span><br><span class="line">       stringRedisTemplate.delete(CACHE_SHOP_KEY + shop.getId());</span><br><span class="line">       <span class="keyword">return</span> Result.ok();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">       <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">       <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">       stringRedisTemplate.delete(key);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="逻辑过期"><a href="#逻辑过期" class="headerlink" title="逻辑过期"></a>逻辑过期</h3><p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/02/29/21339_1653360308731.png" alt="1653360308731" style="zoom: 55%;" /></p>
<p>思路分析：当用户开始查询redis时，判断是否命中，如果没有命中则直接返回空数据，不查询数据库，而一旦命中后，将value取出，判断value中的过期时间是否满足，如果没有过期，则直接返回redis中的数据，如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><p><strong>封装过期时间和店铺数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveShop2Redis</span><span class="params">(Long id, Long expireSeconds)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询商铺数据</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">        <span class="comment">//2.封装逻辑过期时间</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(shop);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));</span><br><span class="line">        <span class="comment">//3.写入redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用逻辑过期解决缓存击穿</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithLogicalExpire</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">//CACHE_SHOP_KEY---&gt;&quot;cache:shop:&quot;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">        <span class="comment">//1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">//2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(shopJson)) &#123;</span><br><span class="line">            <span class="comment">//3.未命中</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, RedisData.class);</span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="comment">// 5.判断是否过期</span></span><br><span class="line">        <span class="keyword">if</span> (expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">            <span class="keyword">return</span> shop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.2.已过期，需要缓存重建</span></span><br><span class="line">        <span class="comment">// 6.缓存重建</span></span><br><span class="line">        <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (isLock) &#123;</span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//重建缓存</span></span><br><span class="line">                    <span class="built_in">this</span>.saveShop2Redis(id, <span class="number">20L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//释放锁</span></span><br><span class="line">                    unLock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//8.返回</span></span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="封装redis工具类"><a href="#封装redis工具类" class="headerlink" title="封装redis工具类"></a>封装redis工具类</h3><p>善于利用泛型，函数式编程</p>
<p>R是返回类型，ID不确定类型，不知道具体的数据库搜索函数，采用函数式编程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithPassThrough</span><span class="params">(</span></span><br><span class="line"><span class="params">            String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3.存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断命中的是否是空值</span></span><br><span class="line">        <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回一个错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.不存在，根据id查询数据库</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">        <span class="comment">// 5.不存在，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将空值写入redis</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="comment">// 返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.存在，写入redis</span></span><br><span class="line">        <span class="built_in">this</span>.set(key, r, time, unit);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>调用封装类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> cacheClient</span><br><span class="line">                .queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, <span class="built_in">this</span>::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> cacheClient</span><br><span class="line">    .queryWithPassThrough(CACHE_SHOP_KEY, id, Shop.class, id2 -&gt; getById(id2), CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录-二叉树2</title>
    <url>/2024/03/05/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%952%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p><strong>本节包括：</strong></p>
<ul>
<li>二叉树（部分）</li>
</ul>
<span id="more"></span>
<h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h2><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A((1))</span><br><span class="line">    B((2))</span><br><span class="line">    C((2))</span><br><span class="line">    D((3))</span><br><span class="line">    E((4))</span><br><span class="line">    F((4))</span><br><span class="line">    G((3))</span><br><span class="line">    A --&gt; B</span><br><span class="line">    A --&gt; C</span><br><span class="line">    B --&gt; D</span><br><span class="line">    B --&gt; E</span><br><span class="line">    C --&gt; F</span><br><span class="line">    C --&gt; G</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了<strong>其实我们要比较的是两个树（这两个树是根节点的左右子树）</strong>，所以在递归遍历的过程中，也是要同时遍历两棵树。</p>
<p>要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。</p>
<p>节点为空的情况有：（<strong>注意我们比较的其实不是左孩子和右孩子，所以如下我称之为左节点右节点</strong>）</p>
<ul>
<li>左节点为空，右节点不为空，不对称，return false</li>
<li>左不为空，右为空，不对称 return false</li>
<li>左右都为空，对称，返回true</li>
</ul>
<p>此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：</p>
<ul>
<li>左右都不为空，比较节点数值，不相同就return false</li>
</ul>
<p>此时左右节点不为空，且数值也不相同的情况我们也处理了。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IsSymmetricTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> compare(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode left, TreeNode right)</span> &#123;</span><br><span class="line">        <span class="comment">//首先排除空节点的情况</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 排除了空节点，再排除数值不相同的情况</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left.val != right.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//比较外层和内层</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">outside</span> <span class="operator">=</span> compare(left.left, right.right);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">inside</span> <span class="operator">=</span> compare(left.right, right.left);</span><br><span class="line">        <span class="keyword">return</span> outside &amp;&amp; inside;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h2><p>推荐方法，递归法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>左子树和右子树的最大深度 <em>l</em> 和 <em>r</em>，那么该二叉树的最大深度即为</p>
<script type="math/tex; mode=display">
m a x ( l , r ) + 1</script><h2 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a>111.二叉树的最小深度</h2><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<h3 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h3><p>不能简单粗暴的求<code>Math.min(minDepth(root.left),minDepth(root.right))+1</code></p>
<p>因为当左右子树一空一不空的时候，该节点并不是叶子节点，应当选取不为空的分叉继续递归求二叉树的最小深度。</p>
<h3 id="正确解法一：递归"><a href="#正确解法一：递归" class="headerlink" title="正确解法一：递归"></a>正确解法一：递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//1、到达叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> minDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> minDepth(root.right);</span><br><span class="line">        <span class="comment">//2、左右子树有一个为空，选择不为空的的分支，l和r其中国一个必为0</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> || root.right == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> l + r + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//3、左右子树均不为空，子树最短路径+1</span></span><br><span class="line">        <span class="keyword">return</span> Math.min(l, r) + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>情况1和二可以合并</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">m1</span> <span class="operator">=</span> minDepth(root.left);</span><br><span class="line">       <span class="type">int</span> <span class="variable">m2</span> <span class="operator">=</span> minDepth(root.right);</span><br><span class="line">       <span class="comment">//1.如果左孩子和右孩子有为空的情况，直接返回m1+m2+1</span></span><br><span class="line">       <span class="comment">//2.如果都不为空，返回较小深度+1</span></span><br><span class="line">       <span class="keyword">return</span> root.left == <span class="literal">null</span> || root.right == <span class="literal">null</span> ? m1 + m2 + <span class="number">1</span> : Math.min(m1,m2) + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="正确解法二：层序遍历"><a href="#正确解法二：层序遍历" class="headerlink" title="正确解法二：层序遍历"></a>正确解法二：层序遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                cur = queue.poll();</span><br><span class="line">                <span class="comment">//如果当前节点的左右孩子都为空，直接返回最小深度</span></span><br><span class="line">                <span class="keyword">if</span> (cur.left == <span class="literal">null</span> &amp;&amp; cur.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> depth;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) queue.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226.翻转二叉树"></a>226.翻转二叉树</h2><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>前序遍历，左右子树翻转</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvertBinTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        preOrderInvertTree(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrderInvertTree</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        swapChild(node);</span><br><span class="line">        preOrderInvertTree(node.left);</span><br><span class="line">        preOrderInvertTree(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swapChild</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmpNode</span> <span class="operator">=</span> node.right;</span><br><span class="line">        node.right = node.left;</span><br><span class="line">        node.left = tmpNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222.完全二叉树的节点个数"></a>222.完全二叉树的节点个数</h2><p>给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p>
<blockquote>
<p>先求它的左子树的节点数量，再求右子树的节点数量，最后取总和再加一 （加1是因为算上当前中间节点）就是目前节点为根节点的节点数量。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> countNodes(root.left) + countNodes(root.right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110.平衡二叉树"></a>110.平衡二叉树</h2><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>比较每一个节点的左右子树的高度差是否大于1</p>
<h3 id="错误解法"><a href="#错误解法" class="headerlink" title="错误解法"></a>错误解法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> maxDepthBalance(root) != -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepthBalance</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(maxDepthBalance(node.left) - maxDepthBalance(node.right)) &gt; <span class="number">1</span> ? -<span class="number">1</span> : Math.max(maxDepthBalance(node.left), maxDepthBalance(node.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>没有考虑到<code>maxDepthBalance(node.left) - maxDepthBalance(node.right)</code>其中或许已经存在-1这种结果而不是真实的高度了</p>
<h3 id="正确解法"><a href="#正确解法" class="headerlink" title="正确解法"></a>正确解法</h3><p>如果当前传入节点为根节点的二叉树已经不是二叉平衡树了，还返回高度的话就没有意义了。</p>
<p>所以如果已经不是二叉平衡树了，可以返回-1 来标记已经不符合平衡树的规则了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> maxDepthBalance(root) != -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 所以如果已经不是二叉平衡树了，可以返回-1 来标记已经不符合平衡树的规则了。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepthBalance</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> maxDepthBalance(node.left);</span><br><span class="line">       <span class="keyword">if</span> (leftDepth == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> maxDepthBalance(node.right);</span><br><span class="line">       <span class="keyword">if</span> (rightDepth == -<span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (Math.abs(leftDepth - rightDepth) &gt; <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257.二叉树的所有路径"></a>257.二叉树的所有路径</h2><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<h3 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h3><p>采用采用递归和回溯的方法求取所有路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">//traversal方法</span></span><br><span class="line">    List&lt;Integer&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//已经遍历的节点</span></span><br><span class="line">    traversal(root, paths, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode node, List&lt;Integer&gt; paths, List&lt;String&gt; res)</span> &#123;</span><br><span class="line">        paths.add(node.val);<span class="comment">//加入当前节点到路径</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; paths.size() - <span class="number">1</span>; i++) &#123;<span class="comment">// 将paths里记录的路径转为string格式</span></span><br><span class="line">                sb.append(paths.get(i)).append(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(paths.get(paths.size() - <span class="number">1</span>));<span class="comment">//加上最后一个节点（单独处理）</span></span><br><span class="line">            res.add(sb.toString());<span class="comment">//加入一个叶子节点的路径</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历左右节点路径，并回溯</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            traversal(node.left, paths, res);</span><br><span class="line">            paths.remove(paths.size() - <span class="number">1</span>);<span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            traversal(node.right, paths, res);</span><br><span class="line">            paths.remove(paths.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h3><p>采用不断生长公共子节点的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        growthTraversal(root, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">growthTraversal</span><span class="params">(TreeNode node, String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s).append(node.val).toString());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s).append(node.val).append(<span class="string">&quot;-&gt;&quot;</span>).toString();</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        growthTraversal(node.left, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        growthTraversal(node.right, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><blockquote>
<p>使用StringBuilder进行字符串拼接通常比直接使用字符串相加的方式更高效。这是因为StringBuilder是可变的，允许在同一对象上进行多次追加操作，而不会每次都创建一个新的字符串对象。</p>
</blockquote>
<h2 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404.左叶子之和"></a>404.左叶子之和</h2><p>给定二叉树的根节点 <code>root</code> ，返回所有左叶子之和。</p>
<h3 id="法一-基于DFS"><a href="#法一-基于DFS" class="headerlink" title="法一 基于DFS"></a>法一 基于DFS</h3><p>基于深度层序遍历，累加左叶子之和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    levelOrder(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLeaf</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">levelOrder</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isLeaf(node.left)) &#123;</span><br><span class="line">            res += node.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        levelOrder(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        levelOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513.找树左下角的值"></a>513.找树左下角的值</h2><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p>
<p>假设二叉树中至少有一个节点。</p>
<p><strong>示例 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg" alt="img" style="zoom:67%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,null,5,6,null,null,7]</span><br><span class="line">输出: 7</span><br></pre></td></tr></table></figure>
<h3 id="法一-基于广度优先遍历"><a href="#法一-基于广度优先遍历" class="headerlink" title="法一 基于广度优先遍历"></a>法一 基于广度优先遍历</h3><p>不断更新每一层的节点的最左边的的节点值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindBottomLeftValue</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        BFSFindBottomLeftValue(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">BFSFindBottomLeftValue</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) res = tmp.val;</span><br><span class="line">                <span class="keyword">if</span> (tmp.left != <span class="literal">null</span>) queue.offer(tmp.left);</span><br><span class="line">                <span class="keyword">if</span> (tmp.right != <span class="literal">null</span>) queue.offer(tmp.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="法二-基于深度优先搜索-递归"><a href="#法二-基于深度优先搜索-递归" class="headerlink" title="法二 基于深度优先搜索-递归"></a>法二 基于深度优先搜索-递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindBottomLeftValueRecursive</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">Deep</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        preOrderFindLeftBottomValue(root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrderFindLeftBottomValue</span><span class="params">(TreeNode node, <span class="type">int</span> deep)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (deep &gt; Deep) &#123;</span><br><span class="line">                Deep = deep;</span><br><span class="line">                value = node.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        preOrderFindLeftBottomValue(node.left, deep + <span class="number">1</span>);</span><br><span class="line">        preOrderFindLeftBottomValue(node.right, deep + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112.路径总和"></a>112.路径总和</h2><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<h3 id="法一-1"><a href="#法一-1" class="headerlink" title="法一"></a>法一</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>找到所有路径，然后求和</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HasPathSum</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; paths = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        getPath(root, path);</span><br><span class="line">        <span class="keyword">return</span> compareSum(paths, targetSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getPath</span><span class="params">(TreeNode node, List&lt;Integer&gt; path)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 创建 path 的副本</span></span><br><span class="line">        List&lt;Integer&gt; copyOfPath = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path);</span><br><span class="line">        copyOfPath.add(node.val);</span><br><span class="line">        <span class="comment">//叶子节点，加入路径</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            paths.add(copyOfPath);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左右节点，继续向下遍历</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) getPath(node.left, copyOfPath);</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) getPath(node.right, copyOfPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compareSum</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; paths, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; sums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; path : paths) &#123;</span><br><span class="line">            <span class="comment">//求每条路径和</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">tmpSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (Integer i : path) &#123;</span><br><span class="line">                tmpSum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tmpSum == targetSum) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="法二-1"><a href="#法二-1" class="headerlink" title="法二"></a>法二</h3><h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 叶子节点直接在这里结束。因为传入null，一定就是false，那整颗树就一定是false</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> targetSum == root.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">newTargetSum</span> <span class="operator">=</span> targetSum - root.val;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">leftHasPathSum</span> <span class="operator">=</span> hasPathSum(root.left, newTargetSum);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rightHasPathSum</span> <span class="operator">=</span> hasPathSum(root.right, newTargetSum);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leftHasPathSum || rightHasPathSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654.最大二叉树"></a>654.最大二叉树</h2><p>给定一个不重复的整数数组 <code>nums</code> 。 <strong>最大二叉树</strong> 可以用下面的算法从 <code>nums</code> 递归地构建:</p>
<ol>
<li>创建一个根节点，其值为 <code>nums</code> 中的最大值。</li>
<li>递归地在最大值 <strong>左边</strong> 的 <strong>子数组前缀上</strong> 构建左子树。</li>
<li>递归地在最大值 <strong>右边</strong> 的 <strong>子数组后缀上</strong> 构建右子树。</li>
</ol>
<p>返回 <code>nums</code> 构建的 <strong>最大二叉树</strong> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstructMaximumBinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> buildHelper(nums, <span class="number">0</span>, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">buildHelper</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">//叶子节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line">        <span class="keyword">if</span> (right - left == <span class="number">1</span>) &#123;</span><br><span class="line">            node.val = nums[left];</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//空叶子</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归构建左子树、右子树</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> getMaxIndex(nums, left, right);</span><br><span class="line">        node.val = nums[maxIndex];</span><br><span class="line">        node.left = buildHelper(nums, left, maxIndex);</span><br><span class="line">        node.right = buildHelper(nums, maxIndex + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取局部数组的最大值索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxIndex</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; maxValue) &#123;</span><br><span class="line">                maxIndex = i;</span><br><span class="line">                maxValue = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h2><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p>
<p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p>
<p>返回合并后的二叉树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">null</span>) <span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span> (root2 == <span class="literal">null</span>) <span class="keyword">return</span> root1;</span><br><span class="line">        root1.val += root2.val;</span><br><span class="line">        root1.left = mergeTrees(root1.left, root2.left);</span><br><span class="line">        root1.right = mergeTrees(root1.right, root2.right);</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700.二叉搜索树中的搜索"></a>700.二叉搜索树中的搜索</h2><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和一个整数值 <code>val</code>。</p>
<p>你需要在 BST 中找到节点值等于 <code>val</code> 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 <code>null</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || root.val == val) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> searchBST(root.left, val);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> searchBST(root.right, val);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归，利用二叉搜索树特点，优化</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || root.val == val) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (val &lt; root.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.left, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h2><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p>
<p><strong>有效</strong>二叉搜索树定义如下：</p>
<ul>
<li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li>
<li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>中序遍历二叉树，如果不是递增的就不是二叉搜索树</p>
<h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><ol>
<li>中序遍历，递归法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       inOrder(root.left);</span><br><span class="line">       queue.offer(root.val);</span><br><span class="line">       inOrder(root.right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>左边数值&gt;=右边数值均为false</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (node1 &gt;= node2) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>变量不能作为for循环的边界</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">queueSize</span> <span class="operator">=</span> queue.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; queueSize - <span class="number">1</span>; i++) </span><br></pre></td></tr></table></figure>
<h3 id="总代码"><a href="#总代码" class="headerlink" title="总代码"></a>总代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    inOrder(root);</span><br><span class="line">    <span class="type">int</span> <span class="variable">queueSize</span> <span class="operator">=</span> queue.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; queueSize - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">node1</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="type">int</span> <span class="variable">node2</span> <span class="operator">=</span> queue.peek();</span><br><span class="line">        <span class="keyword">if</span> (node1 &gt;= node2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    inOrder(root.left);</span><br><span class="line">    queue.offer(root.val);</span><br><span class="line">    inOrder(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>推荐代码-中序遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">pre</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!isValidBST(root.left)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre &gt; root.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root.val;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530.二叉搜索树的最小绝对差"></a>530.二叉搜索树的最小绝对差</h2><p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p>
<p>差值是一个正数，其数值等于两值之差的绝对值。</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>中序遍历，求得到的数组两点间的绝对值最小值</p>
<h3 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h3><ol>
<li>成员变量一定要初始化，不然会是空</li>
<li>初始最小值一定要设的足够大</li>
</ol>
<h3 id="总代码-1"><a href="#总代码-1" class="headerlink" title="总代码"></a>总代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    inOrder(root);</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">    <span class="type">int</span> <span class="variable">minAbsDis</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> list.get(i + <span class="number">1</span>) - list.get(i);</span><br><span class="line">        <span class="keyword">if</span> (minAbsDis &gt; tmp) &#123;</span><br><span class="line">            minAbsDis = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minAbsDis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inOrder(root.left);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    inOrder(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501.二叉搜索树中的众数"></a>501.二叉搜索树中的众数</h2><p>给你一个含重复值的二叉搜索树(BST)的根节点root,，找出并返回BST中的所有众数(即，出现频率最高的元素)。<br>如果树中有不止一个众数，可以按任意顺序返回。<br>假定BST满足如下定义：</p>
<ol>
<li>结点左子树中所含节点的值小于等于当前节点的值</li>
<li>结点右子树中所含节点的值大于等于当前节点的值</li>
<li>左子树和右子树都是二叉搜索树</li>
</ol>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><ul>
<li>中序遍历</li>
<li>弄一个指针指向前一个节点，这样每次cur（当前节点）才能和pre（前一个节点）作比较。</li>
<li>而且初始化的时候pre = NULL，这样当pre为NULL时候，我们就知道这是比较的第一个元素。</li>
<li>与前一个节点数值不同，新值count = 1</li>
<li>与前一个节点数值相同，count加1</li>
<li>频率count 等于 maxCount（最大频率），当然要把这个元素加入到结果集中</li>
<li>count&gt;maxCount,清除以前的众数，添加当前元素</li>
<li>指针后移</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindMode2</span> &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; resList;</span><br><span class="line">    <span class="type">int</span> maxCount;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    TreeNode pre;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        resList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        maxCount = <span class="number">0</span>;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        pre = <span class="literal">null</span>;</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[resList.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; resList.size(); i++) &#123;</span><br><span class="line">            res[i] = resList.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">nodeValue</span> <span class="operator">=</span> root.val;</span><br><span class="line">        <span class="comment">//相同数值，增加频数</span></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">null</span> &amp;&amp; nodeValue == pre.val) &#123;</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//第一次出现</span></span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == maxCount) resList.add(nodeValue);</span><br><span class="line">        <span class="keyword">if</span> (count &gt; maxCount) &#123;</span><br><span class="line">            maxCount = count;</span><br><span class="line">            resList.clear();</span><br><span class="line">            resList.add(nodeValue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//后移前指针</span></span><br><span class="line">        pre = root;</span><br><span class="line"></span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a href="https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。</p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>情况一：如果找到一个节点，发现左子树出现结点p，右子树出现节点q，或者 左子树出现结点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220922173502.png" alt="img" style="zoom:50%;" /></p>
<p>情况二：节点本身p(q)，它拥有一个子孙节点q(p)</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220922173530.png" alt="img" style="zoom:50%;" /></p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/03/05/69347_Snipaste_2024-03-05_20-12-07.png" alt="Snipaste_2024-03-05_20-12-07" style="zoom: 50%;" /></p>
<p>情况一二代码的实现逻辑一样，即：<strong>如果递归遍历遇到q，就将q返回，遇到p 就将p返回，那么如果左右子树的返回值都不为空，说明此时的中节点，一定是q 和p 的最近祖先。</strong></p>
<p><strong>注意：利用后续遍历</strong></p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LowestCommonAncestor2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q || root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235.二叉搜索树的最近公共祖先"></a>235.二叉搜索树的最近公共祖先</h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a href="https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>
</ul>
<h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>我们从根节点搜索，第一次遇到cur节点是数值在[q, p]区间中，即节点5，此时可以说明 q 和 p 一定分别存在于节点5的左子树，和右子树中。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701.二叉搜索树中的插入操作"></a>701.二叉搜索树中的插入操作</h2><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。</p>
<h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>根据二叉搜索树的特性，不断递归，找到可以插入的叶子节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; val &amp;&amp; root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            insertIntoBST(root.left, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; val &amp;&amp; root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            insertIntoBST(root.right, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; val) &#123;</span><br><span class="line">            root.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; val) &#123;</span><br><span class="line">            root.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>简化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="comment">// 如果当前节点为空，也就意味着val找到了合适的位置，此时创建节点直接返回。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; val)&#123;</span><br><span class="line">        root.right = insertIntoBST(root.right, val); <span class="comment">// 递归创建右子树</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; val)&#123;</span><br><span class="line">        root.left = insertIntoBST(root.left, val); <span class="comment">// 递归创建左子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450.删除二叉搜索树中的节点"></a>450.删除二叉搜索树中的节点</h2><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><ul>
<li>第一种情况：没找到删除的节点，遍历到空节点直接返回了</li>
<li>找到删除的节点<ul>
<li>第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li>
<li>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li>
<li>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li>
<li>第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。</li>
</ul>
</li>
</ul>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.gif" alt="450.删除二叉搜索树中的节点"></p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="comment">//没有找到，返回空指针</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//当前节点为删除节点</span></span><br><span class="line">        <span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">            <span class="comment">//删除的节点左右子树至少有一个为空,3种情况</span></span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root.right == <span class="literal">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">                <span class="comment">//左右子树均不为空，当前节点左子树插入右子树的最左端叶子节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">insertPos</span> <span class="operator">=</span> root.right;</span><br><span class="line">                <span class="keyword">while</span> (insertPos.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    insertPos = insertPos.left;</span><br><span class="line">                &#125;</span><br><span class="line">                insertPos.left = root.left;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除节点在左边</span></span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; key) root.left = deleteNode(root.left, key);</span><br><span class="line">        <span class="comment">//删除节点在右边</span></span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; key) root.right = deleteNode(root.right, key);</span><br><span class="line">        <span class="comment">//返回根节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a>669. 修剪二叉搜索树</h2><p>给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201014173219142.png" alt="669.修剪二叉搜索树1" style="zoom:50%;" /></p>
<h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><ol>
<li>修剪的操作并不是在终止条件上进行的，所以就是遇到空节点返回就可以了。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>确定单层递归的逻辑：</li>
</ol>
<ul>
<li>如果root（当前节点）的元素小于low的数值，那么应该递归右子树，并返回右子树符合条件的头结点。</li>
<li>如果root(当前节点)的元素大于high的，那么应该递归左子树，并返回左子树符合条件的头结点。</li>
</ul>
<ol>
<li><p>接下来要将下一层处理完左子树的结果赋给root-&gt;left，处理完右子树的结果赋给root-&gt;right。</p>
</li>
<li><p>最后返回root节点</p>
</li>
</ol>
<h3 id="代码实现-递归"><a href="#代码实现-递归" class="headerlink" title="代码实现-递归"></a>代码实现-递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//当前节点小于low，判断当前右子树是否有在[low,high]区间的节点</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; low) &#123;</span><br><span class="line">        <span class="keyword">return</span> trimBST(root.right, low, high);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前节点大于high，判断当前左子树是否有在[low,high]区间的节点</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; high) &#123;</span><br><span class="line">        <span class="keyword">return</span> trimBST(root.left, low, high);</span><br><span class="line">    &#125;</span><br><span class="line">    root.left = trimBST(root.left, low, high);<span class="comment">// root-&gt;left接入符合条件的左孩子</span></span><br><span class="line">    root.right = trimBST(root.right, low, high);<span class="comment">// root-&gt;right接入符合条件的右孩子</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码实现-迭代-了解"><a href="#代码实现-迭代-了解" class="headerlink" title="代码实现-迭代-了解"></a>代码实现-迭代-了解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//iteration</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span> &amp;&amp; (root.val &lt; low || root.val &gt; high))&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val &lt; low)</span><br><span class="line">                root = root.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//deal with root&#x27;s left sub-tree, and deal with the value smaller than low.</span></span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(curr.left != <span class="literal">null</span> &amp;&amp; curr.left.val &lt; low)&#123;</span><br><span class="line">                curr.left = curr.left.right;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//go back to root;</span></span><br><span class="line">        curr = root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//deal with root&#x27;s righg sub-tree, and deal with the value bigger than high.</span></span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(curr.right != <span class="literal">null</span> &amp;&amp; curr.right.val &gt; high)&#123;</span><br><span class="line">                curr.right = curr.right.left;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code_Musing</category>
      </categories>
      <tags>
        <tag>binaryTree</tag>
        <tag>traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC并发编程基础</title>
    <url>/2024/03/06/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul>
<li>JUC</li>
<li>进程线程</li>
<li>线程常用方法</li>
<li>线程的6种状态</li>
<li>线程状态切换</li>
<li>Callable接口</li>
</ul>
<span id="more"></span>
<h2 id="什么是J-U-C"><a href="#什么是J-U-C" class="headerlink" title="什么是J.U.C"></a>什么是J.U.C</h2><p>JUC是<code>java.util.concurrent</code>包的缩写，包结构如下，说⽩了就是<strong>并发场景进⾏多线程编程</strong>的⼯具<br>类。</p>
<p>怎么让程序尽量通过<strong>有限的硬件</strong>，⾼效的处理请求，并且保证程序“<strong>线程安全</strong>”⽽这涉及到的知识点⾮常的庞⼤。</p>
<h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><p>在操作系统中，<strong>进程是基本的资源分配单位</strong>，操作系统通过进程来管理计算机的资源，如CPU、内存、磁盘等。每个进程都有⼀个唯⼀的<strong>进程标识符</strong>（PID），⽤于区分不同的进程。<br>通俗说法：可看做是正在执⾏的程序如 QQ.exe</p>
<h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>底层⻆度：<strong>线程是操作系统中的基本执⾏单元</strong>（能够直接执⾏的最⼩代码块），它是进程中的⼀个实<br>体，是<strong>CPU调度和分派的基本单位</strong>。⼀个进程可以包含多个线程，每个线程都可以独⽴执⾏不同的任<br>务，但它们共享进程的资源。</p>
<h2 id="并⾏、并发、串⾏"><a href="#并⾏、并发、串⾏" class="headerlink" title="并⾏、并发、串⾏"></a>并⾏、并发、串⾏</h2><p><strong>并发</strong>是指多个任务在<strong>同一时间段内</strong>交替执行。这些任务可能会在同一个处理器上通过<strong>时间片轮转</strong>或者通过操作系统的调度器分配资源交替执行。</p>
<p><strong>并行</strong>是指在<strong>同一时刻</strong>，多个任务同时执行。这些任务可以在多个处理器上同时执行。并行的主要目的是提高系统的整体性能和吞吐量。</p>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><ol>
<li>通过继承Thread，重写run</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程Thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>通过实现Runnable</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// new Runnable匿名内部类</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;线程Runnable&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;线程Runnable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="线程常⽤⽅法"><a href="#线程常⽤⽅法" class="headerlink" title="线程常⽤⽅法"></a>线程常⽤⽅法</h2><h3 id="线程原理"><a href="#线程原理" class="headerlink" title="线程原理"></a>线程原理</h3><p>都会调用start方法，然后执行我们的<strong>start0</strong>这个原生本地方法，底层是c/c++代码，执行后回调run方法，run方法有一个Runnable类型的target判断，不为空执行Runnable.run,继承Thread方法的话直接执行run。</p>
<h3 id="start-与-run"><a href="#start-与-run" class="headerlink" title="start 与 run"></a>start 与 run</h3><p><strong>类型</strong><br>run⽅法是同步⽅法，⽽start⽅法是异步⽅法。<br><strong>作⽤</strong><br>run⽅法的作⽤是存放任务代码，⽽start的⽅法呢是启动线程<br><strong>线程数量⽅⾯</strong><br>执⾏run⽅法它不会产⽣新线程，⽽执⾏start⽅法会产⽣新线程，<br><strong>调⽤次数</strong><br>run⽅法可以被执⾏⽆数次，⽽star⽅法只能被执⾏⼀次，原因就在于线程不能被重复启动。</p>
<h3 id="睡眠"><a href="#睡眠" class="headerlink" title="睡眠"></a>睡眠</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;睡眠完毕&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">// 线程中断</span></span><br><span class="line"><span class="comment">//        t1.interrupt();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p><strong>在循环访问锁的过程中，可以加⼊sleep让线程阻塞时间，防⽌⼤量占⽤cpu资源。</strong></p>
<p>比如Tomcat</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    awaitThread = currentThread;</span><br><span class="line">    <span class="keyword">while</span> (!stopAwait) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            <span class="comment">// continue and check the flag</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    awaitThread = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="yeild"><a href="#yeild" class="headerlink" title="yeild"></a>yeild</h3><p>提示线程调度器尽⼒让出当前线程对CPU的使⽤</p>
<ul>
<li>Thread.yield()方法作用是：暂停当前正在执行的线程对象（及放弃当前拥有的cu资源)，并执行其他线程。</li>
<li><strong>yield()做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会</strong>。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，<strong>实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Task2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        Thread.<span class="keyword">yield</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;B:&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>sleep()和yield()的区别 sleep()使当前线程进⼊停滞状态，所以执⾏sleep()的线程在指定的时间内肯定不会被执⾏； yield()只是使当前线程重新回到可执⾏状态，所以执⾏yield()的线程有可能在进⼊到可执⾏状态后⻢上⼜被执⾏。</p>
</blockquote>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">thread1.setPriority(Thread.MAX_PRIORITY);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_PRIORITY</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NORM_PRIORITY</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_PRIORITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h3 id="线程打断"><a href="#线程打断" class="headerlink" title="线程打断"></a>线程打断</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p><strong>实例⽅法</strong>interrupt()仅仅是设置线程的中断状态为true，不会停⽌线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 定时监控系统...</span></span><br><span class="line">            System.out.println(<span class="string">&quot;定时监控...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">定时监控...</span><br><span class="line">定时监控...</span><br><span class="line">定时监控...</span><br><span class="line">定时监控...</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p><strong>静态⽅法</strong>，判断线程是否被中断，并清除当前中断状态<br>也就是说这个⽅法做了两件事：<br>1、返回当前线程的中断状态<br>2、将当前线程的中断状态设为false</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            // 每隔1s 将时间片清除</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(1L);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                // 当出现InterruptedException  会清除中断标记      false</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                // 再次加上中断标记</span><br><span class="line">                Thread.currentThread().interrupt();      // true</span><br><span class="line">            &#125;</span><br><span class="line">            //  如果中断的标记为true</span><br><span class="line">            // 获取线程中断标记，  并且会清除标记</span><br><span class="line">            System.out.println(Thread.currentThread().isInterrupted());</span><br><span class="line">            if (Thread.interrupted()) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().isInterrupted());</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 定时监控系统...</span><br><span class="line">            System.out.println(&quot;定时监控...&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程的合并join"><a href="#线程的合并join" class="headerlink" title="线程的合并join"></a>线程的合并join</h3><p>Thread中， <code>join()</code>⽅法的作⽤是调⽤线程等待该线程完成后，才能继续往下运⾏。</p>
<p>join是Thread类的⼀个⽅法，启动线程后直接调⽤，即join()的作⽤是：“等待该线程终⽌”，这⾥需要<br>理解的就是该线程是指的<strong>主线程等待⼦线程的终⽌</strong>。也就是在⼦线程调⽤了join()⽅法后⾯的代码，只有<br>等到⼦线程结束了才能执⾏。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">t1.start();<span class="comment">// 异步</span></span><br><span class="line">System.out.println(t1.isAlive());<span class="comment">//true</span></span><br><span class="line">t1.join();  <span class="comment">// 异步变成同步</span></span><br><span class="line">System.out.println(t1.isAlive());<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>也可以有时间限制的等待</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">t1.join(<span class="number">1000</span>); </span><br></pre></td></tr></table></figure>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>默认情况下我们创建的线程都是⽤户线程（普通线程），进程需要等待所有的线程执⾏完毕后，进<br>程才会结束。<br>守护线程.setDaemon(true):设置守护线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeamonThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建线程(默认前台线程)</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    System.out.println(i);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//设置线程为守护线程</span></span><br><span class="line">        d1.setDaemon(<span class="literal">true</span>);<span class="comment">//主线程结束便结束了</span></span><br><span class="line">        d1.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>主线程结束</p>
</blockquote>
<p><strong>应⽤：</strong><br>垃圾回收器线程属于守护线程<br>tomcat⽤来接受处理外部的请求的线程就是守护线程。</p>
<h2 id="线程6种状态"><a href="#线程6种状态" class="headerlink" title="线程6种状态"></a>线程6种状态</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">状态名称</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">NEW</td>
<td style="text-align:left">初始状态，线程被构建，但是还没有调用start()方法</td>
</tr>
<tr>
<td style="text-align:left">RUNNABLE</td>
<td style="text-align:left">运行状态，Java线程将操作系统中的就绪和运行两种状态统称为”运行中”</td>
</tr>
<tr>
<td style="text-align:left">BLOCKED</td>
<td style="text-align:left">阻塞状态，表示线程阻塞于锁</td>
</tr>
<tr>
<td style="text-align:left">WAITING</td>
<td style="text-align:left">等待状态，表示线程进入等待状态，进入该状态表示当前线程需要其他线程通知(notify或者notifyAll)</td>
</tr>
<tr>
<td style="text-align:left">TIME_WAITING</td>
<td style="text-align:left">超时等待状态，可以指定等待时间自己返回</td>
</tr>
<tr>
<td style="text-align:left">TERMINATED</td>
<td style="text-align:left">终止状态，表示当前线程已经执行完毕</td>
</tr>
</tbody>
</table>
</div>
<h3 id="BLOCKED"><a href="#BLOCKED" class="headerlink" title="BLOCKED"></a>BLOCKED</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Table table = new Table();</span><br><span class="line">Thread student1 = new Thread(() -&gt; &#123;</span><br><span class="line">    table.use();</span><br><span class="line">&#125;, &quot;s1&quot;);</span><br><span class="line">Thread student2 = new Thread(() -&gt; &#123;</span><br><span class="line">    table.use();</span><br><span class="line">&#125;, &quot;s2&quot;);</span><br><span class="line">student1.start();</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">student2.start();</span><br><span class="line">Thread.sleep(500);</span><br><span class="line">System.out.println(student2.getState());</span><br></pre></td></tr></table></figure>
<p><code>Thread.sleep(1000)</code>的作用是确保student1已经获取了锁，<code>Thread.sleep(500)</code>的作用是确保student2尝试获取锁，但是锁被student1获取没有释放，因此student2是阻塞状态。</p>
<h3 id="WAITING"><a href="#WAITING" class="headerlink" title="WAITING"></a>WAITING</h3><p>会一直卡在wait()那。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Table1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-使用桌子&quot;</span>);</span><br><span class="line">        <span class="comment">//忘记点餐了</span></span><br><span class="line">        System.out.println(<span class="string">&quot;忘记点餐了&quot;</span>);</span><br><span class="line">        wait();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;就餐结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TIMED-WAITING"><a href="#TIMED-WAITING" class="headerlink" title="TIMED_WAITING"></a>TIMED_WAITING</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">wait(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<h2 id="线程状态间转换"><a href="#线程状态间转换" class="headerlink" title="线程状态间转换"></a>线程状态间转换</h2><h3 id="Blocked-进⼊-Runnable"><a href="#Blocked-进⼊-Runnable" class="headerlink" title="Blocked 进⼊ Runnable"></a>Blocked 进⼊ Runnable</h3><p>想要从 Blocked 状态进⼊ Runnable 状态，我们上⾯说过必须要线程获得 monitor 锁，但是如果想<br>进⼊其他状态那么就相对⽐较特殊，因为它是没有超时机制的，也就是不会主动进⼊。</p>
<h3 id="Waiting-进⼊-Runnable"><a href="#Waiting-进⼊-Runnable" class="headerlink" title="Waiting 进⼊ Runnable"></a>Waiting 进⼊ Runnable</h3><ul>
<li>有当执⾏了LockSupport.unpark()，或者join的线程运⾏结束，或者被中断时才可以进⼊Runnable 状态。</li>
<li>如果通过其他线程调⽤ notify() 或 notifyAll()来唤醒它，则它会直接进⼊ Blocked 状态，这⾥⼤家<br>可能会有疑问，不是应该直接进⼊ Runnable 吗？<strong>这⾥需要注意⼀点，因为唤醒 Waiting 线程的线程如果调⽤ notify() 或 notifyAll()，要求必须⾸先持有该 monitor锁</strong>，这也就是我们说的 wait()、notify 必须在 synchronized 代码块中。</li>
<li>所以处于Waiting状态的线程被唤醒时拿不到该锁，就会进⼊Blocked状态，直到执⾏了notify（）/notifyAll（）的唤醒它的线程执⾏完毕并释放monitor锁，才可能轮到它去抢夺这把锁，如果它能抢到，就会从Blocked状态回到Runnable状态。</li>
</ul>
<h2 id="Callable接⼝"><a href="#Callable接⼝" class="headerlink" title="Callable接⼝"></a>Callable接⼝</h2><p>⼀般情况下，使⽤Runnable接⼝、Thread实现的线程我们都是⽆法返回结果的。但是如果对⼀些场合需要线程返回的结果。就要使⽤⽤<strong>Callable、Future</strong>这⼏个类。Callable只能在ExecutorService的线程池中跑，但有返回结果，也可以通过返回的Future对象查询执⾏状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它只有⼀个call⽅法，并且有⼀个返回V，是泛型。可以认为这⾥返回V就是线程返回的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="built_in">this</span>.callable = callable;</span><br><span class="line">        <span class="built_in">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>第一步，创建Callable实现类的实例，并实现call方法</p>
<p>第2步，创建Callable实现类实例</p>
<p>第3步，使用FutureTask类来包装Callable对象，可以创建匿名对象</p>
<p>第4步，使用FutureTask对象作为Thread对象的target创建、并启动新线程。</p>
<p>第5步，调用FutureTask对象的方法来获取子线程执行结束后的返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.info(<span class="string">&quot;2.子线程运行中...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line">FutureTask&lt;Integer&gt; future = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(task);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(future).start();</span><br></pre></td></tr></table></figure>
<h2 id="三种线程创建的⽅式"><a href="#三种线程创建的⽅式" class="headerlink" title="三种线程创建的⽅式"></a>三种线程创建的⽅式</h2><ol>
<li>实现Runnable接口的run⽅法</li>
<li>继承Thread类并重写run的⽅法</li>
<li>使⽤FutureTask⽅式(实现Callable接口的⽅式)</li>
</ol>
<p>Java中，类仅⽀持单继承，如果⼀个类继承了Thread类，就⽆法再继承其它类，因此，<strong>如果⼀个类既要</strong><br><strong>继承其它的类，⼜必须创建为⼀个线程，就可以使⽤实现Runable接⼝的⽅式。</strong></p>
<p>使⽤实现Callable接口的⽅式创建的线程，可以获取到线程执⾏的<strong>返回值</strong>、是否执⾏完成等信息。</p>
<h3 id="Runnable和Callable区别"><a href="#Runnable和Callable区别" class="headerlink" title="Runnable和Callable区别"></a>Runnable和Callable区别</h3><ol>
<li>返回值：实现Callable接口的任务线程能返回执⾏结果；⽽实现Runnable接口的任务线程不能返回结果</li>
<li>抛出异常：Callable接口的call()⽅法允许抛出异常；⽽Runnable接口的run()⽅法的异常只能在内部消化，不能继续上抛；</li>
</ol>
]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>JUC</tag>
        <tag>basic</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC并发编程基础-线程池</title>
    <url>/2024/03/07/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul>
<li>线程池概念 特性</li>
<li>创建线程EXecutors</li>
<li>自定义创建线程ThreadPoolExecutor</li>
<li>源码分析：创建、淘汰、异常、中断</li>
</ul>
<span id="more"></span>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>其实就是⼀个容纳多个线程的容器，其中的线程可以反复使⽤，省去了频繁创建线程对象的操作，⽆需反复创建线程⽽消耗过多资源。</p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>线程池做的⼯作主要是<strong>控制运⾏的线程数量</strong>，处理过程中<strong>将任务放⼊队列</strong>，然后在线程创建后启动这些任务，如果线程数量超过了最⼤数量，超出数量的线程排队等候，等其他线程执⾏完毕，再从队列中取出任务来执⾏。</p>
<p><strong>降低资源消耗</strong>。通过重复利⽤已创建的线程降低线程创建和销毁造成的销耗。</p>
<p><strong>提⾼响应速度</strong>。当任务到达时，任务可以不需要等待线程创建就能⽴即执⾏。</p>
<p><strong>提⾼线程的可管理性</strong>。线程是稀缺资源，如果⽆限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使⽤线程池可以进⾏<strong>统⼀的分配，调优和监控</strong></p>
<h2 id="线程池-初试"><a href="#线程池-初试" class="headerlink" title="线程池-初试"></a>线程池-初试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    executorService.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            list.add(random.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">executorService.shutdown();</span><br><span class="line">executorService.awaitTermination(<span class="number">1</span>, TimeUnit.DAYS);  </span><br></pre></td></tr></table></figure>
<h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><p>Java⾥⾯线程池的顶级接口是 java.util.concurrent.Executor ，但是严格意义上讲 Executor并不是⼀个线程池，⽽只是⼀个执⾏线程的⼯具。真正的线程池接接口是<code>java.util.concurrent.ExecutorService</code> 。</p>
<ul>
<li><code>newFixedThreadPool</code>创建⼀个固定⻓度的线程池，当到达线程最⼤数量时，线程池的规模将不再变化。</li>
<li><code>newCachedThreadPool</code>创建⼀个可缓存的线程池，如果当前线程池的规模超出了处理需求，将回收空的线程；当需求增加时，会增加线程数量；线程池规模⽆限制。</li>
<li><code>newSingleThreadPoolExecutor</code>创建⼀个单线程的Executor，确保任务对了，串⾏执⾏</li>
<li><code>newScheduledThreadPool</code>创建⼀个固定⻓度的线程池，⽽且以延迟或者定时的⽅式来执⾏，类似 Timer；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;\t 办理业务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使⽤<br>的是<code>LinkedBlockingQueue</code>执⾏⻓期任务性能好，创建⼀个线程池，<strong>⼀池有N个固定的线程</strong>，有固定线程<br>数的线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        threadPool.execute(task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    threadPool.shutdownNow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>newSingleThreadExecutor 创建的线程池corePoolSize和maximumPoolSize值都是1，它使⽤的是<code>LinkedBlockingQueue</code>⼀个任务⼀个任务的执⾏，⼀池⼀线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure>
<h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><p>newCachedThreadPool创建的线程池将corePoolSize设置为0，将maximumPoolSize设置<br>为<code>Integer.MAX_VALUE</code>，它使⽤的是<code>SynchronousQueue</code>，也就是说<strong>来了任务就创建线程运⾏，当线程</strong><br><strong>空闲超过60秒，就销毁线程</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>
<h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><p><strong>可以固定线程池线程数和延迟固定时间执行任务</strong>，类型是<code>ScheduledExecutorService</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>执行任务也有所不同<code>schedule</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">threadPool.schedule(task, <span class="number">5</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>如果没有关闭线程池，线程池中线程一直占用系统资源，内存泄露，主线程只会不会退出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不会立马停止正在执行的线程，会等待所有的任务执行完后才彻底关闭</span></span><br><span class="line">threadPool.shutdown();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断线程池是否关闭，异步</span></span><br><span class="line">threadPool.isTerminated()</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//等待线程池关闭，等待线程池中所有的线程执行完，最多等待Long.MAX_VALUE的时间，同步</span></span><br><span class="line">threadPool.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不会立马停止正在执行的线程，只会等待正在执行的线程执行完后才彻底关闭，异步</span></span><br><span class="line"><span class="comment">//举例，线程池5个任务执行完毕后就会关闭，不管10个任务没有执行完毕</span></span><br><span class="line">threadPool.shutdownNow();</span><br></pre></td></tr></table></figure>
<h2 id="excute和submit"><a href="#excute和submit" class="headerlink" title="excute和submit"></a>excute和submit</h2><p><strong>1.参数</strong></p>
<p>execute Runnable.run</p>
<p>submit callable</p>
<p><strong>2.返回值</strong></p>
<p>execute void</p>
<p>submit Future</p>
<p><strong>3.异常</strong></p>
<p>execute 会在子线程中抛出异常，在主线程捕捉不到</p>
<p>submit不会字码抛出异常，而是会讲一次暂时存起来，等Future.get()方法的时候才会抛出，可以在主线程捕捉，处理异常更方便</p>
<h2 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                        <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                        <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                        TimeUnit unit,</span></span><br><span class="line"><span class="params">                        BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                        ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                        RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>
<p>corePoolSize:核心线程池数量<br>maximumPoolSize:最大线程数量<br>keepAliveTime:非核心线程的空闲状态的存活时间(数字1)<br>unit:时间单位(天、小时、…)<br>workQueue:工作队列（阻塞队列）</p>
<ul>
<li>ArrayBlockingQueue，基于数组结构的有界阻塞队列</li>
<li>LinkedBlockingQueue，⼀个基于链表结构的有界阻塞队列，默认为<code>Integer.MAX_VALUE</code></li>
<li>SynchronousQueue，不存储元素的阻塞队列</li>
<li>DelayQueue，⽀持延时获取元素的⽆界阻塞队列</li>
<li>PriorityBlockingQueue，⼀个具有优先级的⽆限阻塞队列</li>
</ul>
<p>threadFactory：线程⼯⼚，主要⽤来创建线程，一般默认<code>Executors.defaultThreadFactory()</code></p>
<p>handler：表示当拒绝处理任务时的策略，有以下四种取值</p>
<ul>
<li><code>ThreadPoolExecutor.AbortPolicy</code>: :raising_hand_woman:丢弃任务并抛出RejectedExecutionException异常，<strong>常用</strong></li>
<li>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前⾯的任务，然后重新尝试执⾏任务<br>（重复此过程）</li>
<li>ThreadPoolExecutor.CallerRunsPolicy：由调⽤线程处理该任务</li>
</ul>
<h2 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">               <span class="number">10</span>,</span><br><span class="line">               <span class="number">20</span>,</span><br><span class="line">               <span class="number">0L</span>,</span><br><span class="line">               TimeUnit.SECONDS,</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="number">10</span>),</span><br><span class="line">               Executors.defaultThreadFactory(),</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()</span><br><span class="line">       );</span><br><span class="line">       <span class="comment">//10个顾客请求</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">               <span class="type">MyTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(i);</span><br><span class="line">               threadPool.execute(task);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           threadPool.shutdown();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>首先提交的10个任务</strong>：这些任务会立即由线程池中的核心线程开始执行。</li>
<li><strong>接下来提交的10个任务</strong>：由于核心线程已经满了，这些任务会被放入阻塞队列中等待执行。</li>
<li><strong>再接下来提交的10个任务</strong>：阻塞队列已满，线程池会创建新的线程来执行这些任务，直到线程池达到最大线程数20。</li>
<li><strong>剩余的70个任务</strong>：由于线程池和阻塞队列都已满，根据<code>AbortPolicy</code>拒绝策略，提交这些任务会导致<code>RejectedExecutionException</code>异常。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">26</span></span><br><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="number">29</span></span><br><span class="line">java.util.concurrent.RejectedExecutionException: Task com.hdb.juclearn.threadpoll.MyTask@728938a9 rejected from java.util.concurrent.ThreadPoolExecutor@21b8d17c[Running, <span class="type">pool</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">20</span>, <span class="type">active</span> <span class="variable">threads</span> <span class="operator">=</span> <span class="number">20</span>, <span class="type">queued</span> <span class="variable">tasks</span> <span class="operator">=</span> <span class="number">10</span>, <span class="type">completed</span> <span class="variable">tasks</span> <span class="operator">=</span> <span class="number">0</span>]</span><br><span class="line">	at java.base/java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:<span class="number">2065</span>)</span><br><span class="line">	at java.base/java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:<span class="number">833</span>)</span><br><span class="line">	at java.base/java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:<span class="number">1365</span>)</span><br><span class="line">	at com.hdb.juclearn.threadpoll.C2_CustomeThreadPool.main(C2_CustomeThreadPool.java:<span class="number">23</span>)</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>
<h2 id="创建线程方法选用"><a href="#创建线程方法选用" class="headerlink" title="创建线程方法选用"></a>创建线程方法选用</h2><p>超级大坑 在工作中单一的/固定数的/可变的三种创建线程池的方法哪个用的多？</p>
<blockquote>
<p>答案是一个都不用，我们工作中只能使用自定义的</p>
</blockquote>
<p><strong>FixedThreadPool和SingleThreadPool:</strong></p>
<p>允许的请求队列长度为Integer.MAX_VALUE,可能会堆积大量的请求，从而导致O0M。</p>
<p><strong>CachedThreadPool和ScheduledThreadPool:</strong></p>
<p>允许的创建线程数量为Integer.MAX_VALUE,可能会创建大量的线程，从而导致OOM。</p>
<h2 id="Tomcat和JDK线程池区别"><a href="#Tomcat和JDK线程池区别" class="headerlink" title="Tomcat和JDK线程池区别"></a>Tomcat和JDK线程池区别</h2><p>jdk创建线程池执行前是没有线程的，Tomcat创建线程池的构造函数会额外调用<code>prestartAllCoreThreads</code></p>
<p>函数，预先启动所有的核心线程。</p>
<h2 id="线程池如何创建线程"><a href="#线程池如何创建线程" class="headerlink" title="线程池如何创建线程"></a>线程池如何创建线程</h2><ol>
<li><p>未达到核心线程数（假设10个），创建新的线程执行任务</p>
</li>
<li><p>线程保活，通过阻塞队列让线程执行阻塞队列中的任务，没有获取到任务线程就会阻塞</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayBlockingQueue&lt;Runnable&gt; arrayBlockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        Runnable task;</span><br><span class="line">        <span class="keyword">while</span> ((task = arrayBlockingQueue.poll()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            task.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<ol>
<li>阻塞队列满，创建新的线程执行新来的任务，直到达到最大线程数（包括核心线程数）</li>
</ol>
<h2 id="线程池淘汰策略"><a href="#线程池淘汰策略" class="headerlink" title="线程池淘汰策略"></a>线程池淘汰策略</h2><p>假设有200个线程，淘汰到最后只剩10个，就是核心线程，不一定只淘汰后续创建的线程</p>
<p>注意<code>compareAndDecrementWorkerCount</code>，成功的线程被淘汰</p>
<p>Runnable r = timed ?<br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>                workQueue.take();</p>
<p>一个是限时阻塞，一个是长期阻塞</p>
<p>从队列获取任务时，允许核心线程超时或者当前线程数大于corePoolSize时，使用poll方法拉取任务，超过keepAliveTimel时返回null,否则使用take方法阻塞拉取任务，直到获取到任务或者线程被中断将<code>timedOut</code>变为false表示非正常超时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 循环调用，其中会判断线程池状态</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line">    	<span class="comment">// 线程池即将关闭状态，如果阻塞队列中也没有任务了，返回null，runWorker方法没有拿到task则退出while循环，销毁线程。</span></span><br><span class="line">        <span class="comment">// 这里根据shutdown和shutdownNow设置不同的线程池状态走不同的逻辑</span></span><br><span class="line">        <span class="comment">// 如果线程池状态是STOP则直接线程数减1，然后返回null，runWorker方法会退出while循环，线程销毁</span></span><br><span class="line">        <span class="comment">// 如果线程池状态是SHUTDOWN则再看看阻塞队列是否为空，为空则线程数减1，后续线程销毁，不会空则继续获取任务</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">// 获取当前线程数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">    	<span class="comment">// 是否允许超时标识，allowCoreThreadTimeOut核心线程是否允许超时</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">    	<span class="comment">// 非核心线程过多或者允许超时的情况下，如果队列为空则工作线程减1，后续销毁线程，这里就返回null</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 允许核心线程超时或者线程数大于核心线程数时，采用poll取数据，非阻塞，超过keepAliveTime没有获取到数据就继续自旋获取任务，</span></span><br><span class="line">            <span class="comment">// 不允许核心线程超时或者线程数小于等于核心线程数时，采用take取数据，阻塞等待直到获取到任务或者被中断</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程异常"><a href="#线程异常" class="headerlink" title="线程异常"></a>线程异常</h2><p>工作线程结束有两种情况，一种是执行任务过程中发生异常，会将异常抛出，当前线程结束销毁（被淘汰掉），但是会创建一个新的线程；</p>
<p>还有一种情况是Woker的task为null或者getTask方法从阻塞队列未获取到任务，线程正常销毁结束。</p>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><p>将线程池状态设置为SHUTDOWN后不再接受新任务，将阻塞队列的任务执行完成后，线程池关闭。</p>
<h3 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h3><ul>
<li>调用shutdownNow方法会将线程池状态设置为STOP后不再接受新任务，然后将所有线程中断（这里的中断已经拿到任务并执行不会响应中断，是在调用getTask获取下一个任务时看线程池状态为STOP则不会再取阻塞队列任务，直接返回null，然后工作线程销毁</li>
<li>还有一种情况是正在阻塞等待拿任务，阻塞在poll或take上，都会响应中断，然后再一次循环任务返回null），并将未执行的任务返回，线程池关闭。</li>
</ul>
]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>JUC</tag>
        <tag>ThreadPool</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录-二叉树3</title>
    <url>/2024/03/11/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%953%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p><strong>本节包括：</strong></p>
<ul>
<li>二叉树（部分）</li>
</ul>
<span id="more"></span>
<h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a>108.将有序数组转换为二叉搜索树</h2><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 升序 排列，请你将其转换为一棵平衡二叉搜索树。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>本质就是寻找分割点，分割点作为当前节点，然后递归左区间和右区间</strong>。</p>
<p>分割点就是数组中间位置的节点。</p>
<p>采用[left,right]左闭右闭</p>
<h3 id="越界注意"><a href="#越界注意" class="headerlink" title="越界注意"></a>越界注意</h3><p>首先取数组中间元素的位置，不难写出<code>int mid = (left + right) / 2;</code>，这么写其实有一个问题，就是数值越界，例如left和right都是最大int，这么操作就越界了，</p>
<p>所以可以这么写：<code>int mid = left + ((right - left) / 2);</code></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortedArrayToBST</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> buildBST(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildBST</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; left) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = buildBST(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        root.right = buildBST(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538.把二叉搜索树转换为累加树"></a>538.把二叉搜索树转换为累加树</h2><p>给出二叉搜索树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201023160751832.png" alt="538.把二叉搜索树转换为累加树" style="zoom:50%;" /></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>采用中序遍历思想，不过是右中左的方式，累加结果，赋予当前<strong>中节点</strong></p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConvertBSTtoGST</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        convertInOrder(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按右中左顺序遍历，累加即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">convertInOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        convertInOrder(root.right);</span><br><span class="line">        sum += root.val;</span><br><span class="line">        root.val = sum;</span><br><span class="line">        convertInOrder(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code_Musing</category>
      </categories>
      <tags>
        <tag>binaryTree</tag>
        <tag>traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu小技巧</title>
    <url>/2024/03/20/tips/ubuntuTips/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul>
<li>screen</li>
<li>conda</li>
<li>常用命令</li>
</ul>
<span id="more"></span>
<h2 id="Screen"><a href="#Screen" class="headerlink" title="Screen"></a>Screen</h2><p><strong>新建一个screen会话</strong></p>
<p>screen -S &lt;名字&gt;</p>
<p><strong>退出当前screen会话</strong></p>
<p>键盘点击ctrl+a , 然后按d</p>
<p><strong>查看所有screen会话</strong></p>
<p>screen -ls</p>
<p><strong>进入（恢复）某一screen会话</strong></p>
<p>screen -r &lt;会话序列号&gt;</p>
<p><strong>关闭screen会话</strong></p>
<p>screen -X -S &lt;序列号&gt; quit</p>
<h2 id="conda"><a href="#conda" class="headerlink" title="conda"></a>conda</h2><p>查看虚拟环境列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda <span class="built_in">env</span> list</span><br><span class="line">conda info --envs</span><br></pre></td></tr></table></figure>
<p>删除环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda remove -n env_name --all</span><br></pre></td></tr></table></figure>
<p>创建虚拟环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create -n name python=3.8</span><br></pre></td></tr></table></figure>
<p>激活虚拟环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda activate name</span><br></pre></td></tr></table></figure>
<p>退出虚拟环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure>
<h2 id="查看进程和杀死"><a href="#查看进程和杀死" class="headerlink" title="查看进程和杀死"></a>查看进程和杀死</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top u name</span><br><span class="line">pkill name</span><br></pre></td></tr></table></figure>
<h2 id="统计文件数"><a href="#统计文件数" class="headerlink" title="统计文件数"></a>统计文件数</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -1A | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure>
<h2 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h2><p>正则匹配</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> | grep <span class="string">&#x27;\.py$&#x27;</span></span><br></pre></td></tr></table></figure>
<p>模糊匹配</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> | grep requi</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(pytorch_yolo) ➜  yolov5-pytorch git:(main) ✗ <span class="built_in">ls</span> | grep requi</span><br><span class="line">requirements.txt</span><br></pre></td></tr></table></figure>
<h2 id="Mysql使用"><a href="#Mysql使用" class="headerlink" title="Mysql使用"></a>Mysql使用</h2><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用root用户登录</span></span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>
<h3 id="显示使用数据库列表"><a href="#显示使用数据库列表" class="headerlink" title="显示使用数据库列表"></a>显示使用数据库列表</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">show databases;</span><br><span class="line">use database_name;</span><br></pre></td></tr></table></figure>
<h3 id="建库与删库"><a href="#建库与删库" class="headerlink" title="建库与删库"></a>建库与删库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create database seal_log character <span class="built_in">set</span> utf8</span><br><span class="line">drop database seal_log;</span><br></pre></td></tr></table></figure>
<h3 id="建表与删表"><a href="#建表与删表" class="headerlink" title="建表与删表"></a>建表与删表</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">use seal_log;</span><br><span class="line">create table 表名(字段列表);</span><br><span class="line">drop table 表名;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#创建与数据库的连接</span></span><br><span class="line">    <span class="comment">#参数分别是 指定本机 数据库用户名 数据库密码 数据库名 端口号 autocommit是是否自动提交（非常不建议，万一出问题不好回滚）</span></span><br><span class="line">    db=pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>,user=<span class="string">&#x27;xxx&#x27;</span>,password=<span class="string">&#x27;xxx&#x27;</span>,database=<span class="string">&#x27;seal_log&#x27;</span>,port=<span class="number">3309</span>,autocommit=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment">#创建游标对象cursor</span></span><br><span class="line">    cursor=db.cursor()</span><br><span class="line">    <span class="comment">#使用execute()方法执行sql，如果表存在则删除</span></span><br><span class="line">    cursor.execute(<span class="string">&#x27;drop table if EXISTS logs&#x27;</span>)</span><br><span class="line">    <span class="comment">#创建表的sql</span></span><br><span class="line">    sql=<span class="string">&#x27;&#x27;&#x27;CREATE TABLE IF NOT EXISTS logs</span></span><br><span class="line"><span class="string">             (user_id INTEGER PRIMARY KEY,</span></span><br><span class="line"><span class="string">              disk_speed_per REAL,</span></span><br><span class="line"><span class="string">              cpu INTEGER,</span></span><br><span class="line"><span class="string">              gpu INTEGER,</span></span><br><span class="line"><span class="string">              pass_failed INTEGER,</span></span><br><span class="line"><span class="string">              authorization INTEGER,</span></span><br><span class="line"><span class="string">              transgression_number INTEGER,</span></span><br><span class="line"><span class="string">              up_traffic INTEGER,</span></span><br><span class="line"><span class="string">              down_traffic INTEGER,</span></span><br><span class="line"><span class="string">              svm_cipher BLOB)&#x27;&#x27;&#x27;</span></span><br><span class="line">    cursor.execute(sql)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;创建表失败:&#x27;</span>, e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment">#关闭数据库连接</span></span><br><span class="line">    db.close()</span><br></pre></td></tr></table></figure>
<h3 id="显示数据表的结构"><a href="#显示数据表的结构" class="headerlink" title="显示数据表的结构"></a>显示数据表的结构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">describe logs;</span><br></pre></td></tr></table></figure>
<h2 id="端口打开与关闭"><a href="#端口打开与关闭" class="headerlink" title="端口打开与关闭"></a>端口打开与关闭</h2><p>打开40000</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo iptables -A INPUT -p tcp --dport 40000 -j ACCEPT</span><br></pre></td></tr></table></figure>
<p>列出所有端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo iptables -L INPUT --line-numbers</span><br></pre></td></tr></table></figure>
<p><strong>删除特定编号的规则</strong>： 根据上一步显示的编号，如果开放端口 40000 的规则是第 N 号，使用以下命令删除它：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo iptables -D INPUT N</span><br></pre></td></tr></table></figure>
<h2 id="conda环境打包"><a href="#conda环境打包" class="headerlink" title="conda环境打包"></a>conda环境打包</h2><p>1、 安装conda-pack</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install -c conda-forge conda-pack</span><br></pre></td></tr></table></figure>
<p>2、 打包虚拟环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda pack -n sf -o sf_output.tar.gz</span><br></pre></td></tr></table></figure>
<p>3、 新机器上安装<strong>打包的conda环境</strong></p>
<ol>
<li><strong>复制压缩文件sf_output.tar.gz 到新的电脑环境</strong></li>
<li>进入到conda的安装目录下：<strong>/anaconda(或者miniconda)/envs/</strong>，在该名目录下创建文件夹，复制sf_output.tar.gz 到文件夹中。</li>
<li>解压conda环境：<strong>tar -xzvf sf_output.tar.gz</strong></li>
<li>使用conda env list查看虚拟环境</li>
<li>conda activate激活环境</li>
</ol>
<h2 id="clash"><a href="#clash" class="headerlink" title="clash"></a>clash</h2><p>命令开启</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo bash start.sh</span><br><span class="line"><span class="built_in">source</span> /etc/profile.d/clash.sh</span><br><span class="line">proxy_on</span><br></pre></td></tr></table></figure>
<p>关闭</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proxy_off</span><br></pre></td></tr></table></figure>
<h2 id="python函数说明文档"><a href="#python函数说明文档" class="headerlink" title="python函数说明文档"></a>python函数说明文档</h2><p>查询函数库中的函数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -m pydoc -p 1234</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>tips</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录-回溯算法</title>
    <url>/2024/03/24/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p><strong>本节包括：</strong></p>
<ul>
<li>回溯概念</li>
<li>组合</li>
<li>分割回文</li>
<li>排列</li>
<li>N皇后</li>
</ul>
<span id="more"></span>
<p><strong>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。</strong></p>
<p>回溯是递归的副产品，只要有递归就会有回溯。</p>
<p><strong>因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案</strong>，如果想让回溯法高效一些，可以加一些<strong>剪枝</strong>的操作，但也改不了回溯法就是穷举的本质。</p>
<h2 id="回溯法解决的问题"><a href="#回溯法解决的问题" class="headerlink" title="回溯法解决的问题"></a>回溯法解决的问题</h2><ul>
<li>组合问题：N个数里面按一定规则找出k个数的集合</li>
<li>切割问题：一个字符串按一定规则有几种切割方式</li>
<li>子集问题：一个N个数的集合里有多少符合条件的子集</li>
<li>排列问题：N个数按一定规则全排列，有几种排列方式</li>
<li>棋盘问题：N皇后，解数独等等</li>
</ul>
<h2 id="回溯法模板"><a href="#回溯法模板" class="headerlink" title="回溯法模板"></a>回溯法模板</h2><p>回溯算法中函数返回值一般为void。</p>
<ul>
<li>回溯函数伪代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(参数)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>回溯函数终止条件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">    存放结果;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>回溯搜索的遍历过程</li>
</ul>
<p>在上面我们提到了，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210130173631174.png" alt="回溯算法理论基础" style="zoom:45%;" /></p>
<p>可以从图中看出<strong>for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历</strong>，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。</p>
<p>分析完过程，回溯算法模板框架如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(参数)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="77-组合"><a href="#77-组合" class="headerlink" title="77.组合"></a>77.组合</h2><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p>
<p>你可以按 <strong>任何顺序</strong> 返回答案。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>那么我把组合问题抽象为如下树形结构：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195223940.png" alt="77.组合" style="zoom:50%;" /></p>
<p>函数里一定有两个参数，既然是集合n里面取k个数，那么n和k是两个int型的参数。</p>
<p>然后还需要一个参数，为int型变量<code>startIndex</code>，这个参数用来记录本层递归的中，集合从哪里开始遍历（集合就是[1,…,n] ）。</p>
<p>for循环每次从<code>startIndex</code>开始遍历，然后用path保存取到的节点i。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= n; i++) &#123; <span class="comment">// 控制树的横向遍历</span></span><br><span class="line">    path.push_back(i); <span class="comment">// 处理节点</span></span><br><span class="line">    backtracking(n, k, i + <span class="number">1</span>); <span class="comment">// 递归：控制树的纵向遍历，注意下一层搜索要从i+1开始</span></span><br><span class="line">    path.pop_back(); <span class="comment">// 回溯，撤销处理的节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="剪枝优化"><a href="#剪枝优化" class="headerlink" title="剪枝优化"></a>剪枝优化</h3><ol>
<li>已经选择的元素个数：path.size();</li>
<li>还需要的元素个数为: k - path.size();</li>
<li>在集合n中至多要从该起始位置 : <code>n - (k - path.size()) + 1</code>，开始遍历</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CombineK</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        backtracking(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIdx)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIdx; i &lt;= n - (k - path.size()) + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            backtracking(n, k, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="216-组合总和3"><a href="#216-组合总和3" class="headerlink" title="216.组合总和3"></a>216.组合总和3</h2><p>找出所有相加之和为 <code>n</code> 的 <code>k</code> 个数的组合，且满足下列条件：</p>
<ul>
<li>只使用数字1到9</li>
<li>每个数字 <strong>最多使用一次</strong> </li>
</ul>
<p>返回所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol>
<li>k其实就已经限制树的深度</li>
<li>所以如果path.size() 和 k相等了，就终止。如果此时path里收集到的元素和（sum） 和targetSum（就是题目描述的n）相同了，就用result收集当前的结果。</li>
<li>已选元素总和如果已经大于n（图中数值为4）了，那么往后遍历就没有意义了，直接剪掉。</li>
<li>for循环的范围也可以剪枝，i &lt;= 9 - (k - path.size()) + 1就可以了。</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CombinationSum3</span> &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        backtracking(n, k, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> k, <span class="type">int</span> sum, <span class="type">int</span> startIdx)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target == sum) &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIdx; i &lt;= <span class="number">9</span> - (k - path.size()) + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            path.add(i);</span><br><span class="line">            <span class="comment">//不符合，直接剪枝</span></span><br><span class="line">            <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                sum -= i;</span><br><span class="line">                path.removeLast();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            backtracking(target, k, sum, i + <span class="number">1</span>);</span><br><span class="line">            sum -= i;</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" alt="img"></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol>
<li>数字和字母如何映射：可以使用map或者定义一个二维数组</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] numMaps = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>终止条件：如果num 等于字符串长度digits.length()</li>
<li><p><strong>字符类型的数字转化为int类型的数字可以通过<code>c-&#39;0&#39;</code>实现</strong></p>
</li>
<li><p>遍历当前数字映射的所有字符，并回溯</p>
</li>
</ol>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LetterCombinations</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        String[] numMaps = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> (digits.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        backTracking(digits, numMaps, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(String digits, String[] numMaps, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == digits.length()) &#123;</span><br><span class="line">            res.add(temp.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前数字代表的字母组合</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> numMaps[digits.charAt(num) - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            temp.append(str.charAt(i));</span><br><span class="line">            backTracking(digits, numMaps, num + <span class="number">1</span>);</span><br><span class="line">            temp.deleteCharAt(temp.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h2><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
<p>说明：</p>
<ul>
<li>所有数字（包括 target）都是正整数。</li>
<li>解集不能包含重复的组合。</li>
</ul>
<p>示例 1：</p>
<ul>
<li>输入：candidates = [2,3,6,7], target = 7,</li>
<li>所求解集为： [ [7], [2,2,3] ]</li>
</ul>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>target&gt;sum和target==sum截止</p>
<p>采用回溯法</p>
<p>如果至少一个数字的被选数量不同，则两种组合是不同的，需要按照一定顺序向下遍历，因此需要从i开始作为start</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bachtracking(candidates, target, sum, i);</span><br></pre></td></tr></table></figure>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CombinationSum</span> &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        backtracking(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> startIdx)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == sum) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; sum) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIdx; i &lt; candidates.length; i++) &#123;</span><br><span class="line">                sum += candidates[i];</span><br><span class="line">                path.add(candidates[i]);</span><br><span class="line">                backtracking(candidates, target, sum, i);</span><br><span class="line">                sum -= candidates[i];</span><br><span class="line">                path.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="40-组合总和II"><a href="#40-组合总和II" class="headerlink" title="40.组合总和II"></a>40.组合总和II</h2><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p>
<p><strong>注意：</strong>解集不能包含重复的组合。 </p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,1,6],</span><br><span class="line">[1,2,5],</span><br><span class="line">[1,7],</span><br><span class="line">[2,6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000918.png" alt="40.组合总和II" style="zoom: 40%;" /></p>
<h3 id="代码实现1"><a href="#代码实现1" class="headerlink" title="代码实现1"></a>代码实现1</h3><p>不使用used数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;Integer&gt; path;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    backtracking(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> startIdx)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target == sum) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIdx; i &lt; candidates.length &amp;&amp; target &gt;= sum + candidates[i]; i++) &#123;</span><br><span class="line">        <span class="comment">//同一层不能选重复数字，同一分支可以选择重复数字</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; startIdx &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += candidates[i];</span><br><span class="line">        path.add(candidates[i]);</span><br><span class="line">        backtracking(candidates, target, sum, i + <span class="number">1</span>);</span><br><span class="line">        sum -= candidates[i];</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码实现2"><a href="#代码实现2" class="headerlink" title="代码实现2"></a>代码实现2</h3><p>使用used数组</p>
<ul>
<li>used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</li>
<li>used[i - 1] == false，说明同一树层candidates[i - 1]使用过</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;Integer&gt; path;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"><span class="type">boolean</span>[] used;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    used = <span class="keyword">new</span> <span class="title class_">boolean</span>[candidates.length];</span><br><span class="line">    Arrays.fill(used, <span class="literal">false</span>);</span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    backtracking(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> startIdx)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target == sum) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIdx; i &lt; candidates.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum + candidates[i] &gt; target) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//同一层不能选重复数字，同一分支可以选择重复数字</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        sum += candidates[i];</span><br><span class="line">        path.add(candidates[i]);</span><br><span class="line">        backtracking(candidates, target, sum, i + <span class="number">1</span>);</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">        sum -= candidates[i];</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h2><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong>。返回 <code>s</code> 所有可能的分割方案。</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p><strong>判断回文</strong></p>
<p>可以使用双指针法，一个指针从前向后，一个指针从后向前，如果前后指针所指向的元素是相等的，就是回文字符串了。</p>
<p><strong>切割方法</strong></p>
<ul>
<li>首先判断当前子串是不是回文，如果是回文，就加入在<code>Deque&lt;String&gt; queue</code>中，<code>queue</code>用来记录切割过的回文子串。</li>
<li>下次再<code>startIdx =i+1</code>处开始继续递归</li>
<li>结果最后回溯<code>queue.removeLast();</code></li>
</ul>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Deque&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    backtracking(s, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(String s, <span class="type">int</span> startIdx)</span> &#123;</span><br><span class="line">    <span class="comment">//如果起始位置大于s的大小，说明找到了一组分割方案</span></span><br><span class="line">    <span class="keyword">if</span> (startIdx &gt;= s.length()) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(queue));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIdx; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="comment">//如果是回文子串，则记录</span></span><br><span class="line">        <span class="keyword">if</span> (isPalindrome(s, startIdx, i)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.substring(startIdx, i + <span class="number">1</span>);</span><br><span class="line">            queue.add(str);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//起始位置后移，保证不重复</span></span><br><span class="line">        backtracking(s, i + <span class="number">1</span>);</span><br><span class="line">        queue.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否是回文</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) != s.charAt(j)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93.复原IP地址"></a>93.复原IP地址</h2><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p>
<p>有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p>
<p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效的 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “192.168@1.1” 是 无效的 IP 地址。</p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>判断当前子字符串是否符合ip地址格式：0~255，没有特殊字符</p>
<p>回溯：</p>
<p>当dotCount=3时，递归结束，判断当前ip地址是否符合条件，是否加入res</p>
<p>对字符串的操作，加入 <code>.</code>删除 <code>.</code>分别用通过insert和deleteCharAt实现，i+1是偏移，表示在i+1处插入删除（从0开始）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; sb.length(); i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (isValid(sb, start, i)) &#123;</span><br><span class="line">               sb.insert(i + <span class="number">1</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">               backtracking(sb, i + <span class="number">2</span>, dotCount + <span class="number">1</span>);</span><br><span class="line">               sb.deleteCharAt(i + <span class="number">1</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//当前的字符串已经不满足&lt;255等条件</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestoreIpAddresses</span> &#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);</span><br><span class="line">        backtracking(sb, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(StringBuilder sb, <span class="type">int</span> start, <span class="type">int</span> dotCount)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dotCount == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isValid(sb, start, sb.length() - <span class="number">1</span>)) &#123;</span><br><span class="line">                res.add(sb.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; sb.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isValid(sb, start, i)) &#123;</span><br><span class="line">                sb.insert(i + <span class="number">1</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                backtracking(sb, i + <span class="number">2</span>, dotCount + <span class="number">1</span>);</span><br><span class="line">                sb.deleteCharAt(i + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//当前的字符串已经不满足&lt;255等条件</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(StringBuilder s, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(start) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; start != end) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (digit &lt; <span class="number">0</span> || digit &gt; <span class="number">9</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            num = num * <span class="number">10</span> + digit;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">255</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78.子集"></a>78.子集</h2><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>示例: 输入: nums = [1,2,3] 输出: [ [3],  [1],  [2],  [1,2,3],  [1,3],  [2,3],  [1,2],  [] ]</p>
<h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，<strong>那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！</strong></p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/78.%E5%AD%90%E9%9B%86.png" alt="78.子集" style="zoom: 40%;" /></p>
<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subsets</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> LinkedList&lt;Integer&gt; subset = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        backtracking(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(subset));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            subset.add(nums[i]);</span><br><span class="line">            backtracking(nums, i + <span class="number">1</span>);</span><br><span class="line">            subset.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="90-子集II"><a href="#90-子集II" class="headerlink" title="90.子集II"></a>90.子集II</h2><p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>示例:</p>
<ul>
<li>输入: [1,2,2]</li>
<li>输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ]</li>
</ul>
<h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>同层不能取同一个数字其他和<code>78.子集</code>一样的思路</p>
<p>先要排序<code>Arrays.sort(nums);</code>，第二个重复的同层不能取</p>
<p>一定要记得，存储res时，要<code>res.add(new ArrayList&lt;&gt;(subset));</code></p>
<h3 id="代码实习"><a href="#代码实习" class="headerlink" title="代码实习"></a>代码实习</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubsetsWithDup</span> &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; subset = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtracking(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(subset));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            subset.add(nums[i]);</span><br><span class="line">            backtracking(nums, i + <span class="number">1</span>);</span><br><span class="line">            subset.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491.递增子序列"></a>491.递增子序列</h2><p>给你一个整数数组 <code>nums</code> ，找出并返回所有该数组中不同的递增子序列，递增子序列中 <strong>至少有两个元素</strong> 。你可以按 <strong>任意顺序</strong> 返回答案。</p>
<p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p>
<h3 id="思路-回溯法"><a href="#思路-回溯法" class="headerlink" title="思路-回溯法"></a>思路-回溯法</h3><p>定义一个used数组或者set、hashmap，用户保存每一层使用过的元素，不能<strong>直接排序</strong></p>
<p>考虑到<code>-100 &lt;= nums[i] &lt;= 100</code>，于是采用数组实现used</p>
<h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindSubsequences</span> &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findSubsequences</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        backtracking(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] used = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">201</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[nums[i] + <span class="number">100</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (path.isEmpty() || nums[i] &gt;= path.getLast()) &#123;</span><br><span class="line">                used[nums[i] + <span class="number">100</span>] = <span class="number">1</span>;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                backtracking(nums, i + <span class="number">1</span>);</span><br><span class="line">                path.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46.全排列"></a>46.全排列</h2><p>给定一个 没有重复数字的序列，返回其所有可能的全排列。</p>
<p>示例:</p>
<ul>
<li>输入: [1,2,3]</li>
<li>输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]</li>
</ul>
<h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><p>采用used数组记录已经挑选过后的元素，使用了continue，未使用加入path，继续递归知道<code>path.size==nums.length</code>.</p>
<h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Permute</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">boolean</span>[] used;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        backtracking(nums, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] used)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backtracking(nums, used);</span><br><span class="line">            path.removeLast();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47.全排列 II"></a>47.全排列 II</h2><p>给定一个可包含重复数字的序列 <code>nums</code> ，<strong><em>按任意顺序</em></strong> 返回所有不重复的全排列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure>
<h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><p>在使用used的基础需要额外：</p>
<p>对数组排序，同一层不能取重复元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//之前已经取过相同元素，并且将used[i-1]重置为false</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; !used[i - <span class="number">1</span>] &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>
<h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    backtracking(nums, used);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] used)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.size() == nums.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">//之前已经取过相同元素，并且将used[i-1]重置为false</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; !used[i - <span class="number">1</span>] &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backtracking(nums, used);</span><br><span class="line">            path.removeLast();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="332-重新安排行程"><a href="#332-重新安排行程" class="headerlink" title="332.重新安排行程"></a>332.重新安排行程</h2><p>给你一份航线列表 <code>tickets</code> ，其中 <code>tickets[i] = [fromi, toi]</code> 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。</p>
<p>所有这些机票都属于一个从 <code>JFK</code>（肯尼迪国际机场）出发的先生，所以该行程必须从 <code>JFK</code> 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。</p>
<ul>
<li>例如，行程 <code>[&quot;JFK&quot;, &quot;LGA&quot;]</code> 与 <code>[&quot;JFK&quot;, &quot;LGB&quot;]</code> 相比就更小，排序更靠前。</li>
</ul>
<p>假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/14/itinerary1-graph.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：tickets = [[&quot;MUC&quot;,&quot;LHR&quot;],[&quot;JFK&quot;,&quot;MUC&quot;],[&quot;SFO&quot;,&quot;SJC&quot;],[&quot;LHR&quot;,&quot;SFO&quot;]]</span><br><span class="line">输出：[&quot;JFK&quot;,&quot;MUC&quot;,&quot;LHR&quot;,&quot;SFO&quot;,&quot;SJC&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/14/itinerary2-graph.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：tickets = [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]</span><br><span class="line">输出：[&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]</span><br><span class="line">解释：另一种有效的行程是 [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;] ，但是它字典排序更大更靠后。</span><br></pre></td></tr></table></figure>
<h3 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h3><p>避免出现死循环</p>
<p>开始时path要加入JFK</p>
<p>终止条件<code>path.size() == tickets.size() + 1</code></p>
<h3 id="Colections-sort"><a href="#Colections-sort" class="headerlink" title="Colections.sort"></a>Colections.sort</h3><p>本题中直接使用List自带的sort，<code>tickets.sort((a, b) -&gt; a.get(1).compareTo(b.get(1)))</code>;sort方法比较字符串，升序排序。</p>
<h3 id="代码实现-会超时"><a href="#代码实现-会超时" class="headerlink" title="代码实现-会超时"></a>代码实现-会超时</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindItinerary</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; res;</span><br><span class="line">    <span class="keyword">public</span> LinkedList&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findItinerary</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span> &#123;</span><br><span class="line">        tickets.sort((a, b) -&gt; a.get(<span class="number">1</span>).compareTo(b.get(<span class="number">1</span>)));</span><br><span class="line">        path.add(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> used[] = <span class="keyword">new</span> <span class="title class_">boolean</span>[tickets.size()];</span><br><span class="line">        backtracking((ArrayList) tickets, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backtracking</span><span class="params">(ArrayList&lt;List&gt; tickets, <span class="type">boolean</span>[] used)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == tickets.size() + <span class="number">1</span>) &#123;</span><br><span class="line">            res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tickets.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[i] &amp;&amp; tickets.get(i).get(<span class="number">0</span>).equals(path.getLast())) &#123;</span><br><span class="line">                path.add((String) tickets.get(i).get(<span class="number">1</span>));</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (backtracking(tickets, used)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">                path.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="法二-使用map函数"><a href="#法二-使用map函数" class="headerlink" title="法二-使用map函数"></a>法二-使用map函数</h3><p>Hierholzer 算法用于在连通图中寻找欧拉路径，其流程如下：</p>
<ul>
<li><p>从起点出发，进行深度优先搜索。</p>
</li>
<li><p>每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边。</p>
</li>
<li><p>如果没有可移动的路径，则将所在节点加入到栈中，并返回。</p>
</li>
</ul>
<p>不妨倒过来思考。我们注意到只有那个入度与出度差为 111 的节点会导致死胡同。而该节点必然是最后一个遍历到的节点。我们可以改变入栈的规则，当我们遍历完一个节点所连的所有节点后，我们才将该节点入栈（即逆序入栈）。</p>
<p>对于当前节点而言，从它的每一个非「死胡同」分支出发进行深度优先搜索，都将会搜回到当前节点。而从它的「死胡同」分支出发进行深度优先搜索将不会搜回到当前节点。也就是说当前节点的死胡同分支将会优先于其他非「死胡同」分支入栈。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindItineraryRec</span> &#123;</span><br><span class="line">    Map&lt;String, PriorityQueue&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, PriorityQueue&lt;String&gt;&gt;();</span><br><span class="line">    List&lt;String&gt; itinerary = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findItinerary</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; ticket : tickets) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> ticket.get(<span class="number">0</span>), dst = ticket.get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(src)) &#123;</span><br><span class="line">                map.put(src, <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;String&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(src).offer(dst);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        Collections.reverse(itinerary);</span><br><span class="line">        <span class="keyword">return</span> itinerary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String curr)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (map.containsKey(curr) &amp;&amp; map.get(curr).size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> map.get(curr).poll();</span><br><span class="line">            dfs(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        itinerary.add(curr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51. N皇后"></a>51. N皇后</h2><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p>
<p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。</p>
<p>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p>
<h3 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h3><p>如何验证当前节点是否符合条件</p>
<ol>
<li>检查列</li>
<li>45°和135°需要要检查</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//check 135 degrees</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将<code>char[][]</code>转化为字符窜，一定要复制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">char</span>[] chars : chessboard) &#123;</span><br><span class="line">    str.add(String.copyValueOf(chars));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一层遍历</p>
<h3 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SolveNQueens</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[][] chessboard = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>[] chars : chessboard) &#123;</span><br><span class="line">            Arrays.fill(chars, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        backtracking(n, <span class="number">0</span>, chessboard);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> row, <span class="type">char</span>[][] chessboard)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">            res.add(ArraysToList(chessboard));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isValid(row, col, n, chessboard)) &#123;</span><br><span class="line">                chessboard[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                backtracking(n, row + <span class="number">1</span>, chessboard);</span><br><span class="line">                chessboard[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">ArraysToList</span><span class="params">(<span class="type">char</span>[][] chessboard)</span> &#123;</span><br><span class="line">        List&lt;String&gt; str = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>[] chars : chessboard) &#123;</span><br><span class="line">            str.add(String.copyValueOf(chars));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> n, <span class="type">char</span>[][] chessboard)</span> &#123;</span><br><span class="line">        <span class="comment">//check column</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chessboard[i][col] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//check 45 degrees</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//check 135 degrees</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a>37. 解数独</h2><p>编写一个程序，通过填充空格来解决数独问题。</p>
<p>数独的解法需 <strong>遵循如下规则</strong>：</p>
<ol>
<li>数字 <code>1-9</code> 在每一行只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一列只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li>
</ol>
<p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p>
<ul>
<li><code>board.length == 9</code></li>
<li><code>board[i].length == 9</code></li>
<li><code>board[i][j]</code> 是一位数字或者 <code>&#39;.&#39;</code></li>
</ul>
<h3 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！</p>
</li>
<li><p>判断棋盘是否合法有如下三个维度：</p>
</li>
</ol>
<ul>
<li>同行是否重复</li>
<li>同列是否重复</li>
<li>9宫格里是否重复</li>
</ul>
<p>注意点：递归时何时返回true和false需要注意</p>
<h3 id="代码实现-10"><a href="#代码实现-10" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solveSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">       backtracking(board);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">               <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">k</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>; k &lt;= <span class="string">&#x27;9&#x27;</span>; k++) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (isValid(i, j, k, board)) &#123;</span><br><span class="line">                       board[i][j] = k;</span><br><span class="line">                       <span class="keyword">if</span> (backtracking(board)) &#123;</span><br><span class="line">                           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                       board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//1-9试完全失败</span></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//所有的都填充完毕，9*9continue，true</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">char</span> val, <span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">       <span class="comment">//check row</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (board[row][i] == val) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//check col</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (board[i][col] == val) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//check block</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">newRow</span> <span class="operator">=</span> row - row % <span class="number">3</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">newCol</span> <span class="operator">=</span> col - col % <span class="number">3</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> newRow; i &lt; newRow + <span class="number">3</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> newCol; j &lt; newCol + <span class="number">3</span>; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (board[i][j] == val) &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code_Musing</category>
      </categories>
      <tags>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC并发编程基础-线程安全</title>
    <url>/2024/03/26/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul>
<li>线程安全</li>
<li>volatile</li>
<li>原子类</li>
<li>锁</li>
<li>ReenTrantLock</li>
</ul>
<span id="more"></span>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>多线程下并发同时对共享数据进⾏读写，会造成数据混乱</p>
<p>当多线程并发访问临界资源时，如果破坏其<strong>原⼦性、可见性、有序性</strong>，可能会造成数据不⼀致。</p>
<blockquote>
<p>临界资源：共享资源（同⼀对象）同时读写，⼀次仅允许⼀个线程使⽤，才可保证其正确性</p>
</blockquote>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>原⼦性操作指相应的操作是单⼀不可分割的操作</p>
<h4 id="同步锁synchronized"><a href="#同步锁synchronized" class="headerlink" title="同步锁synchronized"></a>同步锁synchronized</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StockRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 购买.. stock=stock-1； 1000000-1</span></span><br><span class="line">            <span class="comment">//stock--;</span></span><br><span class="line">            stock--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>可见性是指当多个线程访问同⼀个变量时，⼀个线程修改了这个变量的值，其他线程能够⽴即看得到修改的值。</p>
<ol>
<li>synchronized 和 Lock 能保证同⼀时刻只有⼀个线程获取锁然后执⾏同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Boolean</span> <span class="variable">always</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (always) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (always) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;).start();</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    always = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>通过<code>System.out.println(&quot;执行...&quot;);</code>也可以刷新工作变量到主内存，因为这个打印方法包含了一个<code>synchronized</code>方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(String x)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (getClass() == PrintStream.class) &#123;</span><br><span class="line">    writeln(String.valueOf(x));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>Java提供了volatile关键字来保证可见性。当⼀个共享变量被<code>volatile</code>修饰时，它会保证修改的值会⽴即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Boolean</span> <span class="variable">always</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>有序性最终表述的现象是<strong>CPU是否按照既定代码顺序依次执⾏指令</strong>。编译器和CPU为了提⾼指令的执⾏效率可能会进⾏<strong>指令重排序</strong>，这使得代码的实际执⾏⽅式可能不是按照我们所认为的⽅式进⾏。</p>
<h2 id="破坏临界资源"><a href="#破坏临界资源" class="headerlink" title="破坏临界资源"></a>破坏临界资源</h2><h3 id="只读"><a href="#只读" class="headerlink" title="只读"></a>只读</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fianl</span><br></pre></td></tr></table></figure>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>每个线程使用自己的局部变量</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p><code>ThreadLocal</code>也就是线程本地变量。如果你创建了⼀个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的⼀个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从⽽起到线程隔离的作⽤，避免了线程安全问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> ThreadLocal&lt;User&gt; userThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">userThreadLocal.set(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userThreadLocal.get();</span><br></pre></td></tr></table></figure>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p>如果在线程池中使⽤ThreadLocal会造成内存泄漏，因为当ThreadLocal对象使⽤完之后，应该要把设置的key，value，也就是Entry对象进⾏回收，但线程池中的线程不会回收，⽽线程对象是通过<strong>强引⽤</strong>指向<code>ThreadLocalMap</code>，ThreadLocalMap也是通过强引⽤指向Entry对象，线程不被回收，Entry对象也就不会被回收，从⽽出现内存泄漏。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">userL.set(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">userL.remove();</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/03/08/86364_image-20240308153610276.png" alt="image-20240308153610276" style="zoom:40%;" /></p>
<h3 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h3><p>InheritableThreadLocal是ThreadLocal⼦类</p>
<p>:notes:<strong>主线程和ThreadLocal线程之间的变量是隔离的</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 替换成 InheritableThreadLocal</span></span><br><span class="line">    ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    threadLocal.set(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;value:&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码value的值为null</p>
<p>采用InheritableThreadLocal可以获取到test的值，但是使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InheritableThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>当我们改变了<code>InheritableThreadLocal</code>中的值过后，输出的值都是⼀样的。这是因为，<strong>使⽤线程池时，核⼼线程在⾸次使⽤被创建的时候能正确复制⽗线程的上下⽂，但之后已复制上下⽂的核⼼线程不会回收的情况下，线程池中的线程上下⽂将不会再被改变！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">threadLocal.set(<span class="string">&quot;test111&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile关键字具备两个特性，⼀是<strong>可见性</strong>，⼀是<strong>禁⽌指令重排</strong>。</p>
<h3 id="可见性-1"><a href="#可见性-1" class="headerlink" title="可见性"></a>可见性</h3><p>可见性：当⼀个变量被声明为volatile时，它会告诉编译器和CPU将该变量存储在主内存中，⽽不是线程的本地内存中。即每个线程读取的都是主内存中最新的值，避免了多线程并发下的数据不⼀致问题。</p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/03/11/93032_image-20240311204210678.png" alt="image-20240311204210678" style="zoom:50%;" /></p>
<h3 id="Volatile缓存可见性实现原理"><a href="#Volatile缓存可见性实现原理" class="headerlink" title="Volatile缓存可见性实现原理"></a>Volatile缓存可见性实现原理</h3><p>底层实现主要是通过<strong>汇编lock前缀指令</strong>，它会锁定这块内存区域的缓存（缓存行锁定）并回写到主内存<br>IA-32和Intel64架构软件开发者手册<strong>对lock指令的解释</strong>：<br><strong>1)会将当前处理器缓存行的数据立即写回到系统内存。</strong><br><strong>2)这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效(MESI协议)</strong><br><strong>3)提供内存屏障功能，使lock前后指令不能重排序</strong></p>
<h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><p>指令重排序：在不影响单线程程序执行结果的前提下，计算机为了最大限度的发挥机器性能，会对机器指令重排序优化。</p>
<p>重排序会遵循<code>as-if-serial</code>与<code>happens-before</code>原则</p>
<p><strong>as-if-serial</strong><br>as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。</p>
<p><strong>happens-before</strong></p>
<p>happens-before关系的定义如下： 1. 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。 2. <strong>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么JMM也允许这样的重排序。</strong></p>
<blockquote>
<p>as-if-serial语义保证单线程内重排序后的执行结果和程序代码本身应有的结果是一致的，happens-before关系保证正确同步的多线程程序的执行结果不被重排序改变。</p>
</blockquote>
<h3 id="DCL双重检测锁"><a href="#DCL双重检测锁" class="headerlink" title="DCL双重检测锁"></a>DCL双重检测锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>没有volatile会有单例半初始化</strong></p>
<p>对象的创建过程(new关键字),它简单的分为三个阶段:</p>
<p><strong>1.分配对象内存空间.</strong></p>
<p><strong>2.初始化对象.</strong></p>
<p><strong>3.设置对象指向内存空间.</strong></p>
<p>那么实际上第三步和第二步的关系是可以进行互换的,在JVM的优化中存在一种指令重排序的现象,为了加快JVM的运行速度,指令重排序会在不影响结果的情况下,对JVM的指令进行重新排序.</p>
<p>那么当出现指令重排序时,原本1,2,3的顺序则可能变为1,3,2.此时当代码运行到3时,另一个线程恰好在获取该单例,那么此时代码就会返回一个没有初始化完成的单例对象,这是非常危险的. </p>
<h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><ol>
<li>在每个volatile写操作的前面插入一个StoreStore屏障</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StoreStore屏障</span><br><span class="line">a=<span class="number">1</span>;<span class="comment">//volatile写，a为volatile变量</span></span><br><span class="line">StoreLoad屏障</span><br><span class="line">b=a;<span class="comment">//volatile读</span></span><br><span class="line">LoadLoad屏障</span><br><span class="line">LoadStore屏障</span><br></pre></td></tr></table></figure>
<h2 id="JMM内存模型"><a href="#JMM内存模型" class="headerlink" title="JMM内存模型"></a>JMM内存模型</h2><p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/03/11/14349_image-20240311203311356.png" alt="image-20240311203311356" style="zoom:50%;" /></p>
<h2 id="JMM数据原子操作"><a href="#JMM数据原子操作" class="headerlink" title="JMM数据原子操作"></a>JMM数据原子操作</h2><p>read(读取)：从主内存读取数据<br>load(载入)：将主内存读取到的数据写入工作内存<br>use(使用)：从工作内存读取数据来计算<br>assign(赋值)：将计算好的值重新赋值到工作内存中<br>store(存储)：将工作内存数据写入主内存<br>write(写入)：将store过去的变量值赋值给主内存中的变量<br>1ock(锁定)：将主内存变量加锁，标识为线程独占状态<br>unlock(解锁)：将主内存变量解锁，解锁后其他线程可以锁定该变量</p>
<h3 id="缓存一致性协议-MES"><a href="#缓存一致性协议-MES" class="headerlink" title="缓存一致性协议(MES)"></a>缓存一致性协议(MES)</h3><p>多个cpu从主内存读取同一个数据到各自的高速缓存，当其中某个cpu修改了缓存里的数据，该数据会马上同步回主内存，其它cpu通过总线嗅探机制可以感知到数据的变化从而将自己缓存里的数据失效</p>
<h3 id="缓存加锁"><a href="#缓存加锁" class="headerlink" title="缓存加锁"></a>缓存加锁</h3><p>缓存锁的核心机制是基于缓存一致性协议来实现的，一个处理器的缓存回写到内存会导致其他处理器的缓存无效，IA-32和lntel 64处理器使用MESI实现缓存一致性协议</p>
<h2 id="原⼦类"><a href="#原⼦类" class="headerlink" title="原⼦类"></a>原⼦类</h2><ol>
<li>不可分割</li>
<li>⼀个操作是不可中断的，即便是多线程的情况下也可以保证</li>
<li>java.util.concurrent.atomic</li>
<li>原⼦类的作⽤和锁类似，是为了保证并发情况下的线程安全。不过原⼦类相对于锁有⼀点的优势</li>
</ol>
<p><strong>粒度更细</strong>：<strong>原⼦变量可以把竞争范围缩⼩到变量级别</strong>，这是我们可以获得的最细的粒度的情况了，通常锁的粒度都要⼤于原⼦变量的粒度<br><strong>效率更⾼</strong>：通常，使⽤原⼦类的效率会⽐使⽤锁的效率更⾼，除了⾼度竞争的情况</p>
<h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><p>使用原子的方式更新基本类型</p>
<ul>
<li><code>AtomicInteger</code>：整型原子类</li>
<li><code>AtomicLong</code>：长整型原子类</li>
<li><code>AtomicBoolean</code>：布尔型原子类</li>
</ul>
<p><strong>数组类型</strong></p>
<p>使用原子的方式更新数组里的某个元素</p>
<ul>
<li><code>AtomicIntegerArray</code>：整型数组原子类</li>
<li><code>AtomicLongArray</code>：长整型数组原子类</li>
<li><code>AtomicReferenceArray</code>：引用类型数组原子类</li>
</ul>
<p><strong>引用类型</strong></p>
<ul>
<li><code>AtomicReference</code>：引用类型原子类</li>
<li><code>AtomicMarkableReference</code>：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来。</li>
<li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">atomicStock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">10000</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StockRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (atomicStock.get() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        atomicStock.decrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AtomicInteger-类常⽤⽅法"><a href="#AtomicInteger-类常⽤⽅法" class="headerlink" title="AtomicInteger 类常⽤⽅法"></a>AtomicInteger 类常⽤⽅法</h2><ol>
<li>public final int get() //获取当前的值</li>
<li>public final int getAndSet(int newValue) //获取当前的值，并设置新的值</li>
<li>public final int getAndIncrement() //获取当前的值，并⾃增</li>
<li>public final int getAndDecrement() //获取当前的值，并⾃减</li>
<li>public final int getAndAdd(int delta) //获取当前的值，并加上预期的值</li>
<li>boolean compareAndSet(int expect, int update) //如果输⼊的数值等于预期值，则以原⼦⽅式将该值更新为输⼊值（update）</li>
</ol>
<p>在Java中，<code>final</code> 关键字可以用于不同的上下文中，其中一个是用于修饰方法。在方法声明中使用 <code>final</code> 关键字表示该方法不能被子类重写（override）。</p>
<p>如果在Java中使用 <code>final</code> 关键字修饰变量，这意味着这个变量的值只能被赋值一次。一旦赋值后，它的值将不能被修改。</p>
<h2 id="AtomicIntegerArray类常⽤⽅法"><a href="#AtomicIntegerArray类常⽤⽅法" class="headerlink" title="AtomicIntegerArray类常⽤⽅法"></a>AtomicIntegerArray类常⽤⽅法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">aia</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] value = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">AtomicIntegerArray</span> <span class="variable">aia</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(value);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;ai.getAndSet(0, 3)&quot;</span>);</span><br><span class="line">    aia.getAndAdd(<span class="number">0</span>, <span class="number">3</span>);<span class="comment">//将索引0处的值加3</span></span><br><span class="line">    System.out.println(<span class="string">&quot;aia.get(0) = &quot;</span> + aia.get(<span class="number">0</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;value[0] = &quot;</span> + value[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    aia.compareAndSet(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;aia.compareAndSet(1, 2, 5)&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;aia.get(1) = &quot;</span> + aia.get(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AtomicReference类常⽤⽅法"><a href="#AtomicReference类常⽤⽅法" class="headerlink" title="AtomicReference类常⽤⽅法"></a>AtomicReference类常⽤⽅法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">ar</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;xushu&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        AtomicReference&lt;User&gt; atomicUserRef = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;User&gt;(user);</span><br><span class="line">        <span class="comment">//atomicUserRef.set(user);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;atomicUserRef.get() = &quot;</span> + atomicUserRef.get().toString());</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">updateUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhuge&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        atomicUserRef.compareAndSet(user, updateUser);</span><br><span class="line">        System.out.println(<span class="string">&quot;atomicUserRef.compareAndSet(user, updateUser);&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;atomicUserRef.get() = &quot;</span> + atomicUserRef.get().toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="AtomicIntegerFieldUpdate类常⽤⽅法"><a href="#AtomicIntegerFieldUpdate类常⽤⽅法" class="headerlink" title="AtomicIntegerFieldUpdate类常⽤⽅法"></a>AtomicIntegerFieldUpdate类常⽤⽅法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">au</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建原子更新器,并设置需要更新的对象类和对象的属性</span></span><br><span class="line">        AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.</span><br><span class="line">                newUpdater(User.class, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置xushu的年龄是10岁</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">xushu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;xushu&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 徐庶长了一岁,但是仍然会输出旧的年龄</span></span><br><span class="line">        System.out.println(a.getAndIncrement(xushu));</span><br><span class="line">        <span class="comment">// 输出xushu现在的年龄</span></span><br><span class="line">        System.out.println(a.get(xushu));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Adder累加器"><a href="#Adder累加器" class="headerlink" title="Adder累加器"></a>Adder累加器</h2><h3 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h3><p>LongAdder适合的场景是统计求和计数的场景，⽽且LongAdder基本只提供了add⽅法，⽽AtomicLong还具有cas⽅法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无参构造函数  从0开始</span></span><br><span class="line"><span class="type">LongAdder</span> <span class="variable">longAdder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();</span><br><span class="line"></span><br><span class="line">longAdder.increment();</span><br><span class="line">longAdder.increment();</span><br><span class="line">System.out.println(<span class="string">&quot;longAdder = &quot;</span> + longAdder.longValue());</span><br></pre></td></tr></table></figure>
<h2 id="LongAccumulator"><a href="#LongAccumulator" class="headerlink" title="LongAccumulator"></a>LongAccumulator</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LongAccumulator</span> <span class="variable">longAccumulator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAccumulator</span>((x, y) -&gt; x + y, <span class="number">1</span>);</span><br><span class="line">longAccumulator.accumulate(<span class="number">3</span>);</span><br><span class="line">longAccumulator.accumulate(<span class="number">3</span>);</span><br><span class="line">longAccumulator.accumulate(<span class="number">3</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;longAccumulator = &quot;</span> + longAccumulator.get());</span><br></pre></td></tr></table></figure>
<p>适⽤于需要⼤量计算，并且需要并⾏计算的场景，如果不需要并⾏计算，可⽤for循环解决问题，⽤了Accumulator累加器可利⽤多核同时计算，提供效率</p>
<p>计算的顺序不能成为瓶颈，线程1可能在线程5之后运⾏，也可能在之前运⾏，不影响最终结果</p>
<h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><p><strong>悲观锁</strong>：认为当前线程使用数据的时候⼀定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。</p>
<blockquote>
<p>synchronized关键字和Lock的实现类都是悲观锁，适合写操作多的场景，先加锁可以保证写操作时数据正确。</p>
</blockquote>
<p><strong>乐观锁</strong>：乐观锁认为当前线程使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。</p>
<blockquote>
<p>乐观锁在Java中是通过使⽤⽆锁编程来实现，最常采⽤的是CAS算法，Java原⼦类中的递增操作就通过CAS⾃旋实现的，适合读操作多的场景，不加锁的特点能够使其读操作的性能⼤幅提升。</p>
</blockquote>
<p>乐观锁直接去操作同步资源，是⼀种⽆锁算法，得之我幸不得我命，重试。</p>
<h2 id="CAS-Compare-and-Swap"><a href="#CAS-Compare-and-Swap" class="headerlink" title="CAS(Compare-and-Swap)"></a>CAS(Compare-and-Swap)</h2><p>即比较并替换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StockRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="type">int</span> oldValue;</span><br><span class="line">           <span class="type">int</span> newValue;</span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">               oldValue = stock.get();</span><br><span class="line">               newValue = oldValue -<span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">while</span> (!stock.compareAndSet(oldValue, newValue));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>循环时间⻓开销很⼤<code>do&#123;...&#125;while</code></li>
<li>引出来ABA问题</li>
</ol>
<h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>当第⼀个线程执⾏CAS（V，E，U）操作。在获取到当前变量V，准备修改为新值U前，另外两个线程已连续修改了两次变量V的值，使得该值⼜恢复为旧值，这样的话，我们就⽆法正确判断这个变量是否已被修改过</p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/03/20/93282_image-20240320200400885.png" alt="image-20240320200400885" style="zoom: 33%;" /></p>
<h3 id="解决方法AtomicStampedReference"><a href="#解决方法AtomicStampedReference" class="headerlink" title="解决方法AtomicStampedReference"></a>解决方法AtomicStampedReference</h3><p>在调用compareAndSet方法时会设置标记stamp，通过查看标记判断是否被修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicStampedReference&lt;Integer&gt; balance = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>(<span class="number">1000</span>, <span class="number">0</span>);</span><br><span class="line"> <span class="comment">// 财务发3000工资</span></span><br><span class="line">balance.compareAndSet(balance.getReference(), <span class="number">4000</span>, balance.getStamp(), balance.getStamp() + <span class="number">1</span>);</span><br><span class="line"> <span class="comment">// 老婆取3000工资</span></span><br><span class="line">balance.compareAndSet(balance.getReference(), <span class="number">1000</span>, balance.getStamp(), balance.getStamp() + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (balance.getReference() &gt; <span class="number">3000</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;张三美滋滋&quot;</span> + balance.getReference());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (balance.getStamp() == <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;张三找财务麻烦:&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;张三找老婆麻烦:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自旋锁-spinlock"><a href="#自旋锁-spinlock" class="headerlink" title="自旋锁(spinlock)"></a>自旋锁(spinlock)</h2><p>是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。</p>
<p>属于乐观锁，实现基础是CAS算法机制</p>
<h2 id="wait-sleep区别"><a href="#wait-sleep区别" class="headerlink" title="wait/sleep区别"></a>wait/sleep区别</h2><p>1、所属类不同：sleep是线程中的方法，但是wait是Object中的方法。<br>2、语法不同：sleep方法不依赖于同步器synchronized,但是wait需要依赖synchronized关键字。<br>3、参数不同：sleep必须设置参数时间，wait可以不设置时间，不设置将一直休眠。<br>4、释放锁资源不同：sleep方法不会释放Iock,<strong>但是wait会释放</strong>，而且会加入到等待队列中。</p>
<p>5、唤醒方式不同：sleep:不需要被唤醒（休眠之后退出阻塞），但是<strong>wait需要</strong>(不指定时间需要被别人中断)。<br>6、线程进入状态不同：调用sleep方法线程会进入<code>TIMED_WAITING</code>有时限等待状态，而调用无参数的wait方法，线程会进入<code>WAITING</code>无时限等待状态。</p>
<h2 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hdb.juclearn.javalock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C4_SharedQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列最大长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">queenSize</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">private</span> ArrayBlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(queenSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Producter</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 保证生产者在整个过程中是线程安全的</span></span><br><span class="line">            <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line"><span class="comment">// 1、 判断当前队列长度是否小于最大长度</span></span><br><span class="line">                <span class="keyword">if</span> (queue.size() &lt; queenSize) &#123;</span><br><span class="line">                    <span class="comment">// 2、如果小于 生产者就可以生产消息了</span></span><br><span class="line">                    <span class="comment">// 2.1 往队列queue添加一条信息</span></span><br><span class="line">                    queue.add(random.nextInt());</span><br><span class="line">                    System.out.println(<span class="string">&quot;生产者往队列中加入消息，队列当前长度：&quot;</span> + queue.size());</span><br><span class="line">                    <span class="comment">// 2.2 唤醒消费，有活了</span></span><br><span class="line">                    queue.notify();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 3. 如果大于 生产者停止工作， 稍微歇一歇</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        queue.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        queue.notify();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 消费者需要重复的工作</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 保证整个消费的过程是线程安全</span></span><br><span class="line">                <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                    <span class="comment">// 如果队列为空， 消费者睡眠</span></span><br><span class="line">                    <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;当前队列为空...&quot;</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            queue.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            <span class="comment">// 一旦出现异常，手动唤醒</span></span><br><span class="line">                            queue.notify();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 队列不为空， 消费者需要进行消费</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 消费头部的信息</span></span><br><span class="line">                        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                        System.out.println(<span class="string">&quot;消费者从队列中消费了信息:&quot;</span> + value + <span class="string">&quot;，队列当前长度：&quot;</span> + queue.size());</span><br><span class="line">                        <span class="comment">// 唤醒生产者， 可以继续工作了</span></span><br><span class="line">                        queue.notify();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 模拟业务处理</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">C4_SharedQueue</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C4_SharedQueue</span>();</span><br><span class="line">        <span class="comment">// 消费者持续运行</span></span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> test.<span class="keyword">new</span> <span class="title class_">Consumer</span>();</span><br><span class="line">        consumer.start();</span><br><span class="line">        <span class="comment">// 生产10条消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">Producter</span> <span class="variable">producter</span> <span class="operator">=</span> test.<span class="keyword">new</span> <span class="title class_">Producter</span>();</span><br><span class="line">            producter.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p><strong>其实在JDK 1.6之前</strong>，Java内置锁还是⼀个重量级锁，是⼀个效率⽐较低下的锁， 会由jvm⽤户态切换到操作系统的管程来实现互斥。</p>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>管程是指管理共享变量以及对共享变量操作的过程，让它们⽀持并发。翻译成Java领域的语⾔，就是<strong>管理类的状态变量，让这个类是线程安全的</strong> 。</p>
<p>synchronized关键字和wait()、notify()、notifyAll()这三个⽅法是Java中实现管程技术的组成部分。</p>
<p>Monitor有两⼤作⽤：同步和互斥</p>
<p>wait/notify基于monitor做的</p>
<p>synchronized关联了monitor</p>
<h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><p>在JDK 1.6之后，JVM为了提⾼锁的获取与释放效率，对synchronized的实现进⾏了优化，引⼊了偏向锁<br>和轻量级锁，从此以后Java内置锁的状态就有了4种（⽆锁、偏向锁、轻量级锁和重量级锁）</p>
<h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="无锁状态"><a href="#无锁状态" class="headerlink" title="无锁状态"></a>无锁状态</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> &#123;</span><br><span class="line">        Integer age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="type">T</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OFFSET  SIZE                TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4                     (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br></pre></td></tr></table></figure>
<p>锁对象刚创建，没有任何线程竞争，对象处于⽆锁状态+不可偏向状态</p>
<p><code>00000001</code>代表无锁as</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>jdk中偏向锁存在延迟4秒启动，也就是说在jvm启动后4秒后创建的对象才会开启偏向锁</p>
<p>创建的对象状态为 对象处于⽆锁状态+可偏向状态</p>
<p>这个锁将自己偏向了当前线程，心里默默地藏着线程id， 在这里，我们就引入了“偏向锁”的概念。</p>
<p><code>101</code></p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>当两个或以上线程交替获取锁，<strong>但并没有在对象上并发的获取锁时</strong>，偏向锁升级为轻量级锁。在此阶段，线程采取CAS的⾃旋⽅式尝试获取锁，避免阻塞线程造成的cpu在⽤户态和内核态间转换的消耗主线程⾸先对user对象加锁，⾸次加锁为<code>000</code>偏向锁</p>
<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>两个或以上线程并发的在同⼀个对象上进⾏同步时，为了避免⽆⽤⾃旋消耗cpu，轻量级锁会升级成重量级锁。这时markword中的指针指向的是monitor对象（也被称为管程或监视器锁）的起始地址</p>
<p><code>10</code></p>
<h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>是指在同⼀个线程在外层⽅法获取锁的时候，再进⼊该线程的内层⽅法会⾃动获取锁（前提，锁对象得是同⼀个对象），不会因为之前已经获取过还没释放⽽阻塞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">objectLockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           relock();</span><br><span class="line">       &#125;, <span class="string">&quot;a&quot;</span>).start();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">relock</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">synchronized</span> (objectLockA) &#123;</span><br><span class="line">           <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               i++;</span><br><span class="line">               System.out.println(i + <span class="string">&quot;调用&quot;</span>);</span><br><span class="line">               relock();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock是Lock的默认实现</p>
<ol>
<li>可重⼊锁：可重⼊锁是指同⼀个线程可以多次获得同⼀把锁；ReentrantLock和关键字Synchronized都是可重⼊锁</li>
<li>可中断锁：可中断锁时⼦线程在获取锁的过程中，是否可以相应线程中断操作。synchronized是不可中断的，ReentrantLock是可中断的</li>
<li>公平锁和⾮公平锁：公平锁是指多个线程尝试获取同⼀把锁的时候，获取锁的顺序按照线程到达的先后顺序获取，⽽不是随机插队的⽅式获取。synchronized是⾮公平锁<strong>，⽽ReentrantLock是两种都可以实现，不过默认是⾮公平锁</strong></li>
</ol>
<h3 id="synchronized的局限性"><a href="#synchronized的局限性" class="headerlink" title="synchronized的局限性"></a>synchronized的局限性</h3><ul>
<li>当线程尝试获取锁的时候，如果获取不到锁会⼀直阻塞，这个阻塞的过程，⽤户⽆法控制</li>
<li>如果获取锁的线程进⼊休眠或者阻塞，<strong>除⾮当前线程异常，否则其他线程尝试获取锁必须⼀直等待</strong></li>
</ul>
<h3 id="ReentrantLock使用"><a href="#ReentrantLock使用" class="headerlink" title="ReentrantLock使用"></a>ReentrantLock使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C6_ReentrantLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">stock</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StockRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                stock--;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (lock.isHeldByCurrentThread()) &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="type">StockRunnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StockRunnable</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">                threadPool.execute(task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdownNow();</span><br><span class="line">            threadPool.awaitTermination(<span class="number">1000</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;剩余库存：&quot;</span> + stock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上⾯代码需要注意lock.unlock()⼀定要放在finally中，否则，若程序出现了异常，锁没有释放，那么其他线程就再也没有机会获取这个锁了。</p>
<h3 id="trylock"><a href="#trylock" class="headerlink" title="trylock"></a>trylock</h3><p>获取锁限时等待的⽅法<code>tryLock（）</code>，可以选择传⼊时间参数，表示等待指定的时间，⽆参则表示⽴即返回锁申请的结果：true表示获取锁成功，false表示获取锁失败。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> (lock1.tryLock(<span class="number">2</span>, TimeUnit.SECONDS)) &#123;  <span class="comment">// lock()</span></span><br><span class="line">    System.out.println(System.currentTimeMillis() + <span class="string">&quot;:&quot;</span> + <span class="built_in">this</span>.getName() + <span class="string">&quot;获取到了锁!&quot;</span>);</span><br><span class="line">    <span class="comment">//获取到锁之后，休眠5秒</span></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lockInterruptibly"><a href="#lockInterruptibly" class="headerlink" title="lockInterruptibly()"></a>lockInterruptibly()</h3><p>在lock的基础上可以加上了中断机制，如果在外部调用<code>interrupt</code>，会中断等待。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.lockInterruptibly();</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 2 获取了锁&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程 2异常&quot;</span>);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (lock.isHeldByCurrentThread()) &#123;</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">...</span><br><span class="line">thread2.interrupt(); <span class="comment">// interrupt thread2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>线程调⽤interrupt()之后，线程的中断标志会被置为true</li>
<li>触发InterruptedException异常之后，线程的中断标志会被清空，即置为false</li>
</ul>
<h2 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁/非公平锁"></a>公平锁/非公平锁</h2><p>公平锁和⾮公平锁：公平锁是指多个线程尝试获取同⼀把锁的时候，获取锁的顺序按照线程到达的先后顺序获取，⽽不是随机插队的⽅式获取。synchronized是⾮公平锁<strong>，⽽ReentrantLock是两种都可以实现，不过默认是⾮公平锁</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认非公平锁，  true  公平锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">fairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<h3 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h3><p><strong>1、 为什么会有公平锁/⾮公平锁的设计为什么默认⾮公平？</strong></p>
<blockquote>
<p>恢复挂起的线程到真正锁的获取还是有时间差的，从开发⼈员来看这个时间微乎其微，但是从CPU的⻆度来看，这个时间差存在的还是很明显的。<strong>所以⾮公平锁能更充分的利⽤CPU的时间⽚，尽量减少CPU空闲状态时间。</strong></p>
<p><strong>使⽤多线程很重要的考量点是线程切换的开销</strong>，当采⽤⾮公平锁时，当1个线程请求锁获取同步状态，然后释放同步状态，因为不需要考虑是否还有前驱节点，所以刚释放锁的线程在此刻再次获取同步状态的概率就变得⾮常⼤，所以就减少了线程的开销。</p>
</blockquote>
<p><strong>2、 使⽤公平锁会有什么问题</strong></p>
<blockquote>
<p>公平锁保证了排队的公平性，⾮公平锁霸⽓的忽视这个规则，所以就有可能导致排队的⻓时间在排队，也没有机会获取到锁，这就是传说中的“锁饥饿”</p>
</blockquote>
<p><strong>3、 什么时候⽤公平？什么时候⽤⾮公平</strong></p>
<blockquote>
<p>如果为了更⾼的吞吐量，很显然⾮公平锁是⽐较合适的，因为节省很多线程切换时间，吞吐量⾃然就上去了；否则那就⽤公平锁，⼤家公平使⽤。</p>
</blockquote>
<h2 id="共享锁和排它锁"><a href="#共享锁和排它锁" class="headerlink" title="共享锁和排它锁"></a>共享锁和排它锁</h2><ul>
<li>排它锁⼜称独占锁，获得了以后既能读⼜能写，其他没有获得锁的线程不能读也不能写，典型的synchronized就是排它锁</li>
<li>共享锁⼜称读锁，获得了共享锁以后<strong>可以查看但⽆法修改和删除数据</strong>，其他线程也能获得共享锁，也可以查看但不能修改和删除数据</li>
</ul>
<blockquote>
<p>在没有读写锁之前，我们虽然保证了线程安全，但是也浪费了⼀定的资源，因为多个读操作同时进⾏并没有线程安全问题</p>
</blockquote>
<h3 id="读写锁的规则"><a href="#读写锁的规则" class="headerlink" title="读写锁的规则"></a>读写锁的规则</h3><ol>
<li>多个线程只申请读锁，都能申请到</li>
<li><strong>如果有⼀个线程已经占⽤了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会⼀直等待读锁释放该锁</strong></li>
<li>如果有⼀个线程已经占⽤写锁，则其他线程申请写锁或读锁都要等待它释放</li>
</ol>
<blockquote>
<p>要么多读要么⼀写</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">readLock</span> <span class="operator">=</span> readWriteLock.readLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">writeLock</span> <span class="operator">=</span> readWriteLock.writeLock();、</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">readLock.lock();</span><br><span class="line">readLock.unlock();</span><br></pre></td></tr></table></figure>
<h2 id="synchronized与Lock的区别"><a href="#synchronized与Lock的区别" class="headerlink" title="synchronized与Lock的区别"></a>synchronized与Lock的区别</h2><ul>
<li>⾸先synchronized是java内置关键字，在jvm层⾯，Lock是个java类；</li>
<li>synchronized⽆法判断是否获取锁的状态，Lock可以判断是否获取到锁；</li>
<li>synchronized会⾃动释放锁（a线程执⾏完同步代码会释放锁；b线程执⾏过程中发⽣异常会释放锁），Lock需在finally中⼿⼯释放锁（unlock（）⽅法释放锁），否则容易造成线程死锁；</li>
<li>⽤synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会⼀直等待下去，⽽Lock锁就不⼀定会等待下去，如果尝试获取不到锁，线程可以不⽤⼀直等待就结束了；</li>
<li>synchronized的锁可重⼊、不可中断、⾮公平，⽽Lock锁可重⼊、可中断、可公平（两者皆可）</li>
</ul>
]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>JUC</tag>
        <tag>thread-safety</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题-1</title>
    <url>/2024/03/31/daliyQustion/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p><strong>本节包括：</strong></p>
<ul>
<li>每日一题1</li>
</ul>
<span id="more"></span>
<h2 id="2129-将标题首字母大写"><a href="#2129-将标题首字母大写" class="headerlink" title="2129.将标题首字母大写"></a>2129.将标题首字母大写</h2><p>给你一个字符串 <code>title</code> ，它由单个空格连接一个或多个单词组成，每个单词都只包含英文字母。请你按以下规则将每个单词的首字母 <strong>大写</strong> ：</p>
<ul>
<li>如果单词的长度为 <code>1</code> 或者 <code>2</code> ，所有字母变成小写。</li>
<li>否则，将单词首字母大写，剩余字母变成小写。</li>
</ul>
<p>请你返回 <strong>大写后</strong> 的 <code>title</code> 。</p>
<h3 id="思路-初步实现"><a href="#思路-初步实现" class="headerlink" title="思路-初步实现"></a>思路-初步实现</h3><p>定义左右指针：</p>
<ol>
<li>原来字符串加一个空格，保证处理逻辑一致</li>
<li>right -left &lt;=2，所有字母小写</li>
<li>right-left&gt;2,首字母大写</li>
<li>处理一个单词后，向后移动</li>
<li>去掉字符串的末尾空格</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">capitalizeTitle</span><span class="params">(String title)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(title);</span><br><span class="line">        stringBuilder.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> stringBuilder.length();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (right &lt; length) &#123;</span><br><span class="line">            <span class="keyword">while</span> (stringBuilder.charAt(right) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//此时right处为空格</span></span><br><span class="line">            <span class="keyword">if</span> (right - left &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    res.append(Character.toLowerCase(stringBuilder.charAt(left)));</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//首字母大写</span></span><br><span class="line">                res.append(Character.toUpperCase(stringBuilder.charAt(left)));</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    res.append(Character.toLowerCase(stringBuilder.charAt(left)));</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            res.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理下一个单词</span></span><br><span class="line">            right = right + <span class="number">1</span>;</span><br><span class="line">            left = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString().trim();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">capitalizeTitle</span><span class="params">(String title)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(title);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> title.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (r &lt; n &amp;&amp; sb.charAt(r) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                ++r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*先确定单个单词的右上限 */</span></span><br><span class="line">            <span class="keyword">if</span> (r - l &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                sb.setCharAt(l, Character.toUpperCase(sb.charAt(l)));</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                sb.setCharAt(l, Character.toLowerCase(sb.charAt(l)));</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">            l = r + <span class="number">1</span>;</span><br><span class="line">            ++r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="1261-在受污染的二叉树中查找元素"><a href="#1261-在受污染的二叉树中查找元素" class="headerlink" title="1261.在受污染的二叉树中查找元素"></a>1261.在受污染的二叉树中查找元素</h2><p>给出一个满足下述规则的二叉树：</p>
<ol>
<li><code>root.val == 0</code></li>
<li>如果 <code>treeNode.val == x</code> 且 <code>treeNode.left != null</code>，那么 <code>treeNode.left.val == 2 * x + 1</code></li>
<li>如果 <code>treeNode.val == x</code> 且 <code>treeNode.right != null</code>，那么 <code>treeNode.right.val == 2 * x + 2</code></li>
</ol>
<p>现在这个二叉树受到「污染」，所有的 <code>treeNode.val</code> 都变成了 <code>-1</code>。</p>
<p>请你先还原二叉树，然后实现 <code>FindElements</code> 类：</p>
<ul>
<li><code>FindElements(TreeNode* root)</code> 用受污染的二叉树初始化对象，你需要先把它还原。</li>
<li><code>bool find(int target)</code> 判断目标值 <code>target</code> 是否存在于还原后的二叉树中并返回结果。</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>树的创建过程省略</p>
<ul>
<li>find函数的实现要注意查看数的还原过程，左子树一定是奇数，右子树一定是偶数</li>
<li>假设target存在，从树的底部向上查找，并用栈记录左右子树的查找方向一直到根节点</li>
<li>从根节点开始，取出栈中的值，依次向下遍历，如果遍历过程中栈指示的方向为空，那么返回false；否则返回true</li>
</ul>
<p><strong>坑：由于多次查询，上一次查询时可能栈没有清空，需要先手动清空栈，再往栈中插入方向指示数值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindElements</span> &#123;</span><br><span class="line">    TreeNode root;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FindElements</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> root.val = <span class="number">0</span>;</span><br><span class="line">        buildTree(root);</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        stack.clear();</span><br><span class="line">        findPath(target);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.pop() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            root.left.val = root.val * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            buildTree(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            root.right.val = root.val * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">            buildTree(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findPath</span><span class="params">(<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (target % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            target = (target - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">            stack.push(<span class="number">1</span>);<span class="comment">//1代表右子树</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target = (target - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            stack.push(<span class="number">0</span>);<span class="comment">//0代表左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        findPath(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2864-最大二进制奇数"><a href="#2864-最大二进制奇数" class="headerlink" title="2864.最大二进制奇数"></a>2864.最大二进制奇数</h2><p>给你一个二进制字符串s,其中至少包含一个’1’。<br>你必须按某种方式重新排列字符串中的位，使得到的二进制数字是可以由该组合生成的最大二进制奇数。<br>以字符串形式，表示并返回可以由给定组合生成的最大二进制奇数。<br>注意返回的结果字符串可以含前导零。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;010&quot;</span><br><span class="line">输出：&quot;001&quot;</span><br><span class="line">解释：因为字符串 s 中仅有一个 &#x27;1&#x27; ，其必须出现在最后一位上。所以答案是 &quot;001&quot; 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;0101&quot;</span><br><span class="line">输出：&quot;1001&quot;</span><br><span class="line">解释：其中一个 &#x27;1&#x27; 必须出现在最后一位上。而由剩下的数字可以生产的最大数字是 &quot;100&quot; 。所以答案是 &quot;1001&quot; 。</span><br></pre></td></tr></table></figure>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>记录0和1的次数，字符串末尾需要一个1，最前面用1填充，中间用0填充</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaximumOddBinaryNumber</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">maximumOddBinaryNumber</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];<span class="comment">//记录0和1的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                counts[<span class="number">0</span>]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                counts[<span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (counts[<span class="number">1</span>] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            res.append(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">            counts[<span class="number">1</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (counts[<span class="number">0</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res.append(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            counts[<span class="number">0</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        res.append(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>创建s.length()的char数组，只记录1的次数cnt，0的次数等于s.length()-cnt</p>
<h2 id="2789-合并后数组中的最大元素"><a href="#2789-合并后数组中的最大元素" class="headerlink" title="2789.合并后数组中的最大元素"></a>2789.合并后数组中的最大元素</h2><p>给你一个下标从 <strong>0</strong> 开始、由正整数组成的数组 <code>nums</code> 。</p>
<p>你可以在数组上执行下述操作 <strong>任意</strong> 次：</p>
<ul>
<li>选中一个同时满足 <code>0 &lt;= i &lt; nums.length - 1</code> 和 <code>nums[i] &lt;= nums[i + 1]</code> 的整数 <code>i</code> 。将元素 <code>nums[i + 1]</code> 替换为 <code>nums[i] + nums[i + 1]</code> ，并从数组中删除元素 <code>nums[i]</code> 。</li>
</ul>
<p>返回你可以从最终数组中获得的 <strong>最大</strong> 元素的值。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,3,7,9,3]</span><br><span class="line">输出：21</span><br><span class="line">解释：我们可以在数组上执行下述操作：</span><br><span class="line">- 选中 i = 0 ，得到数组 nums = [5,7,9,3] 。</span><br><span class="line">- 选中 i = 1 ，得到数组 nums = [5,16,3] 。</span><br><span class="line">- 选中 i = 0 ，得到数组 nums = [21,3] 。</span><br><span class="line">最终数组中的最大元素是 21 。可以证明我们无法获得更大的元素。</span><br></pre></td></tr></table></figure>
<h3 id="思路-贪心算法-倒叙遍历"><a href="#思路-贪心算法-倒叙遍历" class="headerlink" title="思路 贪心算法 倒叙遍历"></a>思路 贪心算法 倒叙遍历</h3><p>为了使数组的最大值最大，<strong>我们可以贪心地做尽可能多的合并</strong>，直到整个数组都不能进行合并。</p>
<p>合并的要求是后面的数字不小于前面的数字，我们就尽可能先合并靠后的数字，使其尽快能大，才能够合并前面的数字。</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maxArrayValue</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> nums[nums.length - <span class="number">1</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">           <span class="keyword">if</span> (nums[i] &lt;= sum) &#123;<span class="comment">//可以合并</span></span><br><span class="line">               sum += nums[i];</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               sum = nums[i];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sum;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="2312-卖木头块"><a href="#2312-卖木头块" class="headerlink" title="2312.卖木头块"></a>2312.卖木头块</h2><p>给你两个整数 <code>m</code> 和 <code>n</code> ，分别表示一块矩形木块的高和宽。同时给你一个二维整数数组 <code>prices</code> ，其中 <code>prices[i] = [hi, wi, pricei]</code> 表示你可以以 <code>pricei</code> 元的价格卖一块高为 <code>hi</code> 宽为 <code>wi</code> 的矩形木块。</p>
<p>每一次操作中，你必须按下述方式之一执行切割操作，以得到两块更小的矩形木块：</p>
<ul>
<li>沿垂直方向按高度 <strong>完全</strong> 切割木块，或</li>
<li>沿水平方向按宽度 <strong>完全</strong> 切割木块</li>
</ul>
<p>在将一块木块切成若干小木块后，你可以根据 <code>prices</code> 卖木块。你可以卖多块同样尺寸的木块。你不需要将所有小木块都卖出去。你 <strong>不能</strong> 旋转切好后木块的高和宽。</p>
<p>请你返回切割一块大小为 <code>m x n</code> 的木块后，能得到的 <strong>最多</strong> 钱数。</p>
<p>注意你可以切割木块任意次。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 3, n = 5, prices = [[1,4,2],[2,2,7],[2,1,3]]</span><br><span class="line">输出：19</span><br><span class="line">解释：上图展示了一个可行的方案。包括：</span><br><span class="line">- 2 块 2 x 2 的小木块，售出 2 * 7 = 14 元。</span><br><span class="line">- 1 块 2 x 1 的小木块，售出 1 * 3 = 3 元。</span><br><span class="line">- 1 块 1 x 4 的小木块，售出 1 * 2 = 2 元。</span><br><span class="line">总共售出 14 + 3 + 2 = 19 元。</span><br><span class="line">19 元是最多能得到的钱数。</span><br></pre></td></tr></table></figure>
<h3 id="思路-动态规划"><a href="#思路-动态规划" class="headerlink" title="思路-动态规划"></a>思路-动态规划</h3><p><strong>状态转移方程</strong></p>
<p>如果x&gt;1,那么我们可以沿水平方向将木块切成两部分，它们的高分别是i(1≤i&lt;x)和x-i,宽均为y。因此我们可以得到状态转移方程：</p>
<script type="math/tex; mode=display">
f ( x , y ) = \max _ { 1 \leq i < x } \left\{ f ( i , y ) + f ( x - i , y ) \right\}</script><p>如果y&gt;1，那么我们可以沿垂直方向将木块切成两部分，它们的宽分别是j(1≤j&lt;y)和y-j了，高均为x。因此我们可以得到状态转移方程：</p>
<script type="math/tex; mode=display">
f ( x , y ) = \max _ { 1 \leq j < y } \left\{ f ( x , j ) + f ( x , y - j ) \right\}</script><p><strong>存储键值</strong></p>
<p>通过将 x 左移 16 位（相当于 x * 2^16）然后对其与 y 进行按位异或操作来生成哈希值。</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellingWood</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sellingWood</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span>[][] prices)</span> &#123;</span><br><span class="line">        Map&lt;Long, Integer&gt; value = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过hi和wi映射pricei</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] price : prices) &#123;</span><br><span class="line"></span><br><span class="line">            value.put(pairHash(price[<span class="number">0</span>], price[<span class="number">1</span>]), price[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span>[][] memo = <span class="keyword">new</span> <span class="title class_">long</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span>[] row : memo) &#123;</span><br><span class="line">            Arrays.fill(row, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(m, n, value, memo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, Map&lt;Long, Integer&gt; value, <span class="type">long</span>[][] memo)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[x][y] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[x][y];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">key</span> <span class="operator">=</span> pairHash(x, y);</span><br><span class="line">        <span class="type">long</span> <span class="variable">ret</span> <span class="operator">=</span> value.getOrDefault(key, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; x; i++) &#123;</span><br><span class="line">                ret = Math.max(ret, dfs(i, y, value, memo) + dfs(x - i, y, value, memo));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (y &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; y; j++) &#123;</span><br><span class="line">                ret = Math.max(ret, dfs(x, j, value, memo) + dfs(x, y - j, value, memo));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[x][y] = ret;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">pairHash</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">long</span>) x &lt;&lt; <span class="number">16</span> ^ y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span>[][] prices = &#123;&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">7</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line">        <span class="type">SellingWood</span> <span class="variable">sellingWood</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellingWood</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">price</span> <span class="operator">=</span> sellingWood.sellingWood(m, n, prices);</span><br><span class="line">        System.out.println(price);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h3><p>动态转移方程矩阵中存在重复运算i和x-i，可以砍半优化，</p>
<p>可以直接通过在状态转移矩阵中存储初始元素</p>
<h3 id="优化代码"><a href="#优化代码" class="headerlink" title="优化代码"></a>优化代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sellingWood</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span>[][] prices)</span> &#123;</span><br><span class="line">        <span class="type">long</span>[][] memo = <span class="keyword">new</span> <span class="title class_">long</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] price : prices) &#123;</span><br><span class="line">            memo[price[<span class="number">0</span>]][price[<span class="number">1</span>]] = price[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt;= m; x++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>; y &lt;= n; y++) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">max</span> <span class="operator">=</span> memo[x][y];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= (x &gt;&gt; <span class="number">1</span>); i++) &#123;</span><br><span class="line">                    max = Math.max(max, memo[i][y] + memo[x - i][y]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= (y &gt;&gt; <span class="number">1</span>); i++) &#123;</span><br><span class="line">                    max = Math.max(max, memo[x][i] + memo[x][y - i]);</span><br><span class="line">                &#125;</span><br><span class="line">                memo[x][y] = max;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="310-最小高度树"><a href="#310-最小高度树" class="headerlink" title="310.最小高度树"></a>310.最小高度树</h2><p>树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。</p>
<p>给你一棵包含 <code>n</code> 个节点的树，标记为 <code>0</code> 到 <code>n - 1</code> 。给定数字 <code>n</code> 和一个有 <code>n - 1</code> 条无向边的 <code>edges</code> 列表（每一个边都是一对标签），其中 <code>edges[i] = [ai, bi]</code> 表示树中节点 <code>ai</code> 和 <code>bi</code> 之间存在一条无向边。</p>
<p>可选择树中任何一个节点作为根。当选择节点 <code>x</code> 作为根节点时，设结果树的高度为 <code>h</code> 。在所有可能的树中，具有最小高度的树（即，<code>min(h)</code>）被称为 <strong>最小高度树</strong> 。</p>
<p>请你找到所有的 <strong>最小高度树</strong> 并按 <strong>任意顺序</strong> 返回它们的根节点标签列表。</p>
<p>树的 <strong>高度</strong> 是指根节点和叶子节点之间最长向下路径上边的数量。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul>
<li>首先证明树的高度一定为<script type="math/tex">m i n h e i g h t = \left[ \frac { m a x d i s t } { 2 } \right]</script></li>
<li>最小高度树的根节点一定存在于x到y的路径上</li>
</ul>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/03/17/40961_image-20240317214158323.png" alt="image-20240317214158323"></p>
<p>在此我们利用广度优先搜索来找到节点的最长路径，首先找到距离节点0的最远节点x，然后找到距离节点x的最远节点y，然后找到节点x与节点y的路径，然后找到根节点。</p>
<p><strong>边的存储方式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//存储多叉树</span></span><br><span class="line">List&lt;Integer&gt;[] adj = <span class="keyword">new</span> <span class="title class_">List</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    adj[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">    adj[edge[<span class="number">0</span>]].add(edge[<span class="number">1</span>]);</span><br><span class="line">    adj[edge[<span class="number">1</span>]].add(edge[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>构建多叉树</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">curr</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">    node = curr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : adj[curr]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visit[v]) &#123;</span><br><span class="line">            visit[v] = <span class="literal">true</span>;</span><br><span class="line">            parent[v] = curr;</span><br><span class="line">            queue.offer(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindMinHeightTrees</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findMinHeightTrees</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            res.add(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存储多叉树</span></span><br><span class="line">        List&lt;Integer&gt;[] adj = <span class="keyword">new</span> <span class="title class_">List</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            adj[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">            adj[edge[<span class="number">0</span>]].add(edge[<span class="number">1</span>]);</span><br><span class="line">            adj[edge[<span class="number">1</span>]].add(edge[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(parent, -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">/* 找到与节点 0 最远的节点 x */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> findLongestNode(<span class="number">0</span>, parent, adj);</span><br><span class="line">        <span class="comment">/* 找到与节点 x 最远的节点 y */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> findLongestNode(x, parent, adj);</span><br><span class="line">        <span class="comment">/* 求出节点 x 到节点 y 的路径 */</span></span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        parent[x] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (y != -<span class="number">1</span>) &#123;</span><br><span class="line">            path.add(y);</span><br><span class="line">            y = parent[y];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> path.size();</span><br><span class="line">        <span class="keyword">if</span> (m % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(path.get(m / <span class="number">2</span> - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(path.get(m / <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建多叉树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLongestNode</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span>[] parent, List&lt;Integer&gt;[] adj)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> adj.length;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">boolean</span>[] visit = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        queue.offer(u);</span><br><span class="line">        visit[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//以当前u为根节点，层序遍历</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">node</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curr</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            node = curr;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v : adj[curr]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visit[v]) &#123;</span><br><span class="line">                    visit[v] = <span class="literal">true</span>;</span><br><span class="line">                    parent[v] = curr;</span><br><span class="line">                    queue.offer(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303.区域和检索-数组不可变"></a>303.区域和检索-数组不可变</h2><p>给定一个整数数组  <code>nums</code>，处理以下类型的多个查询:</p>
<ol>
<li>计算索引 <code>left</code> 和 <code>right</code> （包含 <code>left</code> 和 <code>right</code>）之间的 <code>nums</code> 元素的 <strong>和</strong> ，其中 <code>left &lt;= right</code></li>
</ol>
<p>实现 <code>NumArray</code> 类：</p>
<ul>
<li><code>NumArray(int[] nums)</code> 使用数组 <code>nums</code> 初始化对象</li>
<li><code>int sumRange(int i, int j)</code> 返回数组 <code>nums</code> 中索引 <code>left</code> 和 <code>right</code> 之间的元素的 <strong>总和</strong> ，包含 <code>left</code> 和 <code>right</code> 两点（也就是 <code>nums[left] + nums[left + 1] + ... + nums[right]</code> )</li>
</ul>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nums;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        System.arraycopy(nums, <span class="number">0</span>, <span class="built_in">this</span>.nums, <span class="number">0</span>, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) &#123;</span><br><span class="line">            sum += <span class="built_in">this</span>.nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1793-好子数组的最大分数"><a href="#1793-好子数组的最大分数" class="headerlink" title="1793.好子数组的最大分数"></a>1793.好子数组的最大分数</h2><p>给你一个整数数组 <code>nums</code> <strong>（下标从 0 开始）</strong>和一个整数 <code>k</code> 。</p>
<p>一个子数组 <code>(i, j)</code> 的 <strong>分数</strong> 定义为 <code>min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1)</code> 。一个 <strong>好</strong> 子数组的两个端点下标需要满足 <code>i &lt;= k &lt;= j</code> 。</p>
<p>请你返回好子数组的最大可能 <strong>分数</strong> 。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol>
<li>初始化左右指针 <code>l</code> 和 <code>r</code>，分别指向索引 <code>k</code> 的左侧和右侧，<strong>开空间</strong></li>
<li>初始化变量 <code>maxMul</code> 为索引 <code>k</code> 处的元素值，即 <code>nums[k]</code>。</li>
<li>进入一个循环，循环中进行以下操作：<ul>
<li>从当前值 <code>i</code>（初始值为 <code>nums[k]</code>）开始，分别向左右两侧扩展，直到找到左右两侧第一个小于当前值 <code>i</code> 的元素，分别更新左右指针 <code>l</code> 和 <code>r</code>。</li>
<li>计算当前子数组的乘积，即 <code>(r - l - 1) * i</code>，并将其与 <code>maxMul</code> 比较，取较大值更新 <code>maxMul</code>。</li>
<li>如果左指针 <code>l</code> 到达数组的开头且右指针 <code>r</code> 到达数组的末尾，则跳出循环。</li>
<li>更新当前值 <code>i</code> 为左右两侧中较大的值，即 <code>Math.max(nums[l], nums[r])</code>。</li>
</ul>
</li>
<li>返回最大乘积 <code>maxMul</code>。<em>**</em></li>
</ol>
<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumScore</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> k - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> k + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxMul</span> <span class="operator">=</span> nums[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums[k]; ; ) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &gt; -<span class="number">1</span> &amp;&amp; nums[l] &gt;= i) &#123;</span><br><span class="line">                --l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (r &lt; nums.length &amp;&amp; nums[r] &gt;= i) &#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            maxMul = Math.max((r - l - <span class="number">1</span>) * i, maxMul);</span><br><span class="line">            <span class="keyword">if</span> (l == -<span class="number">1</span> &amp;&amp; r == nums.length) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i = Math.max((l == -<span class="number">1</span> ? -<span class="number">1</span> : nums[l]), (r == nums.length ? -<span class="number">1</span> : nums[r]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxMul;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322.零钱兑换"></a>322.零钱兑换</h2><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<h3 id="思路-有错误"><a href="#思路-有错误" class="headerlink" title="思路-有错误"></a>思路-有错误</h3><p>贪心+回溯</p>
<p>将coin排序，每次取符合条件的最大<code>coin[i]</code></p>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">initialVal</span> <span class="operator">=</span> amount + <span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">       Arrays.fill(dp, initialVal);</span><br><span class="line">       dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> coin : coins) &#123;</span><br><span class="line">               <span class="keyword">if</span> (coin &lt;= i) &#123;</span><br><span class="line">                   dp[i] = Math.min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[amount] == initialVal ? -<span class="number">1</span> : dp[amount];</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="518-零钱兑换2"><a href="#518-零钱兑换2" class="headerlink" title="518.零钱兑换2"></a>518.零钱兑换2</h2><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p>
<p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p>
<p>假设每一种面额的硬币有无限个。 </p>
<p>题目数据保证结果符合 32 位带符号整数。</p>
<h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>回溯-会超时</p>
<h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">    Arrays.sort(coins);</span><br><span class="line">    backtracking(amount, coins, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins, <span class="type">int</span> startIdx)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (amount == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIdx; i &lt; coins.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &gt;= coins[i]) &#123;</span><br><span class="line">            backtracking(amount - coins[i], coins, i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//所有coin都不能找零</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路2-动态规划"><a href="#思路2-动态规划" class="headerlink" title="思路2 动态规划"></a>思路2 动态规划</h3><h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><p>上述做法不会重复计算不同的排列。因为外层循环是遍历数组 <code>coins</code>的值，内层循环是遍历不同的金额之和，在计算 <code>dp[i]</code>的值时，可以确保金额之和等于<code>i</code>的硬币面额的顺序，由于顺序确定，因此不会重复计算不同的排列。</p>
<p>如果for循环嵌套错误，会出现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int amount = 5;</span><br><span class="line">int[] coins = &#123;1, 2, 5&#125;;</span><br><span class="line">//1，2，2</span><br><span class="line">//2，2，1</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] dp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">    changeHelper(amount, coins);</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeHelper</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">    Arrays.sort(coins);</span><br><span class="line">    dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> coin : coins) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> coin; i &lt;= amount; i++) &#123;</span><br><span class="line">            dp[i] += dp[i - coin];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2580-统计将重叠区间合并成组的方案数"><a href="#2580-统计将重叠区间合并成组的方案数" class="headerlink" title="2580.统计将重叠区间合并成组的方案数"></a>2580.统计将重叠区间合并成组的方案数</h2><p>给你一个二维整数数组 <code>ranges</code> ，其中 <code>ranges[i] = [starti, endi]</code> 表示 <code>starti</code> 到 <code>endi</code> 之间（包括二者）的所有整数都包含在第 <code>i</code> 个区间中。</p>
<p>你需要将 <code>ranges</code> 分成 <strong>两个</strong> 组（可以为空），满足：</p>
<ul>
<li>每个区间只属于一个组。</li>
<li>两个有 <strong>交集</strong> 的区间必须在 <strong>同一个</strong> 组内。</li>
</ul>
<p>如果两个区间有至少 <strong>一个</strong> 公共整数，那么这两个区间是 <strong>有交集</strong> 的。</p>
<ul>
<li>比方说，区间 <code>[1, 3]</code> 和 <code>[2, 5]</code> 有交集，因为 <code>2</code> 和 <code>3</code> 在两个区间中都被包含。</li>
</ul>
<p>请你返回将 <code>ranges</code> 划分成两个组的 <strong>总方案数</strong> 。由于答案可能很大，将它对 <code>109 + 7</code> <strong>取余</strong> 后返回。</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>排序</p>
</li>
<li><p>将有交集的集合进行合并：</p>
<ul>
<li><p>固定<code>r=ranges[i][1]</code>，只要 <code>r &gt;= ranges[i][0]</code>不断移动向右移动<code>i</code>，并更新<code>r = Math.max(r, ranges[i][1])</code>，直到<code>i</code>到达终点或者<code>r&lt;ranges[i][0]</code></p>
</li>
<li><p>每次中断更新次数</p>
</li>
</ul>
</li>
</ol>
<h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countWays</span><span class="params">(<span class="type">int</span>[][] ranges)</span> &#123;</span><br><span class="line">       Arrays.sort(ranges, Comparator.comparingInt(a -&gt; a[<span class="number">0</span>]));</span><br><span class="line">       <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ranges.length; ) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> ranges[i][<span class="number">1</span>];</span><br><span class="line">           <span class="keyword">while</span> (i &lt; ranges.length &amp;&amp; r &gt;= ranges[i][<span class="number">0</span>]) &#123;</span><br><span class="line">               r = Math.max(r, ranges[i][<span class="number">1</span>]);</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">           res = res * <span class="number">2</span> % <span class="number">1000000007</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="331-验证二叉树的前序序列化"><a href="#331-验证二叉树的前序序列化" class="headerlink" title="331. 验证二叉树的前序序列化"></a>331. 验证二叉树的前序序列化</h2><p>序列化二叉树的一种方法是使用 <strong>前序遍历</strong> 。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 <code>#</code>。</p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/12/pre-tree.jpg" alt="img"></p>
<p>例如，上面的二叉树可以被序列化为字符串 <code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code>，其中 <code>#</code> 代表一个空节点。</p>
<p>给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。</p>
<p><strong>保证</strong> 每个以逗号分隔的字符或为一个整数或为一个表示 <code>null</code> 指针的 <code>&#39;#&#39;</code> 。</p>
<p>你可以认为输入格式总是有效的</p>
<ul>
<li>例如它永远不会包含两个连续的逗号，比如 <code>&quot;1,,3&quot;</code> 。</li>
</ul>
<p><strong>注意：</strong>不允许重建树。</p>
<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= preorder.length &lt;= 104</code></li>
<li><code>preorder</code> 由以逗号 <code>“，”</code> 分隔的 <code>[0,100]</code> 范围内的整数和 <code>“#”</code> 组成</li>
</ul>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>我们可以定义一个概念，叫做槽位。一个槽位可以被看作「当前二叉树中正在等待被节点填充」的那些位置。</p>
<p>二叉树的建立也伴随着槽位数量的变化。每当遇到一个节点时：</p>
<ul>
<li><p>如果遇到了空节点，则要消耗一个槽位；</p>
</li>
<li><p>如果遇到了非空节点，则除了消耗一个槽位外，还要再补充两个槽位。</p>
</li>
<li><p>此外，还需要将根节点作为特殊情况处理。</p>
</li>
</ul>
<blockquote>
<p>我们可以只维护一个计数器，用来记录槽位的变化，槽位提前变为0则返回为<code>false</code>，否则一直遍历直到最终能构成前序遍历。</p>
<p>数字读取时要注意可能不是一位数</p>
</blockquote>
<h3 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidSerialization</span><span class="params">(String preorder)</span> &#123;</span><br><span class="line">       <span class="comment">//定义槽位，用来存放节点和空节点，空节点消耗一个槽位，非空节点消耗一个节点并产生两个节点</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">slots</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> preorder.length();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ) &#123;</span><br><span class="line">           <span class="keyword">if</span> (slots == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           <span class="keyword">if</span> (preorder.charAt(i) == <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">               i++;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (preorder.charAt(i) == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">               slots--;</span><br><span class="line">               i++;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;<span class="comment">//读取数字，如35</span></span><br><span class="line">               <span class="keyword">while</span> (i &lt; len &amp;&amp; preorder.charAt(i) != <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">                   i++;</span><br><span class="line">               &#125;</span><br><span class="line">               slots++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> slots == <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>dailyQuestion</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
        <tag>daily</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录-贪心算法</title>
    <url>/2024/04/08/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p><strong>本节包括：</strong></p>
<ul>
<li>各种贪心算法题</li>
</ul>
<span id="more"></span>
<h2 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455.分发饼干"></a>455.分发饼干</h2><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: g = [1,2], s = [1,2,3]</span><br><span class="line">输出: 2</span><br><span class="line">解释: </span><br><span class="line">你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。</span><br><span class="line">你拥有的饼干数量和尺寸都足以让所有孩子满足。</span><br><span class="line">所以你应该输出2.</span><br></pre></td></tr></table></figure>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">      Arrays.sort(g);</span><br><span class="line">      Arrays.sort(s);</span><br><span class="line">      <span class="type">int</span> <span class="variable">gPos</span> <span class="operator">=</span> g.length - <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">sPos</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (; gPos &gt;= <span class="number">0</span> &amp;&amp; sPos &gt;= <span class="number">0</span>; gPos--) &#123;</span><br><span class="line">          <span class="comment">//饼干能满足孩子胃口</span></span><br><span class="line">          <span class="keyword">if</span> (s[sPos] &gt;= g[gPos]) &#123;</span><br><span class="line">              count++;</span><br><span class="line">              sPos--;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376. 摆动序列"></a>376. 摆动序列</h2><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 <strong>摆动序列 。</strong>第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p>
<ul>
<li>例如， <code>[1, 7, 4, 9, 2, 5]</code> 是一个 <strong>摆动序列</strong> ，因为差值 <code>(6, -3, 5, -7, 3)</code> 是正负交替出现的。</li>
<li>相反，<code>[1, 4, 7, 2, 5]</code> 和 <code>[1, 7, 4, 5, 5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</li>
</ul>
<p><strong>子序列</strong> 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p>
<p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 中作为 <strong>摆动序列</strong> 的 <strong>最长子序列的长度</strong> 。</p>
<h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>分情况讨论：</p>
<ol>
<li>情况一：上下坡中有平坡</li>
<li>情况二：数组首尾两端</li>
<li>情况三：单调坡中有平坡</li>
</ol>
<h4 id="情况一：上下坡中有平坡"><a href="#情况一：上下坡中有平坡" class="headerlink" title="情况一：上下坡中有平坡"></a>情况一：上下坡中有平坡</h4><p>我们记录峰值的条件应该是： <code>(preDiff &lt;= 0 &amp;&amp; curDiff &gt; 0) || (preDiff &gt;= 0 &amp;&amp; curDiff &lt; 0)</code></p>
<h4 id="情况二：数组首尾两端"><a href="#情况二：数组首尾两端" class="headerlink" title="情况二：数组首尾两端"></a>情况二：数组首尾两端</h4><p>我们在计算 <code>prediff（nums[i] - nums[i-1]）</code> 和 <code>curdiff（nums[i+1] - nums[i]）</code>的时候，至少需要三个数字才能计算，而数组只有两个数字时。result 初始为 1（默认最右面有一个峰值），此时 <code>curDiff &gt; 0 &amp;&amp; preDiff &lt;= 0</code>，那么 result++（计算了左面的峰值）</p>
<h4 id="情况三：单调坡度有平坡"><a href="#情况三：单调坡度有平坡" class="headerlink" title="情况三：单调坡度有平坡"></a>情况三：单调坡度有平坡</h4><p>如果在一个单调坡度上有平坡，例如[1,2,2,2,3,4]</p>
<p>我们只需要在这个坡度摆动变化的时候，更新prediff就行，这样prediff在单调区间有平坡的时候就不会发生变化，造成我们的误判。</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">preDiff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">curDiff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">          curDiff = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">          <span class="keyword">if</span> ((preDiff &lt;= <span class="number">0</span> &amp;&amp; curDiff &gt; <span class="number">0</span>) || (preDiff &gt;= <span class="number">0</span> &amp;&amp; curDiff &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">              res++;</span><br><span class="line">              <span class="comment">//出现拐弯时才更新preDiff</span></span><br><span class="line">              preDiff = curDiff;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>下降=在上升的次数加一，上升=在下降的次数加一</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[]nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">down</span> <span class="operator">=</span> <span class="number">1</span>, up = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>])</span><br><span class="line">            up = down + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>])</span><br><span class="line">            down = up + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums.length == <span class="number">0</span> ? <span class="number">0</span> : Math.max(down, up);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a>53. 最大子序和</h2><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<ul>
<li>输入: [-2,1,-3,4,-1,2,1,-5,4]</li>
<li>输出: 6</li>
<li>解释: 连续子数组  [4,-1,2,1] 的和最大，为  6。</li>
</ul>
<h3 id="思路-贪心"><a href="#思路-贪心" class="headerlink" title="思路-贪心"></a>思路-贪心</h3><p>遍历 nums，从头开始用 sum累积，如果 count 一旦加上 nums[i]变为负数，那么就应该从 nums[i+1]开始从 0 累积 count 了，因为已经变为负数的 count，只会拖累总和。</p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; res) &#123;<span class="comment">// 取区间累计的最大值（相当于不断确定最大子序终止位置）</span></span><br><span class="line">                res = sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-动态规划"><a href="#思路-动态规划" class="headerlink" title="思路-动态规划"></a>思路-动态规划</h3><p>dp[i]：包括下标i（以nums[i]为结尾）的最大连续子序列和为dp[i]。</p>
<p>递推公式中<code>dp[i]</code>依赖于dp[i - 1]的状态，需要从前向后遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[i] = Math.max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br></pre></td></tr></table></figure>
<ul>
<li>dp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和</li>
<li>nums[i]，即：从头开始计算当前连续子序列和</li>
</ul>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArrayDP</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp[i] = Math.max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (res &lt; dp[i]) &#123;</span><br><span class="line">            res = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122.买卖股票的最佳时机 II"></a>122.买卖股票的最佳时机 II</h2><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p>
<p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。<strong>你也可以先购买，然后在 同一天出售。</strong></p>
<p>返回你能获得的 <strong>最大</strong> 利润。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [7,1,5,3,6,4]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。</span><br><span class="line">     总利润为 4 + 3 = 7 。</span><br></pre></td></tr></table></figure>
<h3 id="思路-贪心-1"><a href="#思路-贪心-1" class="headerlink" title="思路-贪心"></a>思路-贪心</h3><p><strong>如果想到其实最终利润是可以分解的，那么本题就很容易了！</strong></p>
<p>假如第 0 天买入，第 3 天卖出，那么利润为：prices[3] - prices[0]。</p>
<p>相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。</p>
<p><strong>此时就是把利润分解为每天为单位的维度，而不是从 0 天到第 3 天整体去考虑！</strong></p>
<p>那么根据 prices 可以得到每天的利润序列：<code>(prices[i] - prices[i - 1]).....(prices[1] - prices[0])</code>。</p>
<p>将每日的利润（正）加起来</p>
<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">profit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] dailyProfit = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        dailyProfit[i] = prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dailyProfit.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dailyProfit[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            profit += dailyProfit[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-动态规划-1"><a href="#思路-动态规划-1" class="headerlink" title="思路-动态规划"></a>思路-动态规划</h3><ul>
<li><code>dp[i][0]</code> 表示第i天持有股票所得现金。</li>
<li><code>dp[i][1]</code> 表示第i天不持有股票所得最多现金</li>
</ul>
<p><code>dp[i][0]</code></p>
<p>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：<code>dp[i - 1][0]</code><br>第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：<code>dp[i - 1][1] - prices[i]</code></p>
<p><code>dp[i][1]</code></p>
<p>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：<code>dp[i - 1][1]</code><br>第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：<code>prices[i] + dp[i - 1][0]</code></p>
<h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfitThroughDp</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> prices.length;</span><br><span class="line">       <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[days][<span class="number">2</span>];<span class="comment">//第i天的最大利润</span></span><br><span class="line">       <span class="comment">//dp[i][0]代表有股票，dp[i][1]代表没有股票</span></span><br><span class="line">       dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">       dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; days; i++) &#123;</span><br><span class="line">           dp[i][<span class="number">0</span>] =  Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">           dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[days - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a>55. 跳跃游戏</h2><p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点。</p>
<blockquote>
<p>i 每次移动只能在 cover 的范围内移动，每移动一个元素，cover 得到该元素数值（新的覆盖范围）的补充，让 i 继续移动下去。</p>
</blockquote>
<h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cover</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= cover; i++) &#123;</span><br><span class="line">        cover = Math.max(cover, i + nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (cover &gt;= nums.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45.跳跃游戏 II"></a>45.跳跃游戏 II</h2><p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code>。</p>
<p>每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向前跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p>
<ul>
<li><code>0 &lt;= j &lt;= nums[i]</code> </li>
<li><code>i + j &lt; n</code></li>
</ul>
<p>返回到达 <code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>要从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最少步数！</p>
<p><strong>这里需要统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖</strong>。</p>
<p>如果移动下标达到了当前这一步的最大覆盖最远距离了，还没有到终点的话，那么就必须再走一步来增加覆盖范围，直到覆盖范围覆盖了终点。</p>
<h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">steps</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">curMax</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">nextMax</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        nextMax = Math.max(nextMax, i + nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (i == curMax) &#123;</span><br><span class="line">            steps++;</span><br><span class="line">            curMax = nextMax;</span><br><span class="line">            <span class="comment">//已经可以跳到数组末尾</span></span><br><span class="line">            <span class="keyword">if</span> (nextMax &gt;= nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> steps;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> steps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1005-K次取反后最大化的数组和"><a href="#1005-K次取反后最大化的数组和" class="headerlink" title="1005.K次取反后最大化的数组和"></a>1005.K次取反后最大化的数组和</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，按以下方法修改该数组：</p>
<ul>
<li>选择某个下标 <code>i</code> 并将 <code>nums[i]</code> 替换为 <code>-nums[i]</code> 。</li>
</ul>
<p>重复这个过程恰好 <code>k</code> 次。可以多次选择同一个下标 <code>i</code> 。</p>
<p>以这种方式修改数组后，返回数组 <strong>可能的最大和</strong> 。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ul>
<li>第一步：将数组按照绝对值大小从大到小排序，<strong>注意要按照绝对值的大小</strong></li>
<li>第二步：从前向后遍历，遇到负数将其变为正数，同时K—</li>
<li>第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完</li>
<li>第四步：求和</li>
</ul>
<h3 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">negCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//数组按照绝对值从大到小排序</span></span><br><span class="line">       nums = IntStream.of(nums)</span><br><span class="line">               .boxed()</span><br><span class="line">               .sorted((o1, o2) -&gt; Math.abs(o2) - Math.abs(o1))</span><br><span class="line">               .mapToInt(Integer::intValue)</span><br><span class="line">               .toArray();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">               nums[i] = Math.abs(nums[i]);</span><br><span class="line">               k--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">1</span>) nums[nums.length - <span class="number">1</span>] = -nums[nums.length - <span class="number">1</span>];</span><br><span class="line">       <span class="keyword">return</span> Arrays.stream(nums).sum();</span><br></pre></td></tr></table></figure>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><ol>
<li>先排序，将负数变为正数</li>
<li>若k&gt;0，再次排序，将最小值取反</li>
<li>求和</li>
</ol>
<h3 id="代码实现-10"><a href="#代码实现-10" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestSumAfterKNegations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">       Arrays.sort(nums);</span><br><span class="line">       <span class="comment">//将负数变为正数</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               nums[i] = -nums[i];</span><br><span class="line">               k--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">           Arrays.sort(nums);</span><br><span class="line">           nums[<span class="number">0</span>] = -nums[<span class="number">0</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Arrays.stream(nums).sum();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a>134. 加油站</h2><p>在一条环路上有 <code>n</code> 个加油站，其中第 <code>i</code> 个加油站有汽油 <code>gas[i]</code> 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 <code>i</code> 个加油站开往第 <code>i+1</code> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>给定两个整数数组 <code>gas</code> 和 <code>cost</code> ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 <code>-1</code> 。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明 各个站点的加油站 剩油量<code>rest[i]</code>相加一定是大于等于零的。</p>
<p>i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，因为这个区间选择任何一个位置作为起点，到i这里都会断油，那么起始位置从i+1算起，再从0计算curSum。</p>
<h3 id="代码实现-11"><a href="#代码实现-11" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> gas.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">resGas</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">totalRest</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        resGas += gas[i] - cost[i];</span><br><span class="line">        totalRest += gas[i] - cost[i];</span><br><span class="line">        <span class="keyword">if</span> (resGas &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            start = i + <span class="number">1</span>;</span><br><span class="line">            resGas = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (totalRest &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135. 分发糖果"></a>135. 分发糖果</h2><p><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分。</p>
<p>你需要按照以下要求，给这些孩子分发糖果：</p>
<ul>
<li>每个孩子至少分配到 <code>1</code> 个糖果。</li>
<li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li>
</ul>
<p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</p>
<p>示例 2:</p>
<ul>
<li>输入: [1,2,2]</li>
<li>输出: 4</li>
<li>解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。第三个孩子只得到 1 颗糖果，这已满足上述两个条件。</li>
</ul>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><ul>
<li>一次是从左到右遍历，只比较右边孩子评分比左边大的情况。</li>
<li>一次是从右到左遍历，只比较左边孩子评分比右边大的情况。</li>
</ul>
<h3 id="代码实现-12"><a href="#代码实现-12" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] childCandy = <span class="keyword">new</span> <span class="title class_">int</span>[ratings.length];</span><br><span class="line">        Arrays.fill(childCandy, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//从左往右比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; ratings.length; i++) &#123;</span><br><span class="line">            childCandy[i] = (ratings[i] &gt; ratings[i - <span class="number">1</span>]) ? childCandy[i - <span class="number">1</span>] + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从后往前比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ratings.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i - <span class="number">1</span>] &gt; ratings[i])</span><br><span class="line">                childCandy[i - <span class="number">1</span>] = Math.max(childCandy[i - <span class="number">1</span>], childCandy[i] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(childCandy).sum();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860.柠檬水找零"></a>860.柠檬水找零</h2><p>在柠檬水摊上，每一杯柠檬水的售价为 <code>5</code> 美元。顾客排队购买你的产品，（按账单 <code>bills</code> 支付的顺序）一次购买一杯。</p>
<p>每位顾客只买一杯柠檬水，然后向你付 <code>5</code> 美元、<code>10</code> 美元或 <code>20</code> 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 <code>5</code> 美元。</p>
<p>注意，一开始你手头没有任何零钱。</p>
<p>给你一个整数数组 <code>bills</code> ，其中 <code>bills[i]</code> 是第 <code>i</code> 位顾客付的账。如果你能给每位顾客正确找零，返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<h3 id="代码实现-13"><a href="#代码实现-13" class="headerlink" title="代码实现"></a>代码实现</h3><p>在 Java 中，switch 语句通常在匹配到一个 case 后会执行对应的代码块然后跳出 switch 结构。如果删除了 break 语句，即使匹配到一个 case，也会继续执行下一个 case 中的代码，直到遇到 break 语句或者 switch 结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lemonadeChange</span><span class="params">(<span class="type">int</span>[] bills)</span> &#123;</span><br><span class="line">    <span class="comment">//0,1分别存5美元和10美元零钱</span></span><br><span class="line">    <span class="type">int</span>[] coins = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bills.length; i++) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (bills[i]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">20</span>:</span><br><span class="line">                <span class="keyword">if</span> (coins[<span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    coins[<span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">                    coins[<span class="number">0</span>] -= <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    coins[<span class="number">0</span>] -= <span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">                coins[<span class="number">0</span>] -= <span class="number">1</span>;</span><br><span class="line">                coins[<span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                coins[<span class="number">0</span>] += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (coins[<span class="number">0</span>] &lt; <span class="number">0</span> || coins[<span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406.根据身高重建队列"></a>406.根据身高重建队列</h2><p>假设有打乱顺序的一群人站成一个队列，数组 <code>people</code> 表示队列中一些人的属性（不一定按顺序）。每个 <code>people[i] = [hi, ki]</code> 表示第 <code>i</code> 个人的身高为 <code>hi</code> ，前面 <strong>正好</strong> 有 <code>ki</code> 个身高大于或等于 <code>hi</code> 的人。</p>
<p>请你重新构造并返回输入数组 <code>people</code> 所表示的队列。返回的队列应该格式化为数组 <code>queue</code> ，其中 <code>queue[j] = [hj, kj]</code> 是队列中第 <code>j</code> 个人的属性（<code>queue[0]</code> 是排在队列前面的人）</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</span><br><span class="line">输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</span><br><span class="line">解释：</span><br><span class="line">编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。</span><br><span class="line">编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。</span><br><span class="line">编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。</span><br><span class="line">编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</span><br><span class="line">因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。</span><br></pre></td></tr></table></figure>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><ol>
<li>先按照身高<code>h</code>从大到小排序，注意身高相同，那么就按照<code>k</code>从小到大排序</li>
<li>遍历，根据<code>ki</code>插入对应的队列位置</li>
<li>注意，最后序列转化为数组的方式</li>
</ol>
<h3 id="代码实现-14"><a href="#代码实现-14" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReconstructQueue</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] reconstructQueue(<span class="type">int</span>[][] people) &#123;</span><br><span class="line">        Arrays.sort(people, (a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];<span class="comment">//身高相同，从小到达排序</span></span><br><span class="line">            <span class="keyword">return</span> b[<span class="number">0</span>] - a[<span class="number">0</span>];<span class="comment">//整体升高从大到小</span></span><br><span class="line">        &#125;);</span><br><span class="line">        LinkedList&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; people.length; i++) &#123;</span><br><span class="line">            queue.add(people[i][<span class="number">1</span>], people[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[people.length][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a>452. 用最少数量的箭引爆气球</h2><p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 <code>points</code> ，其中<code>points[i] = [x_start, x_end]</code> 表示水平直径在 <code>xstart</code> 和 <code>xend</code>之间的气球。你不知道气球的确切 y 坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点 <strong>完全垂直</strong> 地射出。在坐标 <code>x</code> 处射出一支箭，若有一个气球的直径的开始和结束坐标为 <code>x_start</code>，<code>x_end</code>， 且满足  <code>x_start ≤ x ≤ x_end</code>，则该气球会被 <strong>引爆</strong> 。可以射出的弓箭的数量 <strong>没有限制</strong> 。 弓箭一旦被射出之后，可以无限地前进。</p>
<p>给你一个数组 <code>points</code> ，<em>返回引爆所有气球所必须射出的 <strong>最小</strong> 弓箭数</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：points = [[10,16],[2,8],[1,6],[7,12]]</span><br><span class="line">输出：2</span><br><span class="line">解释：气球可以用2支箭来爆破:</span><br><span class="line">-在x = 6处射出箭，击破气球[2,8]和[1,6]。</span><br><span class="line">-在x = 11处发射箭，击破气球[10,16]和[7,12]。</span><br></pre></td></tr></table></figure>
<p><code>-231 &lt;= xstart &lt; xend &lt;= 231 - 1</code></p>
<h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>既然按照起始位置排序，那么就从前向后遍历气球数组，靠左尽可能让气球重复。</p>
<p>从前向后遍历遇到重叠的气球了怎么办？</p>
<p><strong>如果气球重叠了，重叠气球中右边边界的最小值 之前的区间一定需要一个弓箭</strong>。</p>
<blockquote>
<p>为了避免数据溢出，要考虑Integer.compare(a[0], b[0]))进行比较，它不是直接做减法运算，而是比较两个数的大小，因此不会发生溢出。</p>
<p>一定要更新重叠气球的最小值</p>
</blockquote>
<h3 id="代码实现-15"><a href="#代码实现-15" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">    Arrays.sort(points, (a, b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br><span class="line">    <span class="comment">//至少需要一只箭，避免最后的一组会落空</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numArrows</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (points[i][<span class="number">0</span>] &gt; points[i - <span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">            numArrows++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            points[i][<span class="number">1</span>] = Math.min(points[i][<span class="number">1</span>], points[i - <span class="number">1</span>][<span class="number">1</span>]); <span class="comment">// 更新重叠气球最小右边界</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numArrows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a>435. 无重叠区间</h2><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
<p>注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p>
<h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>找到所有重叠的区间，然后用总区间减去重叠区间数</p>
<h3 id="代码实现-16"><a href="#代码实现-16" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EraseOverlapIntervals</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">crossInterval</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//记录重叠的区间组总数</span></span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt;= intervals[i - <span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">                crossInterval++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                intervals[i][<span class="number">1</span>] = Math.min(intervals[i][<span class="number">1</span>], intervals[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals.length - crossInterval;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763.划分字母区间"></a>763.划分字母区间</h2><p>给你一个字符串 <code>s</code> 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。</p>
<p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 <code>s</code> 。</p>
<p>返回一个表示每个字符串片段的长度的列表。</p>
<h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><p>将每个字母的最后出现的位置记录下来，不断更新局部区间字母出现最大值，直到这个最大值等于当前索引，这是由于<code>ababcbaca</code>中<code>a</code>最后出现的位置大于<code>b</code>，应该让<code>a</code>包含<code>b</code>，同时用last记录上个区间的位置，方便计算字符串长度。</p>
<h3 id="代码实现-17"><a href="#代码实现-17" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">partitionLabels</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] farIdx = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        farIdx[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">far</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        far = Math.max(far, farIdx[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">        <span class="keyword">if</span> (far == i) &#123;</span><br><span class="line">            res.add(i - last);</span><br><span class="line">            last = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h2><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure>
<h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><p>先排序，让所有的相邻区间尽可能的重叠在一起，按左边界，或者右边界排序都可以，处理逻辑稍有不同。</p>
<p><code>intervals[i][0] &gt; r</code>，表明当前区间不能和前面的区间合并</p>
<p>合并区间后左边界和右边界，作为一个新的区间，加入到result数组里就可以了</p>
<h3 id="代码实现-18"><a href="#代码实现-18" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line">    Arrays.sort(intervals, (a, b) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt; r) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;l, r&#125;);</span><br><span class="line">            l = intervals[i][<span class="number">0</span>];</span><br><span class="line">            r = intervals[i][<span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = Math.max(r, intervals[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;l, r&#125;);</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="738-单调递增的数字"><a href="#738-单调递增的数字" class="headerlink" title="738.单调递增的数字"></a>738.单调递增的数字</h2><p>当且仅当每个相邻位数上的数字 <code>x</code> 和 <code>y</code> 满足 <code>x &lt;= y</code> 时，我们称这个整数是<strong>单调递增</strong>的。</p>
<p>给定一个整数 <code>n</code> ，返回 <em>小于或等于 <code>n</code> 的最大数字，且数字呈 <strong>单调递增</strong></em> 。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: n = 10</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: n = 1234</span><br><span class="line">输出: 1234</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: n = 332</span><br><span class="line">输出: 299</span><br></pre></td></tr></table></figure>
<h3 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h3><p>用一个flag来标记从哪里开始赋值9</p>
<p>遇到<code>strNum[i - 1] &gt; strNum[i]</code>的情况，让<code>strNum[i - 1]</code>减一，<code>flag</code>设为<code>i</code></p>
<h3 id="代码实现-19"><a href="#代码实现-19" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(n);</span><br><span class="line">    <span class="type">char</span>[] array = s.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> array.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i - <span class="number">1</span>] &gt; array[i]) &#123;</span><br><span class="line">            start = i;</span><br><span class="line">            array[i - <span class="number">1</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; array.length; i++) &#123;</span><br><span class="line">        array[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Integer.parseInt(String.valueOf(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968.监控二叉树"></a>968.监控二叉树</h2><p>给定一个二叉树，我们在树的节点上安装摄像头。</p>
<p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p>
<p>计算监控树的所有节点所需的最小摄像头数量。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_01.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[0,0,null,0,0]</span><br><span class="line">输出：1</span><br><span class="line">解释：如图所示，一台摄像头足以监控所有节点。</span><br></pre></td></tr></table></figure>
<h3 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h3><p>后续遍历</p>
<p><strong>局部最优：让叶子节点的父节点安摄像头，所用摄像头最少，整体最优：全部摄像头数量所用最少！</strong></p>
<p>我们分别有三个数字来表示：</p>
<ul>
<li>0：该节点无覆盖</li>
<li>1：本节点有摄像头</li>
<li>2：本节点有覆盖</li>
</ul>
<p><strong>空节点的状态只能是有覆盖，这样就可以在叶子节点的父节点放摄像头了</strong></p>
<p><strong>递推关系：</strong></p>
<p>终止条件应该是遇到了空节点，此时应该返回2（有覆盖）</p>
<p><strong>单层逻辑：</strong></p>
<ul>
<li>情况1：左右节点都有覆盖</li>
</ul>
<p>左孩子有覆盖，右孩子有覆盖，那么此时中间节点应该就是无覆盖的状态了。</p>
<ul>
<li>情况2：左右节点至少有一个无覆盖的情况</li>
</ul>
<p>此时摄像头的数量要加一，并且return 1，代表中间节点放摄像头。</p>
<p>如果是以下情况，其实就是 左右孩子节点有一个有摄像头了，那么其父节点就应该是2（覆盖的状态）</p>
<ul>
<li>情况3：左右节点至少有一个有摄像头</li>
</ul>
<p>如果是以下情况，其实就是 左右孩子节点有一个有摄像头了，那么其父节点就应该是2（覆盖的状态）</p>
<ul>
<li>情况4：头结点没有覆盖</li>
</ul>
<p>以上都处理完了，递归结束之后，可能头结点 还有一个无覆盖的情况</p>
<h3 id="代码实现-20"><a href="#代码实现-20" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinCameraCover</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCameraCover</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (traversal(root) == <span class="number">0</span>) &#123;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 0：该节点无覆盖</span></span><br><span class="line"><span class="comment">     * 1：本节点有摄像头</span></span><br><span class="line"><span class="comment">     * 2：本节点有覆盖</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">traversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> traversal(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> traversal(root.right);</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">2</span> &amp;&amp; right == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="number">0</span> || right == <span class="number">0</span>) &#123;<span class="comment">//一定是父节点覆盖子节点优先，2优于3</span></span><br><span class="line">            ++res;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="number">1</span> || right == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//不会走到这里</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code_Musing</category>
      </categories>
      <tags>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录-动态规划1</title>
    <url>/2024/04/15/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%921/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p><strong>本节包括：</strong></p>
<ul>
<li>动态规划概念</li>
<li>动态规划实战</li>
<li>0-1背包（后续遍历）</li>
</ul>
<span id="more"></span>
<h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><p>动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。</p>
<p><strong>对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！</strong></p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
<li>确定递推公式</li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
<h2 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a>509. 斐波那契数</h2><p><strong>斐波那契数</strong> （通常用 <code>F(n)</code> 表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F(0) = 0，F(1) = 1</span><br><span class="line">F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</span><br></pre></td></tr></table></figure>
<p>给定 <code>n</code> ，请计算 <code>F(n)</code> 。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目已经给出了状态转移方程，用代码实现就行，需要注意n=0，1的情况，动态数组可能越界问题。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h2><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p>
<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>动态规划</p>
<p><code>dp[i]=dp[i-1]+dp[i-2]</code></p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;<span class="comment">//(1,1),(2)</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a>746. 使用最小花费爬楼梯</h2><p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p>
<p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p>
<p>请你计算并返回达到楼梯顶部的最低花费。</p>
<p><code>2 &lt;= cost.length &lt;= 1000</code></p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p><code>dp[i]</code>表示到达台阶<code>i</code>并起跳的最小费用</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[cost.length + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; cost.length; i++) &#123;</span><br><span class="line">        dp[i] = Math.min(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>]) + cost[i];</span><br><span class="line">    &#125;</span><br><span class="line">    dp[cost.length] = Math.min(dp[cost.length - <span class="number">1</span>], dp[cost.length - <span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> dp[cost.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://pic.leetcode.cn/1697422740-adxmsI-image.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 3, n = 7</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>机器人从(0 , 0) 位置出发，到(m - 1, n - 1)终点。</p>
<p><code>dp[i][j]</code> ：表示从（0 ，0）出发，到(i, j) 有<code>dp[i][j]</code>条不同的路径。</p>
<p>想要求<code>dp[i][j]</code>，只能有两个方向来推导出来，即<code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code>。</p>
<p>起始行和起始列初始为1</p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];<span class="comment">//到达(i,j)的不同路径数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a>63. 不同路径 II</h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>因为从(0, 0)的位置到(i, 0)的路径只有一条，所以<code>dp[i][0]</code>一定为1，<code>dp[0][j]</code>也同理。</p>
<p>但如果(i, 0) 这条边有了障碍之后，障碍之后（包括障碍）都是走不到的位置了，所以障碍之后的<code>dp[i][0]</code>应该还是初始值0。</p>
<p>从递归公式<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code> 中可以看出，一定是从左到右一层一层遍历，这样保证推导<code>dp[i][j]</code>的时候，<code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code>一定是有数值。</p>
<p>当前是障碍物，直接跳过</p>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> obstacleGrid.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">//如果在起点或终点出现了障碍，直接返回0</span></span><br><span class="line">    <span class="keyword">if</span> (obstacleGrid[m - <span class="number">1</span>][n - <span class="number">1</span>] == <span class="number">1</span> || obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span>; j++) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343. 整数拆分"></a>343. 整数拆分</h2><p>给定一个正整数 <code>n</code> ，将其拆分为 <code>k</code> 个 <strong>正整数</strong> 的和（ <code>k &gt;= 2</code> ），并使这些整数的乘积最大化。</p>
<p>返回 <em>你可以获得的最大乘积</em> 。</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>因为拆分一个数n 使之乘积最大，那么一定是拆分成m个近似相同的子数相乘才是最大的。</p>
<p>例如 6 拆成 3 <em> 3， 10 拆成 3 </em> 3 * 4。 100的话 也是拆成m个近似数组的子数 相乘才是最大的。</p>
<p>那么 j 遍历，只需要遍历到 n/2 就可以，后面就没有必要遍历了，一定不是最大值。</p>
<p> <code>dp[i] = Math.max(Math.max((i - j) * j, dp[i - j] * j), dp[i]);</code></p>
<p>状态转移方程要考虑三个：</p>
<ol>
<li>当前<code>dp[i]</code></li>
<li><code>dp[i - j] * j</code></li>
<li>把<code>i-j</code>单独作为一个数乘以j</li>
</ol>
<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];<span class="comment">//dp[n]代表正数拆分的最大乘积</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; j++) &#123;</span><br><span class="line">            dp[i] = Math.max(Math.max((i - j) * j, dp[i - j] * j), dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96.不同的二叉搜索树"></a>96.不同的二叉搜索树</h2><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210107093226241.png" alt="96.不同的二叉搜索树2" style="zoom: 33%;" /></p>
<p> dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]</p>
<p>j相当于是头结点的元素，从1遍历到i为止。</p>
<p>所以递推公式：dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量</p>
<h2 id="动态规划：01背包理论基础"><a href="#动态规划：01背包理论基础" class="headerlink" title="动态规划：01背包理论基础"></a>动态规划：01背包理论基础</h2><p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是<code>weight[i]</code>，得到的价值是<code>value[i]</code> 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>
<h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p>使用二维数组，即<code>dp[i][j]</code> 表示从下标为<code>[0-i]</code>的物品里任意取，放进容量为<code>j</code>的背包，价值总和最大是多少</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210110103003361.png" alt="动态规划-背包问题1" style="zoom:50%;" /></p>
<ol>
<li>确定递推公式</li>
</ol>
<ul>
<li><p><strong>不放物品i</strong>：由<code>dp[i - 1][j]</code>推出，即背包容量为<code>j</code>，里面不放物品i的最大价值，此时<code>dp[i][j]</code>就是<code>dp[i - 1][j]</code>。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以背包内的价值依然和前面相同。)</p>
</li>
<li><p><strong>放物品i</strong>：由<code>dp[i - 1][j - weight[i]]</code>推出，<code>dp[i - 1][j - weight[i]]</code> 为背包容量为<code>j - weight[i]</code>的时候不放物品i的最大价值，那么<code>dp[i - 1][j - weight[i]] + value[i]</code> （物品i的价值），就是背包放物品i得到的最大价值</p>
</li>
</ul>
<ol>
<li>dp数组如何初始化</li>
</ol>
<p>首先从<code>dp[i][j]</code>的定义出发，如果背包容量j为0的话，即<code>dp[i][0]</code>，无论是选取哪些物品，背包价值总和一定为0。</p>
<p><code>dp[0][j]</code>，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。</p>
<p>那么很明显当 <code>j &lt; weight[0]</code>的时候，<code>dp[0][j]</code> 应该是 0，因为背包容量比编号0的物品重量还小。</p>
<p>当<code>j &gt;= weight[0]</code>时，<code>dp[0][j]</code> 应该是value[0]，因为背包容量放足够放编号0物品。</p>
<h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> dynamicProgram;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是`weight[i]`，</span></span><br><span class="line"><span class="comment"> * 得到的价值是`value[i]` 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BagProblem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">goods</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">bagSize</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] weight = <span class="keyword">new</span> <span class="title class_">int</span>[goods];</span><br><span class="line">        <span class="type">int</span>[] value = <span class="keyword">new</span> <span class="title class_">int</span>[goods];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; goods; i++) &#123;</span><br><span class="line">            weight[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; goods; i++) &#123;</span><br><span class="line">            value[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(testWeightBagProblem(weight, value, bagSize));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">testWeightBagProblem</span><span class="params">(<span class="type">int</span>[] weight, <span class="type">int</span>[] value, <span class="type">int</span> bagSize)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">goods</span> <span class="operator">=</span> weight.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[goods][bagSize + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> weight[<span class="number">0</span>]; j &lt;= bagSize; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; goods; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= bagSize; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[goods - <span class="number">1</span>][bagSize];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="动态规划：01背包理论基础-一维数组"><a href="#动态规划：01背包理论基础-一维数组" class="headerlink" title="动态规划：01背包理论基础 一维数组"></a>动态规划：01背包理论基础 一维数组</h2><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>对于背包问题其实状态都是可以压缩的。</p>
<p>在使用二维数组的时候，递推公式：<code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</code>;</p>
<p><strong>其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：<code>dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);</code></strong></p>
<p>与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了，只用dp[j]（一维数组，也可以理解是一个滚动数组）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br></pre></td></tr></table></figure>
<p><strong>倒序遍历是为了保证物品i只被放入一次！</strong>。但如果一旦正序遍历了，那么物品0就会被重复加入多次！</p>
<p>这和<code>j - weight[i]</code>有关</p>
<h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">testWeightBagProblemOneDimension</span><span class="params">(<span class="type">int</span>[] weight, <span class="type">int</span>[] value, <span class="type">int</span> bagSize)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">goods</span> <span class="operator">=</span> weight.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[bagSize + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; goods; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> bagSize; j &gt;= weight[i]; j--) &#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[bagSize];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a>416. 分割等和子集</h2><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><ul>
<li>背包的体积为sum / 2</li>
<li>背包要放入的商品（集合里的元素）重量为元素的数值，价值也为元素的数值</li>
<li>背包如果正好装满，说明找到了总和为 sum / 2 的子集。</li>
<li>背包中每一个元素是不可重复放入。</li>
</ul>
<h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(nums).sum();</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> sum /= <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//容量为sum的背包可以装多少容量</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[sum + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> sum; j &gt;= nums[i]; j--) &#123;</span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[sum] == sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1049-最后一块石头的重量II"><a href="#1049-最后一块石头的重量II" class="headerlink" title="1049.最后一块石头的重量II"></a>1049.最后一块石头的重量II</h2><p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p>
<p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p>
<ul>
<li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li>
<li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li>
</ul>
<p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code>0</code>。</p>
<h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><p>将石头尽可能的分成两堆重量相近的子集</p>
<p>用动态规划计算<code>sum/2</code>的容量最多可以装多少石块，然后两堆石块进行相减</p>
<h3 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(stones).sum();</span><br><span class="line">    <span class="type">int</span> <span class="variable">nums</span> <span class="operator">=</span> stones.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">capacities</span> <span class="operator">=</span> sum / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//容量为sum的背包最多可以装多少石头</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[capacities + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> capacities; j &gt;= stones[i]; j--) &#123;</span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum - dp[capacities] * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494.目标和"></a>494.目标和</h2><p>给你一个非负整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>
<p>向数组中的每个整数前添加 <code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p>
<ul>
<li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>&#39;+&#39;</code> ，在 <code>1</code> 之前添加 <code>&#39;-&#39;</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code> 。</li>
</ul>
<p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p>
<h3 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h3><p>假设加法的总和为x，那么减法对应的总和就是sum - x。</p>
<p>所以我们要求的是 <code>x - (sum - x) = target</code></p>
<p><code>x = (target + sum) / 2</code></p>
<ul>
<li>dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法</li>
<li>dp[0] 为 1。</li>
<li>后续遍历</li>
</ul>
<h3 id="代码实现-10"><a href="#代码实现-10" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> newTarget;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(nums).sum();<span class="comment">//x positive (sum -x) negtive</span></span><br><span class="line">    <span class="keyword">if</span> (Math.abs(target) &gt; sum) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((sum + target) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        newTarget = (sum + target) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[newTarget + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> newTarget; j &gt;= nums[i]; j--) &#123;</span><br><span class="line">            dp[j] += dp[j - nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[newTarget];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474.一和零"></a>474.一和零</h2><p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code> 。</p>
<p>请你找出并返回 <code>strs</code> 的最大子集的长度，该子集中 <strong>最多</strong> 有 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> 。</p>
<p>如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合 <code>x</code> 是集合 <code>y</code> 的 <strong>子集</strong> 。</p>
<h3 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h3><p>0-1背包，但是背包有二维</p>
<p>需要记录每个字符串的0和1的个数</p>
<h3 id="代码实现-11"><a href="#代码实现-11" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxForm</span><span class="params">(String[] strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] counts = <span class="keyword">new</span> <span class="title class_">int</span>[strs.length][<span class="number">2</span>];<span class="comment">//存储0，1的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">zeroNums</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oneNums</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> strs[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; str.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(j) == <span class="string">&#x27;0&#x27;</span>) zeroNums++;</span><br><span class="line">            <span class="keyword">else</span> oneNums++;</span><br><span class="line">        &#125;</span><br><span class="line">        counts[i][<span class="number">0</span>] = zeroNums;</span><br><span class="line">        counts[i][<span class="number">1</span>] = oneNums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不用特别初始化，满足条件才加1</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] count : counts) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m; i &gt;= count[<span class="number">0</span>]; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n; j &gt;= count[<span class="number">1</span>]; j--) &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i][j], dp[i - count[<span class="number">0</span>]][j - count[<span class="number">1</span>]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code_Musing</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>obs录屏技巧</title>
    <url>/2024/04/17/tips/obs%E5%BD%95%E5%B1%8F/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul>
<li>obs录屏模糊</li>
<li>屏幕抓取不全</li>
<li>录制桌面</li>
<li>俄罗斯套娃</li>
</ul>
<span id="more"></span>
<h3 id="obs录屏模糊"><a href="#obs录屏模糊" class="headerlink" title="obs录屏模糊"></a>obs录屏模糊</h3><p>查看自己电脑的屏幕分辨率，<strong>打开OBS&gt;设置&gt;视频，将基础和输出分辨率修改为和系统一样</strong></p>
<p>比如：3840*2160（4K）</p>
<h3 id="屏幕抓取不全"><a href="#屏幕抓取不全" class="headerlink" title="屏幕抓取不全"></a>屏幕抓取不全</h3><p>鼠标靠近屏幕&gt;右键&gt;变换&gt;比例适配屏幕</p>
<h3 id="录制桌面"><a href="#录制桌面" class="headerlink" title="录制桌面"></a>录制桌面</h3><p>添加显示器采集</p>
<h3 id="俄罗斯套娃"><a href="#俄罗斯套娃" class="headerlink" title="俄罗斯套娃"></a>俄罗斯套娃</h3><p>设置—&gt;常规中勾选“在屏幕采集中隐藏obs窗口”</p>
]]></content>
      <categories>
        <category>tips</category>
      </categories>
      <tags>
        <tag>obs</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录-动态规划2</title>
    <url>/2024/04/22/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p><strong>本节包括：</strong></p>
<ul>
<li>完全背包</li>
<li>打家劫舍</li>
<li>买卖股票</li>
</ul>
<span id="more"></span>
<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>
<p>完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先遍历物品，再遍历背包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> weight[i]; j &lt;= bagWeight ; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="52-携带研究材料"><a href="#52-携带研究材料" class="headerlink" title="52 携带研究材料"></a>52 携带研究材料</h2><p>小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的重量，并且具有不同的价值。</p>
<p>小明的行李箱所能承担的总重量为 N，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料可以选择无数次，并且可以重复选择。</p>
<p>第一行包含两个整数，N，V，分别表示研究材料的种类和行李空间 </p>
<p>接下来包含 N 行，每行两个整数 wi 和 vi，代表第 i 种研究材料的重量和价值</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarryingResearchMaterials</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">serials</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">bagSize</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[][] values = <span class="keyword">new</span> <span class="title class_">int</span>[serials][<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[bagSize + <span class="number">1</span>];<span class="comment">//dp[j]代表容量为j的背包能装的最大价值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; serials; i++) &#123;</span><br><span class="line">            values[i][<span class="number">0</span>] = scanner.nextInt();<span class="comment">//存储重量</span></span><br><span class="line">            values[i][<span class="number">1</span>] = scanner.nextInt();<span class="comment">//存储价值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; serials; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> values[i][<span class="number">0</span>]; j &lt;= bagSize; j++) &#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - values[i][<span class="number">0</span>]] + values[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[bagSize]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="518-零钱兑换II"><a href="#518-零钱兑换II" class="headerlink" title="518.零钱兑换II"></a>518.零钱兑换II</h2><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p>
<p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p>
<p>假设每一种面额的硬币有无限个。 </p>
<p>题目数据保证结果符合 32 位带符号整数。</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];<span class="comment">//存储amount=i时共有几种兑换方式</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; coins.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> coins[i]; j &lt;= amount; j++) &#123;</span><br><span class="line">            dp[j] += dp[j - coins[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a>377. 组合总和 Ⅳ</h2><p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p>
<p>题目数据保证答案符合 32 位整数范围。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3], target = 4</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">所有可能的组合为：</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br></pre></td></tr></table></figure>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">       <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target + <span class="number">1</span>];<span class="comment">//总数为target一共有多少种组合</span></span><br><span class="line">       dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= target; i++) &#123;<span class="comment">//遍历背包</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums.length; j++) &#123;<span class="comment">//遍历物品</span></span><br><span class="line">               <span class="keyword">if</span> (i &gt;= nums[j]) &#123;</span><br><span class="line">                   dp[i] += dp[i - nums[j]];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[target];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="70-爬楼梯（进阶版）"><a href="#70-爬楼梯（进阶版）" class="headerlink" title="70. 爬楼梯（进阶版）"></a>70. 爬楼梯（进阶版）</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬至多m (1 &lt;= m &lt; n)个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<p>输入描述：输入共一行，包含两个正整数，分别表示n, m</p>
<p>输出描述：输出一个整数，表示爬到楼顶的方法数。</p>
<p>输入示例：3 2</p>
<p>输出示例：3</p>
<p>提示：</p>
<p>当 m = 2，n = 3 时，n = 3 这表示一共有三个台阶，m = 2 代表你每次可以爬一个台阶或者两个台阶。</p>
<p>此时你有三种方法可以爬到楼顶。</p>
<ul>
<li>1 阶 + 1 阶 + 1 阶段</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ul>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StairClimb</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];<span class="comment">//楼梯为n阶移动有多少种爬楼梯方法</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;<span class="comment">//遍历楼梯</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">                    dp[i] += dp[i - j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a>322. 零钱兑换</h2><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul>
<li>凑足总额为j - coins[i]的最少个数为<code>dp[j - coins[i]]</code>，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]）</li>
<li>首先凑足总金额为0所需钱币的个数一定是0，那么<code>dp[0] = 0</code>;</li>
<li>dp[j]必须初始化为一个最大的数，否则就会在<code>min(dp[j - coins[i]] + 1, dp[j])</code>比较的过程中被初始值覆盖。</li>
</ul>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, amount + <span class="number">1</span>);<span class="comment">//dp[i]最大值是amount</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; coins.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> coins[i]; j &lt;= amount; j++) &#123;<span class="comment">//遍历amount</span></span><br><span class="line">            dp[j] = Math.min(dp[j], dp[j - coins[i]] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dp[amount] &gt; amount) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279.完全平方数"></a>279.完全平方数</h2><p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code> 的完全平方数的最少数量</em> 。</p>
<p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>完全平方数就是物品（可以无限件使用），凑个正整数n就是背包，问凑满这个背包最少有多少物品？</p>
<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumSquares</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, n);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i * i &lt;= n; i++) &#123;<span class="comment">//遍历物品</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i * i; j &lt;= n; j++) &#123;<span class="comment">//遍历背包</span></span><br><span class="line">                dp[j] = Math.min(dp[j], dp[j - i * i] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139.单词拆分"></a>139.单词拆分</h2><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 <code>s</code> 则返回 <code>true</code>。</p>
<p><strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以由 &quot;leet&quot; 和 &quot;code&quot; 拼接成。</span><br></pre></td></tr></table></figure>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。</p>
<p>如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j &lt; i ）。</p>
<p>所以递推公式是 if([j, i] 这个区间的子串出现在字典里 <code>&amp;&amp; dp[j]</code>是true) 那么 <code>dp[i] = true</code>。</p>
<h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">    HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordDict);</span><br><span class="line">    <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length() + <span class="number">1</span>];<span class="comment">//记录字符串位置i处是否可以拼接</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= s.length(); i++) &#123;<span class="comment">//遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i &amp;&amp; !dp[i]; j++) &#123;<span class="comment">//遍历单词</span></span><br><span class="line">            <span class="keyword">if</span> (set.contains(s.substring(j, i)) &amp;&amp; dp[j]) &#123;</span><br><span class="line">                dp[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198.打家劫舍"></a>198.打家劫舍</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p><strong>dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]</strong>。</p>
<ol>
<li>确定递推公式</li>
</ol>
<p>决定dp[i]的因素就是第i房间偷还是不偷。</p>
<p>如果偷第i房间，那么<code>dp[i] = dp[i - 2] + nums[i]</code> ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。</p>
<ol>
<li>dp数组如何初始化</li>
</ol>
<p>从递推公式dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);可以看出，递推公式的基础就是dp[0] 和 dp[1]</p>
<p>从dp[i]的定义上来讲，dp[0] 一定是 nums[0]，dp[1]就是nums[0]和nums[1]的最大值即：dp[1] = max(nums[0], nums[1]);</p>
<h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];<span class="comment">//考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]</span></span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="213-打家劫舍II"><a href="#213-打家劫舍II" class="headerlink" title="213.打家劫舍II"></a>213.打家劫舍II</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><ul>
<li><p>情况一：考虑不包含首尾元素</p>
</li>
<li><p>情况二：考虑包含首元素，不包含尾元素</p>
</li>
<li>情况三：考虑包含尾元素，不包含首元素</li>
</ul>
<p><strong>情况二 和 情况三 都包含了情况一了，所以只考虑情况二和情况三就可以了</strong>。</p>
<h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Robber2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">houses</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">return</span> Math.max(robAction(nums, <span class="number">0</span>, houses - <span class="number">2</span>), robAction(nums, <span class="number">1</span>, houses - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">robAction</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (end == start) <span class="keyword">return</span> nums[start];</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">dpIdx</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[start];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[start + <span class="number">1</span>], dp[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + <span class="number">2</span>; i &lt;= end; i++) &#123;</span><br><span class="line">            dp[dpIdx] = Math.max(dp[dpIdx - <span class="number">2</span>] + nums[i], dp[dpIdx - <span class="number">1</span>]);</span><br><span class="line">            dpIdx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337.打家劫舍 III"></a>337.打家劫舍 III</h2><p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 <code>root</code> 。</p>
<p>除了 <code>root</code> 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 <strong>两个直接相连的房子在同一天晚上被打劫</strong> ，房屋将自动报警。</p>
<p>给定二叉树的 <code>root</code> 。返回 <strong>*在不触动警报的情况下</strong> ，小偷能够盗取的最高金额* 。</p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>不能用后续遍历然后直接动态规划</p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/10/rob2-tree.jpg" alt="img" style="zoom:50%;" /></p>
<p>比如后续遍历：1、3、4、1、5、3，正确答案是4+5=9，而直接动态变为：1+4+5=10，那是因为如果不偷4，1和3可以偷，这与题意不符</p>
<p><strong>正确做法</strong></p>
<ol>
<li>dp数组（dp table）以及下标的含义：</li>
</ol>
<p><strong>下标为0记录不偷该节点所得到的的最大金钱，下标为1记录偷该节点所得到的的最大金钱。</strong></p>
<ol>
<li><p>在遍历的过程中，如果遇到空节点的话，很明显，无论偷还是不偷都是0，所以就返回</p>
</li>
<li><p>确定遍历顺序</p>
</li>
</ol>
<p>首先明确的是使用后序遍历。 因为要通过递归函数的返回值来做下一步计算。</p>
<p>通过递归左节点，得到左节点偷与不偷的金钱。</p>
<p>通过递归右节点，得到右节点偷与不偷的金钱。</p>
<h3 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Robber3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = robAction(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[<span class="number">0</span>], dp[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后续遍历，分情况讨论父子节点偷还是不偷</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] robAction(TreeNode root) &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];<span class="comment">//dp[0]不偷，dp[1]偷当前节点获取的金额</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> dp;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] leftDp = robAction(root.left);</span><br><span class="line">        <span class="type">int</span>[] rightDp = robAction(root.right);</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = Math.max(leftDp[<span class="number">0</span>], leftDp[<span class="number">1</span>]) + Math.max(rightDp[<span class="number">0</span>], rightDp[<span class="number">1</span>]);<span class="comment">//不偷获取的金额</span></span><br><span class="line">        dp[<span class="number">1</span>] = leftDp[<span class="number">0</span>] + rightDp[<span class="number">0</span>] + root.val;</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h2><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
<h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>贪心：遍历，选取当前股票最低谷，然后计算当前的利润和以往的利润，取最大值，直到遍历完毕。</p>
<h3 id="代码实现1"><a href="#代码实现1" class="headerlink" title="代码实现1"></a>代码实现1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> prices[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">profit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        low = Math.min(low, prices[i]);</span><br><span class="line">        profit = Math.max(profit, prices[i] - low);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>动态规划：</p>
<p><code>dp[i][0]</code> 表示第i天持有股票所得最多现金</p>
<p><code>dp[i][1]</code> 表示第i天不持有股票所得最多现金</p>
<p>效率太低且繁琐</p>
<h3 id="代码实现2"><a href="#代码实现2" class="headerlink" title="代码实现2"></a>代码实现2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfitDP</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="comment">//`dp[i][0]` 表示第i天持有股票所得最多现金</span></span><br><span class="line">    <span class="comment">//`dp[i][1]` 表示第i天不持有股票所得最多现金</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i]);<span class="comment">//i-1天持有股票，i-1天没有股票</span></span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);<span class="comment">///i-1天没有股票，第i卖股票</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(dp[prices.length - <span class="number">1</span>][<span class="number">0</span>], dp[prices.length - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="122-买卖股票的最佳时机II"><a href="#122-买卖股票的最佳时机II" class="headerlink" title="122.买卖股票的最佳时机II"></a>122.买卖股票的最佳时机II</h2><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p>
<p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p>
<p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p>
<h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>贪心：只选取获利两天进行购买和出售</p>
<p>动态规划：类似<code>买卖股票的最佳时机</code>，只不过可以多次购买和卖出</p>
<h3 id="代码实现-10"><a href="#代码实现-10" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">profit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (tmp &gt; <span class="number">0</span>) profit += tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfitDp</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="comment">//`dp[i][0]` 表示第i天持有股票所得最多现金</span></span><br><span class="line">    <span class="comment">//`dp[i][1]` 表示第i天不持有股票所得最多现金</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);<span class="comment">//i-1天持有股票，i-1天没有股票</span></span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);<span class="comment">///i-1天没有股票，第i卖股票</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(dp[prices.length - <span class="number">1</span>][<span class="number">0</span>], dp[prices.length - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="123-买卖股票的最佳时机III"><a href="#123-买卖股票的最佳时机III" class="headerlink" title="123.买卖股票的最佳时机III"></a>123.买卖股票的最佳时机III</h2><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p><strong>动态数组定义：</strong></p>
<p>一天一共就有五个状态，</p>
<p>没有操作 （其实我们也可以不设置这个状态）</p>
<ol>
<li>第一次持有股票</li>
<li>第一次不持有股票</li>
<li>第二次持有股票</li>
<li>第二次不持有股票</li>
</ol>
<p>达到<code>dp[i][1]</code>状态，有两个具体操作：</p>
<ul>
<li>操作一：第i天买入股票了，那么<code>dp[i][1] = dp[i-1][0] - prices[i]</code></li>
<li>操作二：第i天没有操作，而是沿用前一天买入的状态，即：<code>dp[i][1] = dp[i - 1][1]</code></li>
</ul>
<p>同理<code>dp[i][2]</code>也有两个操作：</p>
<ul>
<li>操作一：第i天卖出股票了，那么<code>dp[i][2] = dp[i - 1][1] + prices[i]</code></li>
<li>操作二：第i天没有操作，沿用前一天卖出股票的状态，即：<code>dp[i][2] = dp[i - 1][2]</code></li>
</ul>
<p>其他类似……</p>
<p><strong>初始化：</strong></p>
<p>第0天做第一次买入的操作，<code>dp[0][1] = -prices[0];</code></p>
<p>第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后再买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。</p>
<p>所以第二次买入操作，初始化为：<code>dp[0][3] = -prices[0];</code></p>
<h3 id="代码实现-11"><a href="#代码实现-11" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="comment">//0. 没有操作 （其实我们也可以不设置这个状态）</span></span><br><span class="line">    <span class="comment">//1. 第一次持有股票</span></span><br><span class="line">    <span class="comment">//2. 第一次不持有股票</span></span><br><span class="line">    <span class="comment">//3. 第二次持有股票</span></span><br><span class="line">    <span class="comment">//4. 第二次不持有股票</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">5</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">3</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        dp[i][<span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">        dp[i][<span class="number">3</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">        dp[i][<span class="number">4</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">4</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>] + prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="188-买卖股票的最佳时机IV"><a href="#188-买卖股票的最佳时机IV" class="headerlink" title="188.买卖股票的最佳时机IV"></a>188.买卖股票的最佳时机IV</h2><p>给你一个整数数组 <code>prices</code> 和一个整数 <code>k</code> ，其中 <code>prices[i]</code> 是某支给定的股票在第 <code>i</code> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <code>k</code> 笔交易。也就是说，你最多可以买 <code>k</code> 次，卖 <code>k</code> 次。</p>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><p>类似<code>买卖股票的最佳时机III</code>，只不过总结规律</p>
<h3 id="代码实现-12"><a href="#代码实现-12" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="comment">//dp[i][0]什么都不做</span></span><br><span class="line">    <span class="comment">//dp[i][2*k-1]第k次买入股票</span></span><br><span class="line">    <span class="comment">//dp[i][2*k]第k次卖出股票</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][k * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span> * i - <span class="number">1</span>] = -prices[<span class="number">0</span>];<span class="comment">//初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            dp[i][j * <span class="number">2</span> - <span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][j * <span class="number">2</span> - <span class="number">1</span>], dp[i - <span class="number">1</span>][j * <span class="number">2</span> - <span class="number">2</span>] - prices[i]);<span class="comment">//买入</span></span><br><span class="line">            dp[i][j * <span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][j * <span class="number">2</span>], dp[i - <span class="number">1</span>][j * <span class="number">2</span> - <span class="number">1</span>] + prices[i]);<span class="comment">//卖出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">2</span> * k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309.最佳买卖股票时机含冷冻期"></a>309.最佳买卖股票时机含冷冻期</h2><p>给定一个整数数组<code>prices</code>，其中第 <code>prices[i]</code> 表示第 <code>*i*</code> 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p><code>dp[i][j]</code>，第i天状态为j，所剩的最多现金为<code>dp[i][j]</code>。</p>
<p>具体可以区分出如下四个状态：</p>
<ul>
<li>状态一：持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）</li>
<li>不持有股票状态，这里就有两种卖出股票状态<ul>
<li>状态二：保持卖出股票的状态（两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作）</li>
<li>状态三：今天卖出股票</li>
</ul>
</li>
<li>状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！</li>
</ul>
<p><a href="https://www.programmercarl.com/0309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F.html#%E6%80%9D%E8%B7%AF">递推公式</a></p>
<h3 id="代码实现-13"><a href="#代码实现-13" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * - 状态一：持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）</span></span><br><span class="line"><span class="comment">     * - 不持有股票状态，这里就有两种卖出股票状态</span></span><br><span class="line"><span class="comment">     *     - 状态二：保持卖出股票的状态（两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作）</span></span><br><span class="line"><span class="comment">     *     - 状态三：今天卖出股票</span></span><br><span class="line"><span class="comment">     * - 状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">4</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], Math.max(dp[i - <span class="number">1</span>][<span class="number">3</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]));</span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line">        dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">        dp[i][<span class="number">3</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(dp[prices.length - <span class="number">1</span>][<span class="number">3</span>], Math.max(dp[prices.length - <span class="number">1</span>][<span class="number">1</span>], dp[prices.length - <span class="number">1</span>][<span class="number">2</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714.买卖股票的最佳时机含手续费"></a>714.买卖股票的最佳时机含手续费</h2><p>给定一个整数数组 <code>prices</code>，其中 <code>prices[i]</code>表示第 <code>i</code> 天的股票价格 ；整数 <code>fee</code> 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p><strong>注意：</strong>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [1, 3, 2, 8, 4, 9], fee = 2</span><br><span class="line">输出：8</span><br><span class="line">解释：能够达到的最大利润:  </span><br><span class="line">在此处买入 prices[0] = 1</span><br><span class="line">在此处卖出 prices[3] = 8</span><br><span class="line">在此处买入 prices[4] = 4</span><br><span class="line">在此处卖出 prices[5] = 9</span><br><span class="line">总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8</span><br></pre></td></tr></table></figure>
<h3 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h3><p><code>dp[i][0]</code> 表示第i天持有股票所省最多现金。 <code>dp[i][1]</code> 表示第i天不持有股票所得最多现金</p>
<h3 id="代码实现-14"><a href="#代码实现-14" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> &#123;</span><br><span class="line">    <span class="type">int</span> dp[][] = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];<span class="comment">//0持有股票</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//1卖出股票</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i] - fee);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300.最长递增子序列"></a>300.最长递增子序列</h2><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code>是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>
<h3 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h3><p><strong>dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度</strong></p>
<p>最终结果不一定是<code>dp[nums.length-1]</code>处取得最大值，最长递增子序列不一定包含组后一个数。</p>
<p>位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。</p>
<p>所以：<code>if (nums[i] &gt; nums[j]) dp[i] = max(dp[i], dp[j] + 1);</code></p>
<h3 id="代码实现-15"><a href="#代码实现-15" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];<span class="comment">//dp[i]以i为结尾的序列的最长递增子序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; maxLen) maxLen = dp[i];<span class="comment">//更新当前最长递增子序列长度</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code_Musing</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>docker初学</title>
    <url>/2024/05/20/docker/docker/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<p>docker的一些基本知识</p>
<span id="more"></span>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://docker-practice.github.io/zh-cn/">Docker — 从入门到实践</a></p>
<h2 id="docker初识"><a href="#docker初识" class="headerlink" title="docker初识"></a>docker初识</h2><p><strong>Docker</strong> 使用 <code>Google</code> 公司推出的 <a href="https://golang.google.cn/">Go 语言</a> 进行开发实现，基于 <code>Linux</code> 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups">cgroup</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces">namespace</a>，以及 <a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/">OverlayFS</a> 类的 <a href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a> 等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization">操作系统层面的虚拟化技术</a>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 <a href="https://linuxcontainers.org/lxc/introduction/">LXC</a>，从 <code>0.7</code> 版本以后开始去除 <code>LXC</code>，转而使用自行开发的 <a href="https://github.com/docker/libcontainer">libcontainer</a>，从 <code>1.11</code> 版本开始，则进一步演进为使用 <a href="https://github.com/opencontainers/runc">runC</a> 和 <a href="https://github.com/containerd/containerd">containerd</a>。</p>
<p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h3><p>操作系统分为 <strong>内核</strong> 和 <strong>用户空间</strong>。对于 <code>Linux</code> 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 <strong>Docker 镜像</strong>（<code>Image</code>），就相当于是一个 <code>root</code> 文件系统。比如官方镜像 <code>ubuntu:18.04</code> 就包含了完整的一套 Ubuntu 18.04 最小系统的 <code>root</code> 文件系统。</p>
<p><strong>Docker 镜像</strong> 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 <strong>不包含</strong> 任何动态数据，其内容在构建之后也不会被改变。</p>
<h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<h2 id="建立-docker-用户组"><a href="#建立-docker-用户组" class="headerlink" title="建立 docker 用户组"></a>建立 docker 用户组</h2><p>建立 <code>docker</code> 组：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo groupadd docker</span><br></pre></td></tr></table></figure>
<p>使用以下命令来查看 Docker 用户组的成员：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep docker /etc/group</span><br></pre></td></tr></table></figure>
<p>将当前用户加入 <code>docker</code> 组：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure>
<p>退出当前终端并重新登录，进行如下测试。</p>
<h2 id="使用-Docker-镜像"><a href="#使用-Docker-镜像" class="headerlink" title="使用 Docker 镜像"></a>使用 Docker 镜像</h2><h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><p><a href="https://hub.docker.com/search?q=&amp;type=image">Docker Hub</a> 上有大量的高质量的镜像可以用</p>
<p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。其命令格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu:18.04</span><br></pre></td></tr></table></figure>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it --<span class="built_in">rm</span> ubuntu:18.04 bash</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li>
<li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li>
<li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</li>
<li><code>bash</code>：放在镜像名后的是 <strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li>
</ul>
<h2 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
<h3 id="镜像体积"><a href="#镜像体积" class="headerlink" title="镜像体积"></a>镜像体积</h3><p>可以通过 <code>docker system df</code> 命令来便捷的查看镜像、容器、数据卷所占用的空间。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker system <span class="built_in">df</span></span><br></pre></td></tr></table></figure>
<h3 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB</span><br></pre></td></tr></table></figure>
<p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure>
<h3 id="中间层镜像"><a href="#中间层镜像" class="headerlink" title="中间层镜像"></a>中间层镜像</h3><p>为了加速镜像构建、重复利用资源，Docker 会利用 <strong>中间层镜像</strong>。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 <code>docker image ls</code> 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 <code>-a</code> 参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image <span class="built_in">ls</span> -a</span><br></pre></td></tr></table></figure>
<h2 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h2><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image <span class="built_in">rm</span> [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure>
<h3 id="短id"><a href="#短id" class="headerlink" title="短id"></a>短id</h3><p>我们可以用镜像的完整 ID，也称为 <code>长 ID</code>，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 <code>短 ID</code> 来删除镜像。<code>docker image ls</code> 默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image <span class="built_in">rm</span> 501</span><br></pre></td></tr></table></figure>
<h3 id="镜像名"><a href="#镜像名" class="headerlink" title="镜像名"></a>镜像名</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image <span class="built_in">rm</span> centos</span><br></pre></td></tr></table></figure>
<h2 id="使用-Dockerfile-定制镜像"><a href="#使用-Dockerfile-定制镜像" class="headerlink" title="使用 Dockerfile 定制镜像"></a>使用 Dockerfile 定制镜像</h2><p>在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> mynginx</span><br><span class="line"><span class="built_in">cd</span> mynginx</span><br><span class="line"><span class="built_in">touch</span> Dockerfile</span><br></pre></td></tr></table></figure>
<p>其内容为：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个 Dockerfile 指定了使用 nginx 镜像作为基础镜像，并在容器启动时执行了一个命令来创建一个包含 “Hello, Docker!” 的 HTML 文件。</p>
</blockquote>
<p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 <code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br></pre></td></tr></table></figure>
<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>在 <code>Dockerfile</code> 文件所在目录执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t nginx:v3 .</span><br></pre></td></tr></table></figure>
<p>从标准输入中读取上下文压缩包进行构建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build - &lt; context.tar.gz</span><br></pre></td></tr></table></figure>
<h2 id="Dockerifle参考"><a href="#Dockerifle参考" class="headerlink" title="Dockerifle参考"></a>Dockerifle参考</h2><h3 id="seal-python"><a href="#seal-python" class="headerlink" title="seal-python"></a>seal-python</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># define the folder where our src should exist/ be deposited</span></span><br><span class="line"><span class="keyword">ARG</span> SRC=/python-seal</span><br><span class="line"></span><br><span class="line"><span class="comment"># prevents update and install asking for tz</span></span><br><span class="line"><span class="keyword">ENV</span> DEBIAN_FRONTEND=noninteractive</span><br><span class="line"></span><br><span class="line"><span class="comment"># install dependencies</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt install -y git build-essential cmake python3 python3-dev python3-pip &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">mkdir</span> -p <span class="variable">$&#123;SRC&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># copy into container requirements and install them before rest of code</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip3 install numpy pybind11</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># copy everything into container now that requirements stage is complete</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . <span class="variable">$&#123;SRC&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># setting our default directory to the one specified above</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$&#123;SRC&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># update submodules</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> <span class="variable">$&#123;SRC&#125;</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    git submodule update --init --recursive</span></span><br><span class="line">    <span class="comment"># git submodule update --remote</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># build and install seal + bindings</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> <span class="variable">$&#123;SRC&#125;</span>/SEAL &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    cmake -S . -B build -DSEAL_USE_MSGSL=OFF -DSEAL_USE_ZLIB=OFF -DSEAL_USE_ZSTD=OFF &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    cmake --build build &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">cd</span> <span class="variable">$&#123;SRC&#125;</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    python3 setup.py build_ext -i</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/usr/bin/python3&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<h2 id="Dockerfile-指令详解"><a href="#Dockerfile-指令详解" class="headerlink" title="Dockerfile 指令详解"></a>Dockerfile 指令详解</h2><h3 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h3><p>格式：</p>
<ul>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></li>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li>
</ul>
<p><code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如：</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> package.json /usr/src/app/</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">COPY --<span class="built_in">chown</span>=55:mygroup files* /mydir/</span><br><span class="line">COPY --<span class="built_in">chown</span>=bin files* /mydir/</span><br><span class="line">COPY --<span class="built_in">chown</span>=1 files* /mydir/</span><br><span class="line">COPY --<span class="built_in">chown</span>=10:11 files* /mydir/</span><br></pre></td></tr></table></figure>
<p>如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径。</p>
<h3 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h3><p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p>
<ul>
<li><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></li>
<li><code>exec</code> 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li>
<li>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li>
</ul>
<p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，<code>ubuntu</code> 镜像默认的 <code>CMD</code> 是 <code>/bin/bash</code>，如果我们直接 <code>docker run -it ubuntu</code> 的话，会直接进入 <code>bash</code>。我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>。这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了，输出了系统版本信息。</p>
<p>如果使用 <code>shell</code> 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> <span class="variable">$HOME</span></span></span><br></pre></td></tr></table></figure>
<p>在实际执行中，会将其变更为：</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo <span class="variable">$HOME</span>&quot;</span> ]</span></span><br></pre></td></tr></table></figure>
<p>Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 <code>systemd</code> 去启动后台服务，容器内没有后台服务的概念。</p>
<p>一些初学者将 <code>CMD</code> 写为：</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> service nginx start</span></span><br></pre></td></tr></table></figure>
<p>然后发现容器执行后就立即退出了。甚至在容器内去使用 <code>systemctl</code> 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p>
<p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p>
<p>而使用 <code>service nginx start</code> 命令，则是希望 upstart 来以后台守护进程形式启动 <code>nginx</code> 服务。而刚才说了 <code>CMD service nginx start</code> 会被理解为 <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code>，因此主进程实际上是 <code>sh</code>。那么当 <code>service nginx start</code> 命令结束后，<code>sh</code> 也就结束了，<code>sh</code> 作为主进程退出了，自然就会令容器退出。</p>
<p>正确的做法是直接执行 <code>nginx</code> 可执行文件，并且要求以前台形式运行。比如：</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<h3 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h3><h4 id="场景一：让镜像变成像命令一样使用"><a href="#场景一：让镜像变成像命令一样使用" class="headerlink" title="场景一：让镜像变成像命令一样使用"></a>场景一：让镜像变成像命令一样使用</h4><p>假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 <code>CMD</code> 来实现：</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get install -y curl \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-s&quot;</span>, <span class="string">&quot;http://myip.ipip.net&quot;</span> ]</span></span><br></pre></td></tr></table></figure>
<p>假如我们使用 <code>docker build -t myip .</code> 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run myip</span><br></pre></td></tr></table></figure>
<p>这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 <code>CMD</code> 中可以看到实质的命令是 <code>curl</code>，那么如果我们希望显示 HTTP 头信息，就需要加上 <code>-i</code> 参数。那么我们可以直接加 <code>-i</code> 参数给 <code>docker run myip</code> 么？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run myip -i</span><br><span class="line">docker: Error response from daemon: invalid header field value <span class="string">&quot;oci runtime error: container_linux.go:247: starting container process caused \&quot;exec: \\\&quot;-i\\\&quot;: executable file not found in <span class="variable">$PATH</span>\&quot;\n&quot;</span>.</span><br></pre></td></tr></table></figure>
<p>我们可以看到可执行文件找不到的报错，<code>executable file not found</code>。之前我们说过，跟在镜像名后面的是 <code>command</code>，运行时会替换 <code>CMD</code> 的默认值。因此这里的 <code>-i</code> 替换了原来的 <code>CMD</code>，而不是添加在原来的 <code>curl -s http://myip.ipip.net</code> 后面。而 <code>-i</code> 根本不是命令，所以自然找不到。</p>
<p>那么如果我们希望加入 <code>-i</code> 这参数，我们就必须重新完整的输入这个命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run myip curl -s http://myip.ipip.net -i</span><br></pre></td></tr></table></figure>
<p>这显然不是很好的解决方案，而使用 <code>ENTRYPOINT</code> 就可以解决这个问题。现在我们重新用 <code>ENTRYPOINT</code> 来实现这个镜像：</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get install -y curl \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [ <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-s&quot;</span>, <span class="string">&quot;http://myip.ipip.net&quot;</span> ]</span></span><br></pre></td></tr></table></figure>
<p>这次我们再来尝试直接使用 <code>docker run myip -i</code>：</p>
<h3 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h3><p>格式有两种：</p>
<ul>
<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>
<li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li>
</ul>
<p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 <code>RUN</code>，还是运行时的应用，都可以直接使用这里定义的环境变量。</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> VERSION=<span class="number">1.0</span> DEBUG=on \</span><br><span class="line">    NAME=<span class="string">&quot;Happy Feet&quot;</span></span><br></pre></td></tr></table></figure>
<p>定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 <code>node</code> 镜像 <code>Dockerfile</code> 中，就有类似这样的代码：</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> NODE_VERSION <span class="number">7.2</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/SHASUMS256.txt.asc&quot;</span> \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; grep <span class="string">&quot; node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz\$&quot;</span> SHASUMS256.txt | <span class="built_in">sha256sum</span> -c - \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; tar -xJf <span class="string">&quot;node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> -C /usr/local --strip-components=1 \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">rm</span> <span class="string">&quot;node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> SHASUMS256.txt.asc SHASUMS256.txt \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">ln</span> -s /usr/local/bin/node /usr/local/bin/nodejs</span></span><br></pre></td></tr></table></figure>
<p>在这里先定义了环境变量 <code>NODE_VERSION</code>，其后的 <code>RUN</code> 这层里，多次使用 <code>$NODE_VERSION</code> 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 <code>7.2.0</code> 即可，<code>Dockerfile</code> 构建维护变得更轻松了。</p>
<h3 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h3><p>格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p>
<p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</p>
<p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p>
<blockquote>
<p>这样做的目的通常是在构建镜像时提供一些动态的值，例如镜像版本、构建环境等，而不将这些敏感信息暴露给容器的运行时环境。相比之下，使用 <code>ENV</code> 指令设置的环境变量会在容器运行时持续存在。</p>
</blockquote>
<p>ARG 指令有生效范围，如果在 <code>FROM</code> 指令之前指定，那么只能用于 <code>FROM</code> 指令中。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只在 FROM 中生效</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> $&#123;DOCKER_USERNAME&#125;/alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要想在 FROM 之后使用，必须再次指定</span></span><br><span class="line"><span class="keyword">ARG</span> DOCKER_USERNAME=library</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x ; <span class="built_in">echo</span> <span class="variable">$&#123;DOCKER_USERNAME&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>构建时会输出：<code>=&gt; CACHED [2/2] RUN set -x ; echo library</code></p>
<p><code>docker run ...</code> 不会有输出结果</p>
<h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h3><p>为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 <code>Dockerfile</code> 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> /app/data</span></span><br></pre></td></tr></table></figure>
<p><code>data</code> 目录就会在容器运行时自动挂载为匿名卷，任何向 <code>/data</code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行容器时可以覆盖这个挂载设置。比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it --<span class="built_in">rm</span> -v $(<span class="built_in">pwd</span>)/data:/app/data work_dir</span><br></pre></td></tr></table></figure>
<p>这里的宿主机和容器一定要是绝对路径</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p /app/data  <span class="comment"># 创建 data 目录</span></span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> /app/data  <span class="comment"># 声明挂载点</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; world.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">touch</span> a.bxt</span></span><br></pre></td></tr></table></figure>
<h3 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a>EXPOSE 声明端口</h3><p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p>
<p><code>EXPOSE</code> 指令是声明容器运行时提供服务的端口，这只是一个声明，在容器运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</p>
<p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p>
<h3 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h3><figure class="highlight docker"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; world.txt</span></span><br></pre></td></tr></table></figure>
<p>如果将这个 <code>Dockerfile</code> 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code>。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；<strong>而在 <code>Dockerfile</code> 中，这两行 <code>RUN</code> 命令的执行环境根本不同，是两个完全不同的容器。这就是对 <code>Dockerfile</code> 构建分层存储的概念不了解所导致的错误。</strong></p>
<p>之前说过每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p>
<p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; world.txt</span></span><br></pre></td></tr></table></figure>
<p>构建和运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t workdir_demo .</span><br><span class="line">docker run -it --<span class="built_in">rm</span> workdir_demo</span><br></pre></td></tr></table></figure>
<p>建议多使用<code>--rm</code>，避免容器越来越多</p>
<h3 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h3><p>USER 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> groupadd -r redis &amp;&amp; useradd -r -g redis redis</span></span><br><span class="line"><span class="keyword">USER</span> redis</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [ <span class="string">&quot;redis-server&quot;</span> ]</span></span><br></pre></td></tr></table></figure>
<p>如果以 <code>root</code> 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 <code>su</code> 或者 <code>sudo</code>，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 <a href="https://github.com/tianon/gosu"><code>gosu</code></a>。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> groupadd -r redis &amp;&amp; useradd -r -g redis redis</span></span><br><span class="line"><span class="comment"># 下载 gosu</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -O /usr/local/bin/gosu <span class="string">&quot;https://github.com/tianon/gosu/releases/download/1.12/gosu-amd64&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">chmod</span> +x /usr/local/bin/gosu \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; gosu nobody <span class="literal">true</span></span></span><br><span class="line"><span class="comment"># 设置 CMD，并以另外的用户执行</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;exec&quot;</span>, <span class="string">&quot;gosu&quot;</span>, <span class="string">&quot;redis&quot;</span>, <span class="string">&quot;redis-server&quot;</span> ]</span></span><br></pre></td></tr></table></figure>
<h3 id="HEALTHCHECK-健康检查"><a href="#HEALTHCHECK-健康检查" class="headerlink" title="HEALTHCHECK 健康检查"></a>HEALTHCHECK 健康检查</h3><ul>
<li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>：设置检查容器健康状况的命令</li>
<li><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</li>
</ul>
<p><code>HEALTHCHECK</code> 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12 引入的新指令。</p>
<p>和 <code>CMD</code>, <code>ENTRYPOINT</code> 一样，<code>HEALTHCHECK</code> 只可以出现一次，如果写了多个，只有最后一个生效。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> --interval=5s --<span class="built_in">timeout</span>=3s \</span></span><br><span class="line"><span class="language-bash">  CMD curl -fs http://localhost/ || <span class="built_in">exit</span> 1</span></span><br></pre></td></tr></table></figure>
<p>这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 3 秒没响应就视为失败，并且使用 <code>curl -fs http://localhost/ || exit 1</code> 作为健康检查命令。</p>
<p>构建这个镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t myweb:v1 .</span><br></pre></td></tr></table></figure>
<p>构建好了后，我们启动一个容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name web -p 80:80 --<span class="built_in">rm</span> myweb:v1</span><br></pre></td></tr></table></figure>
<p>在等待几秒钟后，再次 <code>docker container ls</code>，就会看到健康状态变化为了 <code>(healthy)</code>：</p>
<p>为了帮助排障，健康检查命令的输出（包括 <code>stdout</code> 以及 <code>stderr</code>）都会被存储于健康状态里，可以用 <code>docker inspect</code> 来查看。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect --format <span class="string">&#x27;&#123;&#123;json .State.Health&#125;&#125;&#x27;</span> web | python -m json.tool</span><br></pre></td></tr></table></figure>
<p>停止容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop web</span><br></pre></td></tr></table></figure>
<h3 id="ONBUILD-为他人做嫁衣裳"><a href="#ONBUILD-为他人做嫁衣裳" class="headerlink" title="ONBUILD 为他人做嫁衣裳"></a>ONBUILD 为他人做嫁衣裳</h3><p><code>ONBUILD</code> 是一个特殊的指令，它后面跟的是其它指令，比如 <code>RUN</code>, <code>COPY</code> 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p>
<p><strong>基础镜像</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:slim</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">COPY</span><span class="language-bash"> ./package.json /app</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">RUN</span><span class="language-bash"> [ <span class="string">&quot;npm&quot;</span>, <span class="string">&quot;install&quot;</span> ]</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">COPY</span><span class="language-bash"> . /app/</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;npm&quot;</span>, <span class="string">&quot;start&quot;</span> ]</span></span><br></pre></td></tr></table></figure>
<p><strong>应用镜像</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> my-node</span><br></pre></td></tr></table></figure>
<p>当在各个项目目录中，用这个只有一行的 <code>Dockerfile</code> 构建镜像时，之前基础镜像的那三行 <code>ONBUILD</code> 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对本项目执行 <code>npm install</code>，生成应用镜像。</p>
<h3 id="LABEL-指令"><a href="#LABEL-指令" class="headerlink" title="LABEL 指令"></a>LABEL 指令</h3><p><code>LABEL</code> 指令用来给镜像以键值对的形式添加一些元数据（metadata）。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span></span><br></pre></td></tr></table></figure>
<p>我们还可以用一些标签来申明镜像的作者、文档地址等：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> org.opencontainers.image.authors=<span class="string">&quot;yeasy&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> org.opencontainers.image.documentation=<span class="string">&quot;https://yeasy.gitbooks.io&quot;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="SHELL-指令"><a href="#SHELL-指令" class="headerlink" title="SHELL 指令"></a>SHELL 指令</h3><p>格式：<code>SHELL [&quot;executable&quot;, &quot;parameters&quot;]</code></p>
<p>SHELL<code>指令可以指定</code>RUN<code>`ENTRYPOINT</code> <code>CMD</code> 指令的 shell，Linux 中默认为 `[“/bin/sh”, “-c”]</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。</p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>exited</code>）的容器重新启动。</p>
<p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p>
<h4 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h4><p>所需要的命令主要为 <code>docker run</code>。</p>
<p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run ubuntu:18.04 /bin/echo <span class="string">&#x27;Hello world&#x27;</span></span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure>
<h4 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h4><p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止（<code>exited</code>）的容器启动运行。</p>
<h3 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h3><p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d ubuntu:18.04 /bin/sh -c <span class="string">&quot;while true; do echo hello world; sleep 1; done&quot;</span></span><br></pre></td></tr></table></figure>
<p>要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container logs [container ID or NAMES]</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container logs web</span><br></pre></td></tr></table></figure>
<h3 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h3><p>可以使用 <code>docker container stop</code> 来终止一个运行中的容器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container stop web</span><br></pre></td></tr></table></figure>
<p>终止状态的容器可以用 <code>docker container ls -a</code> 命令看到。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container <span class="built_in">ls</span> -a</span><br></pre></td></tr></table></figure>
<h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。</p>
<p>某些时候需要进入容器进行操作，包括使用 <code>docker attach</code> 命令或 <code>docker exec</code> 命令，推荐大家使用 <code>docker exec</code> 命令，原因会在下面说明。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -dit ubuntu:18.04</span><br><span class="line">-------------------------------------------</span><br><span class="line">(base) ➜  container_demo docker container <span class="built_in">ls</span></span><br><span class="line">CONTAINER ID   IMAGE                                     COMMAND                   CREATED         STATUS                PORTS                                   NAMES</span><br><span class="line">326c1f3e8643   ubuntu:18.04                              <span class="string">&quot;/bin/bash&quot;</span>               6 seconds ago   Up 5 seconds                                                  funny_lovelace</span><br><span class="line">-------------------------------------------</span><br><span class="line">docker <span class="built_in">exec</span> -it 326 bash</span><br></pre></td></tr></table></figure>
<p>如果从这个 stdin 中 exit，不会导致容器的停止（docker attach会停止容器）。这就是为什么推荐大家使用 <code>docker exec</code> 的原因。</p>
<h3 id="导入和导出"><a href="#导入和导出" class="headerlink" title="导入和导出"></a>导入和导出</h3><h4 id="导出容器export"><a href="#导出容器export" class="headerlink" title="导出容器export"></a>导出容器export</h4><p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">export</span> bb5 &gt; ubuntu18.tar</span><br></pre></td></tr></table></figure>
<p><strong><code>docker export</code></strong>:</p>
<ul>
<li>导出一个容器的文件系统为一个 tar 包。</li>
<li>这个命令不包含容器的元数据（例如 Docker 镜像的历史记录、容器的配置信息等）。</li>
</ul>
<h4 id="导出容器save-recommend"><a href="#导出容器save-recommend" class="headerlink" title="导出容器save recommend"></a>导出容器save recommend</h4><ol>
<li><strong><code>docker save</code></strong>:<ul>
<li>保存一个或多个镜像为一个 tar 包。</li>
<li>这个命令包含镜像的所有层和元数据，适用于导出和共享 Docker 镜像。</li>
<li><code>docker save</code> 通常用于将镜像保存为 tar 文件，然后可以用 <code>docker load</code> 恢复。</li>
<li>示例用法：<code>docker save -o my_image.tar my_image:tag</code></li>
</ul>
</li>
</ol>
<h4 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h4><p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ubuntu18.tar | docker import - <span class="built_in">test</span>/ubunntu:1.0</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker load -i ubuntu18.tar</span><br></pre></td></tr></table></figure>
<ul>
<li><code>docker load</code> 命令是从一个 tar 文件加载一个完整的 Docker 镜像，包括所有的元数据。</li>
<li>它能够完全恢复镜像的所有状态和信息，确保导入的镜像和原始镜像完全一致。</li>
</ul>
<p>启动镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -dit --name test_ubuntu --<span class="built_in">rm</span> <span class="built_in">test</span>/ubuntu:1.0 bash</span><br><span class="line">911ae74f13732a0ff1b76cb44e174313dd6ccbe96a4a168b1b288b5a03ffd38c</span><br></pre></td></tr></table></figure>
<p>进入镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 911 bash</span><br><span class="line">docker <span class="built_in">exec</span> -it test_ubuntu bash</span><br></pre></td></tr></table></figure>
<p>停止容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container stop test_ubuntu </span><br></pre></td></tr></table></figure>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>可以使用 <code>docker container rm</code> 来删除一个处于终止状态的容器。例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker container <span class="built_in">rm</span> trusting_newton</span><br></pre></td></tr></table></figure>
<p>清理所有处于终止状态的容器，用 <code>docker container ls -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container prune</span><br></pre></td></tr></table></figure>
<h2 id="访问仓库"><a href="#访问仓库" class="headerlink" title="访问仓库"></a>访问仓库</h2><h3 id="docker-hub"><a href="#docker-hub" class="headerlink" title="docker hub"></a>docker hub</h3><h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h4><p>可以通过执行 <code>docker login</code> 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。</p>
<p>你可以通过 <code>docker logout</code> 退出登录。</p>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>可以通过 <code>docker search</code> 命令来查找官方仓库中的镜像，并利用 <code>docker pull</code> 命令来将它下载到本地。</p>
<p>另外，在查找的时候通过 <code>--filter=stars=N</code> 参数可以指定仅显示收藏数量为 <code>N</code> 以上的镜像。</p>
<h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></table></figure>
<h4 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h4><p>用户也可以在登录后通过 <code>docker push</code> 命令来将自己的镜像推送到 Docker Hub。</p>
<p>以下命令中的 <code>username</code> 请替换为你的 Docker 账号用户名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker tag ubuntu:18.04 username/ubuntu:18.04</span><br></pre></td></tr></table></figure>
<h3 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h3><p>有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。</p>
<h4 id="安装运行-docker-registry"><a href="#安装运行-docker-registry" class="headerlink" title="安装运行 docker-registry"></a>安装运行 docker-registry</h4><h2 id="Docker-数据管理"><a href="#Docker-数据管理" class="headerlink" title="Docker 数据管理"></a>Docker 数据管理</h2><p> Docker 内部以及容器之间管理数据，在容器中管理数据主要有两种方式：</p>
<ul>
<li>数据卷（Volumes）</li>
<li>挂载主机目录 (Bind mounts)</li>
</ul>
<h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p>
<ul>
<li><code>数据卷</code> 可以在容器之间共享和重用</li>
<li>对 <code>数据卷</code> 的修改会立马生效</li>
<li>对 <code>数据卷</code> 的更新，不会影响镜像</li>
<li><code>数据卷</code> 默认会一直存在，即使容器被删除</li>
</ul>
<h4 id="创建一个数据卷"><a href="#创建一个数据卷" class="headerlink" title="创建一个数据卷"></a>创建一个数据卷</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker volume create my-vol</span><br></pre></td></tr></table></figure>
<p>查看所有的 <code>数据卷</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker volume <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line"><span class="built_in">local</span>               my-vol</span><br></pre></td></tr></table></figure>
<p>在主机里使用以下命令可以查看指定 <code>数据卷</code> 的信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker volume inspect my-vol</span><br></pre></td></tr></table></figure>
<h4 id="启动一个挂载数据卷的容器"><a href="#启动一个挂载数据卷的容器" class="headerlink" title="启动一个挂载数据卷的容器"></a>启动一个挂载数据卷的容器</h4><p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将 <code>数据卷</code> 挂载到容器里。在一次 <code>docker run</code> 中可以挂载多个 <code>数据卷</code>。</p>
<p>下面创建一个名为 <code>web</code> 的容器，并加载一个 <code>数据卷</code> 到容器的 <code>/usr/share/nginx/html</code> 目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -P --name web --mount  <span class="built_in">source</span>=my-vol,target=/usr/share/nginx/html nginx:alpine</span><br></pre></td></tr></table></figure>
<h4 id="查看数据卷的具体信息"><a href="#查看数据卷的具体信息" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h4><p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect web</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;my-vol&quot;,</span><br><span class="line">        &quot;Source&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,</span><br><span class="line">        &quot;Destination&quot;: &quot;/usr/share/nginx/html&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Mode&quot;: &quot;z&quot;,</span><br><span class="line">        &quot;RW&quot;: true,</span><br><span class="line">        &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<h4 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker volume <span class="built_in">rm</span> my-vol</span><br></pre></td></tr></table></figure>
<p><code>数据卷</code> 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 <code>数据卷</code>，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 <code>数据卷</code>。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。</p>
<p>无主的数据卷可能会占据很多空间，要清理请使用以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker volume prune</span><br></pre></td></tr></table></figure>
<h3 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h3><h4 id="挂载一个主机目录作为数据卷"><a href="#挂载一个主机目录作为数据卷" class="headerlink" title="挂载一个主机目录作为数据卷"></a>挂载一个主机目录作为数据卷</h4><p>使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -P --name web -v /data/hdb/docker_project/hub/webapp:/usr/share/nginx/html nginx:alpine </span><br></pre></td></tr></table></figure>
<p>以前使用 <code>-v</code> 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 <code>--mount</code> 参数时如果本地目录不存在，Docker 会报错。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -P --name web --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/data/hdb/docker_project/hub/webapp,target=/usr/share/nginx/html nginx:alpine </span><br></pre></td></tr></table></figure>
<p>加了 <code>readonly</code> 之后，就挂载为 <code>只读</code> 了。如果你在容器内 <code>/usr/share/nginx/html</code> 目录新建文件，会显示如下错误</p>
<h2 id="Docker-中的网络功能"><a href="#Docker-中的网络功能" class="headerlink" title="Docker 中的网络功能"></a>Docker 中的网络功能</h2><h3 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h3><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -P nginx:alpine</span><br><span class="line">docker container <span class="built_in">ls</span> -l</span><br><span class="line">----------------------------------</span><br><span class="line">CONTAINER ID   IMAGE                                     COMMAND                   CREATED          STATUS                PORTS                                     NAMES</span><br><span class="line">d5e0bfe7ec29   nginx:alpine                              <span class="string">&quot;/docker-entrypoint.…&quot;</span>   10 seconds ago   Up 9 seconds          0.0.0.0:32771-&gt;80/tcp, :::32771-&gt;80/tcp   competent_benz</span><br></pre></td></tr></table></figure>
<p>使用 <code>docker container ls</code> 可以看到，本地主机的32771被映射到了容器的 80 端口。此时访问本机的 32768 端口即可访问容器内 NGINX 默认页面。</p>
<h4 id="映射所有接口地址"><a href="#映射所有接口地址" class="headerlink" title="映射所有接口地址"></a>映射所有接口地址</h4><p>使用 <code>hostPort:containerPort</code> 格式本地的 80 端口映射到容器的 80 端口，可以执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 80:80 nginx:alpine</span><br></pre></td></tr></table></figure>
<h4 id="映射到指定地址的指定端口"><a href="#映射到指定地址的指定端口" class="headerlink" title="映射到指定地址的指定端口"></a>映射到指定地址的指定端口</h4><p>可以使用 <code>ip:hostPort:containerPort</code> 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1:80:80 nginx:alpine</span><br></pre></td></tr></table></figure>
<p>用 <code>ip::containerPort</code> 绑定 localhost 的任意端口到容器的 80 端口，本地主机会自动分配一个端口。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1::80 nginx:alpine</span><br></pre></td></tr></table></figure>
<p>还可以使用 <code>udp</code> 标记来指定 <code>udp</code> 端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1:80:80/udp nginx:alpine</span><br></pre></td></tr></table></figure>
<p><code>-p</code> 标记可以多次使用来绑定多个端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 80:80 -p 443:443 nginx:alpine</span><br></pre></td></tr></table></figure>
<h3 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h3><p>下面先创建一个新的 Docker 网络。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network create -d bridge my-net</span><br></pre></td></tr></table></figure>
<p><code>-d</code> 参数指定 Docker 网络类型，有 <code>bridge</code> <code>overlay</code>。其中 <code>overlay</code> 网络类型用于 <a href="https://docker-practice.github.io/zh-cn/swarm_mode">Swarm mode</a>，在本小节中你可以忽略它。</p>
<h4 id="连接容器"><a href="#连接容器" class="headerlink" title="连接容器"></a>连接容器</h4><p>运行一个容器并连接到新建的 <code>my-net</code> 网络</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it --<span class="built_in">rm</span> --name busybox1 --network my-net busybox sh</span><br><span class="line">docker run -it --<span class="built_in">rm</span> --name busybox2 --network my-net busybox sh</span><br></pre></td></tr></table></figure>
<p>下面通过 <code>ping</code> 来证明 <code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p>
<p>在 <code>busybox1</code> 容器输入以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping busybox2</span><br></pre></td></tr></table></figure>
<h2 id="docker宿主机和容器之间拷贝"><a href="#docker宿主机和容器之间拷贝" class="headerlink" title="docker宿主机和容器之间拷贝"></a>docker宿主机和容器之间拷贝</h2><h3 id="从容器里面拷文件到宿主机"><a href="#从容器里面拷文件到宿主机" class="headerlink" title="从容器里面拷文件到宿主机"></a>从容器里面拷文件到宿主机</h3><p>docker cp 容器名：要拷贝的文件在容器里面的路径       要拷贝到宿主机的相应路径   </p>
<h4 id="从宿主机拷文件到容器里面"><a href="#从宿主机拷文件到容器里面" class="headerlink" title="从宿主机拷文件到容器里面"></a>从宿主机拷文件到容器里面</h4><p>docker  cp  要拷贝的文件路径    容器名:要拷贝到容器里面对应的路径</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录-动态规划3</title>
    <url>/2024/05/22/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%923/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p><strong>本节包括：</strong></p>
<ul>
<li>最长递增序列</li>
</ul>
<span id="more"></span>
<h2 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a>674. 最长连续递增序列</h2><p>给定一个未经排序的整数数组，找到最长且 <strong>连续递增的子序列</strong>，并返回该序列的长度。</p>
<p><strong>连续递增的子序列</strong> 可以由两个下标 <code>l</code> 和 <code>r</code>（<code>l &lt; r</code>）确定，如果对于每个 <code>l &lt;= i &lt; r</code>，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>不断记录每次最长连续递增序列，最后返回<code>r-l</code>和<code>maxLen</code>的更大值，考虑到最后的r也有可能是一个最大值但是没有被<code>maxLen</code>保存。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfLCIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (r = <span class="number">1</span>; r &lt; nums.length; r++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[r] &gt; nums[r - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            maxLen = Math.max(r - l, maxLen);</span><br><span class="line">            l = r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(r - l, maxLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a>718. 最长重复子数组</h2><p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]</span><br><span class="line">输出：3</span><br><span class="line">解释：长度最长的公共子数组是 [3,2,1] </span><br></pre></td></tr></table></figure>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p><code>dp[i][j]</code> ：以下标<code>i - 1</code>为结尾的A，和以下标<code>j - 1</code>为结尾的B，最长重复子数组长度为<code>dp[i][j]</code>。 （<strong>特别注意</strong>： “以下标i - 1为结尾的A” 标明一定是 以A[i-1]为结尾的字符串 ）</p>
<ol>
<li>确定递推公式</li>
</ol>
<p>根据<code>dp[i][j]</code>的定义，<code>dp[i][j]</code>的状态只能由<code>dp[i - 1][j - 1]</code>推导出来。</p>
<p>即当A[i - 1] 和B[j - 1]相等的时候，<code>dp[i][j] = dp[i - 1][j - 1] + 1</code>;</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">    <span class="comment">//以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i][j]。</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length + <span class="number">1</span>][nums2.length + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums1.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= nums2.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[i][j] &gt; maxLen) maxLen = dp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143.最长公共子序列"></a>1143.最长公共子序列</h2><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p>
<p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<ul>
<li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li>
</ul>
<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol>
<li>定dp数组（dp table）以及下标的含义</li>
</ol>
<p><code>dp[i][j]</code>：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为<code>dp[i][j]</code></p>
<ol>
<li>确定递推公式</li>
</ol>
<p>主要就是两大情况： text1[i - 1] 与 text2[j - 1]相同，text1[i - 1] 与 text2[j - 1]不相同</p>
<p>如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以<code>dp[i][j] = dp[i - 1][j - 1] + 1;</code></p>
<p>如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。</p>
<p>即：<code>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])</code>;</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongestCommonSubsequence</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[text1.length() + <span class="number">1</span>][text2.length() + <span class="number">1</span>];<span class="comment">//长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为`dp[i][j]`</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= text1.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= text2.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[text1.length()][text2.length()];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1035-不相交的线"><a href="#1035-不相交的线" class="headerlink" title="1035.不相交的线"></a>1035.不相交的线</h2><p>在两条独立的水平线上按给定的顺序写下 <code>nums1</code> 和 <code>nums2</code> 中的整数。</p>
<p>现在，可以绘制一些连接两个数字 <code>nums1[i]</code> 和 <code>nums2[j]</code> 的直线，这些直线需要同时满足：</p>
<ul>
<li><code>nums1[i] == nums2[j]</code></li>
<li>且绘制的直线不与任何其他连线（非水平线）相交。</li>
</ul>
<p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p>
<p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2019/04/26/142.png" alt="img" style="zoom: 12%;" /></p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>等价于最长公共子序列</p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxUncrossedLines</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length + <span class="number">1</span>][nums2.length + <span class="number">1</span>];<span class="comment">//dp[i][j]:数组[0,i-1]和数组[0,j-1]的最大连线数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= nums2.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums1.length][nums2.length];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a>53. 最大子序和</h2><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong>是数组中的一个连续部分。</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p><code>dp[i]</code>当前的子数组最大和包含i</p>
<p>状态转移方程： <code>dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);</code></p>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];<span class="comment">//当前的子数组最大和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp[i] = Math.max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (dp[i] &gt; maxSum) maxSum = dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392.判断子序列"></a>392.判断子序列</h2><p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>&quot;ace&quot;</code>是<code>&quot;abcde&quot;</code>的一个子序列，而<code>&quot;aec&quot;</code>不是）。</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>简单略</p>
<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.isEmpty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sIdx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(sIdx) == t.charAt(i)) sIdx++;</span><br><span class="line">        <span class="keyword">if</span> (sIdx == s.length()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="115-不同的子序列"><a href="#115-不同的子序列" class="headerlink" title="115.不同的子序列"></a>115.不同的子序列</h2><p>给你两个字符串 <code>s</code> 和 <code>t</code> ，统计并返回在 <code>s</code> 的 <strong>子序列</strong> 中 <code>t</code> 出现的个数，结果需要对<script type="math/tex">1 0 ^ { 9 } + 7</script>取模。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;rabbbit&quot;, t = &quot;rabbit&quot;</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p><code>dp[i][j]</code>：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为<code>dp[i][j]</code>。</p>
<ol>
<li>确定递推公式</li>
</ol>
<ul>
<li>s[i - 1] 与 t[j - 1]相等，<code>dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]</code>，<code>s：bagg</code> 和 <code>t：bag</code> </li>
<li>s[i - 1] 与 t[j - 1] 不相等，<code>dp[i][j] = dp[i - 1][j]</code>，我们求的是 s 中有多少个 t，而不是 求t中有多少个s，所以只考虑 s中删除元素的情况，即 不用s[i - 1]来匹配 的情况3</li>
</ul>
<ol>
<li>dp数组如何初始化</li>
</ol>
<p><code>dp[i][0]</code> 表示：以i-1为结尾的s可以随便删除元素，出现空字符串的个数。</p>
<p>那么<code>dp[0][j]</code>一定都是0，s如论如何也变成不了t。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(t.<span class="built_in">size</span>() + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">size</span>(); i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= t.<span class="built_in">size</span>(); j++) dp[<span class="number">0</span>][j] = <span class="number">0</span>; <span class="comment">// 其实这行代码可以和dp数组初始化的时候放在一起，但我为了凸显初始化的逻辑，所以还是加上了。</span></span><br></pre></td></tr></table></figure>
<h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumDistinct</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length() + <span class="number">1</span>][t.length() + <span class="number">1</span>];<span class="comment">//以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为`dp[i][j]`。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= s.length(); i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//t为空字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= t.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>)) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()][t.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="583-两个字符串的删除操作"><a href="#583-两个字符串的删除操作" class="headerlink" title="583. 两个字符串的删除操作"></a>583. 两个字符串的删除操作</h2><p>给定两个单词 <code>word1</code> 和 <code>word2</code> ，返回使得 <code>word1</code> 和 <code>word2</code> <strong>相同</strong>所需的<strong>最小步数</strong>。</p>
<p><strong>每步</strong> 可以删除任意一个字符串中的一个字符。</p>
<h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><ol>
<li>定dp数组（dp table）以及下标的含义</li>
</ol>
<p><code>dp[i][j]</code>：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。</p>
<p>这里dp数组的定义有点点绕，大家要撸清思路。</p>
<ol>
<li>确定递推公式</li>
</ol>
<ul>
<li>当word1[i - 1] 与 word2[j - 1]相同的时候</li>
<li>当word1[i - 1] 与 word2[j - 1]不相同的时候</li>
</ul>
<p>当word1[i - 1] 与 word2[j - 1]相同的时候，<code>dp[i][j] = dp[i - 1][j - 1];</code></p>
<p>当word1[i - 1] 与 word2[j - 1]不相同的时候，有三种情况：</p>
<p>情况一：删word1[i - 1]，最少操作次数为<code>dp[i - 1][j] + 1</code></p>
<p>情况二：删word2[j - 1]，最少操作次数为<code>dp[i][j - 1] + 1</code></p>
<p>情况三：同时删word1[i - 1]和word2[j - 1]，操作的最少次数为<code>dp[i - 1][j - 1] + 2</code></p>
<p>那最后当然是取最小值，所以当word1[i - 1] 与 word2[j - 1]不相同的时候，递推公式：<code>dp[i][j] = min(&#123;dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1, dp[i][j - 1] + 1&#125;);</code></p>
<p>因为 <code>dp[i][j - 1] + 1 = dp[i - 1][j - 1] + 2</code>，所以递推公式可简化为：<code>dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);</code></p>
<ol>
<li>dp数组如何初始化</li>
</ol>
<p>从递推公式中，可以看出来，<code>dp[i][0]</code> 和 <code>dp[0][j]</code>是一定要初始化的。</p>
<p><code>dp[i][0]</code>：word2为空字符串，以i-1为结尾的字符串word1要删除多少个元素，才能和word2相同呢，很明显<code>dp[i][0] = i</code>。</p>
<h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[word1.length() + <span class="number">1</span>][word2.length() + <span class="number">1</span>];<span class="comment">//以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。</span></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= word1.length(); i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= word2.length(); j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= word1.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= word2.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, dp[i][j - <span class="number">1</span>] + <span class="number">1</span>);<span class="comment">//删除word1和删除word2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[word1.length()][word2.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>最长公共子序列</p>
<h3 id="代码实现2"><a href="#代码实现2" class="headerlink" title="代码实现2"></a>代码实现2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubSequence</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[word1.length() + <span class="number">1</span>][word2.length() + <span class="number">1</span>];<span class="comment">//以word1[0,i-1】和word2[0,j-1]的醉成公共子序列的长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= word1.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= word2.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> word1.length() + word2.length() - dp[word1.length()][word2.length()] * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a>72. 编辑距离</h2><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)</span><br><span class="line">rorse -&gt; rose (删除 &#x27;r&#x27;)</span><br><span class="line">rose -&gt; ros (删除 &#x27;e&#x27;)</span><br></pre></td></tr></table></figure>
<h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p><strong><code>dp[i][j]</code> 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为<code>dp[i][j]</code></strong>。</p>
<ol>
<li>确定递推公式</li>
</ol>
<p><code>if (word1[i - 1] == word2[j - 1])</code> 那么说明不用任何编辑，<code>dp[i][j]</code> 就应该是 <code>dp[i - 1][j - 1]</code>，即<code>dp[i][j] = dp[i - 1][j - 1]</code>;<br><code>if (word1[i - 1] != word2[j - 1])</code>，此时就需要编辑了，如何编辑呢？</p>
<ul>
<li>操作一：word1删除一个元素，那么就是以下标i - 2为结尾的word1 与 j-1为结尾的word2的最近编辑距离 再加上一个操作。即 <code>dp[i][j] = dp[i - 1][j] + 1</code>;</li>
<li>操作二：word2删除一个元素，那么就是以下标i - 1为结尾的word1 与 j-2为结尾的word2的最近编辑距离 再加上一个操作。即 <code>dp[i][j] = dp[i][j - 1] + 1;</code></li>
<li>操作三：替换元素，word1替换word1[i - 1]，使其与word2[j - 1]相同，此时不用增删加元素。那么只需要一次替换的操作，就可以让 word1[i - 1] 和 word2[j - 1] 相同。所以 <code>dp[i][j] = dp[i - 1][j - 1] + 1</code>;</li>
</ul>
<p><strong>word2添加一个元素，相当于word1删除一个元素</strong>，例如 <code>word1 = &quot;ad&quot; ，word2 = &quot;a&quot;</code>，<code>word1</code>删除元素<code>&#39;d&#39;</code> 和 <code>word2</code>添加一个元素<code>&#39;d&#39;</code>，变成<code>word1=&quot;a&quot;, word2=&quot;ad&quot;</code>， 最终的操作数是一样！ dp数组如下图所示意的：</p>
<h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[word1.length() + <span class="number">1</span>][word2.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= word1.length(); i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= word2.length(); j++) dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= word1.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= word2.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//                    dp[i][j] = Math.min(Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1), dp[i - 1][j - 1] + 1);//删除word1，删除word2，替换</span></span><br><span class="line">                dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;<span class="comment">//优化：删除word1，删除word2，替换</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[word1.length()][word2.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a>647. 回文子串</h2><p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p>
<p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p>
<p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p>
<h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h4><p>两层for循环，遍历区间起始位置和终止位置，然后还需要一层遍历判断这个区间是不是回文。所以时间复杂度：O(n^3)</p>
<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><ol>
<li>确定dp</li>
</ol>
<p>布尔类型的<code>dp[i][j]</code>：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是<code>dp[i][j]</code>为true，否则为false。</p>
<p>注意，一定是<code>i&lt;=j</code></p>
<ol>
<li>确定递推公式</li>
</ol>
<p>在确定递推公式时，就要分析如下几种情况。</p>
<p>整体上是两种，就是s[i]与s[j]相等，s[i]与s[j]不相等这两种。</p>
<p>当s[i]与s[j]不相等，那没啥好说的了，<code>dp[i][j]</code>一定是false。</p>
<p>当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况</p>
<ul>
<li>情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串</li>
<li>情况二：下标i 与 j相差为1，例如aa，也是回文子串</li>
<li>情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看<code>dp[i + 1][j - 1]</code>是否为true。</li>
</ul>
<ol>
<li>确定遍历顺序</li>
</ol>
<p>遍历顺序可有有点讲究了。</p>
<p>首先从递推公式中可以看出，情况三是根据<code>dp[i + 1][j - 1]</code>是否为true，在对<code>dp[i][j]</code>进行赋值true的。</p>
<p><code>dp[i + 1][j - 1]</code> 在 <code>dp[i][j]</code>的左下角</p>
<p><strong>所以一定要从下到上，从左到右遍历，这样保证<code>dp[i + 1][j - 1]</code>都是经过计算的</strong>。</p>
<h4 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h4><p>首先确定回文串，就是找中心然后向两边扩散看是不是对称的就可以了。</p>
<p><strong>在遍历中心点的时候，要注意中心点有两种情况</strong>。</p>
<p>一个元素可以作为中心点，两个元素也可以作为中心点。</p>
<h3 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()][s.length()];</span><br><span class="line">    <span class="comment">//i在前，j在后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; s.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;<span class="comment">//可能是回文</span></span><br><span class="line">                <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123;<span class="comment">//单独的a，或者bb</span></span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    result++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (dp[i][j]) result++;<span class="comment">//是回文，结果加一</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="双指针法-1"><a href="#双指针法-1" class="headerlink" title="双指针法"></a>双指针法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        res += centerExtend(s, i, i);</span><br><span class="line">        res += centerExtend(s, i, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">centerExtend</span><span class="params">(String s, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; s.length() &amp;&amp; s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">        i--;</span><br><span class="line">        j++;</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516.最长回文子序列"></a>516.最长回文子序列</h2><p>给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。</p>
<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>
<h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p><strong><code>dp[i][j]</code>：字符串s在[i, j]范围内最长的回文子序列的长度为<code>dp[i][j]</code></strong>。</p>
<ol>
<li>确定递推公式</li>
</ol>
<p>在判断回文子串的题目中，关键逻辑就是看s[i]与s[j]是否相同。</p>
<p>如果s[i]与s[j]相同，那么<code>dp[i][j] = dp[i + 1][j - 1] + 2;</code></p>
<p>如果s[i]与s[j]不相同，说明s[i]和s[j]的同时加入 并不能增加[i,j]区间回文子序列的长度，那么分别加入s[i]、s[j]看看哪一个可以组成最长的回文子序列。</p>
<p>加入s[j]的回文子序列长度为<code>dp[i + 1][j]</code>。</p>
<p>加入s[i]的回文子序列长度为<code>dp[i][j - 1]</code>。</p>
<p>那么dp[i][j]一定是取最大的，即：<code>dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);</code></p>
<ol>
<li>dp数组如何初始化</li>
</ol>
<p>首先要考虑当i 和j 相同的情况，从递推公式：<code>dp[i][j] = dp[i + 1][j - 1] + 2;</code> 可以看出 递推公式是计算不到 i 和j相同时候的情况。</p>
<p>所以需要手动初始化一下，当i与j相同，那么<code>dp[i][j]</code>一定是等于1的，即：一个字符的回文子序列长度就是1。</p>
<h3 id="代码实现-10"><a href="#代码实现-10" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()][s.length()];<span class="comment">//[i,j]子序列中的最长回文长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;<span class="comment">//初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;<span class="comment">//中心两点扩展0+2</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][s.length() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code_Musing</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录-单调栈</title>
    <url>/2024/05/24/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p><strong>本节包括：</strong></p>
<ul>
<li>单调栈</li>
</ul>
<span id="more"></span>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了</strong>。时间复杂度为O(n)。</p>
<p><strong>单调栈的本质是空间换时间</strong>，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是整个数组只需要遍历一次。</p>
<h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a>739. 每日温度</h2><p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>情况一：当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况</li>
<li>情况二：当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况</li>
<li>情况三：当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> temperatures.length;<span class="comment">//天气天数</span></span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[days];</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();<span class="comment">//单调栈</span></span><br><span class="line">    stack.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; days; i++) &#123;</span><br><span class="line">        <span class="comment">//当前遍历的元素T[i]小于等于栈顶元素T[st.top()]的情况</span></span><br><span class="line">        <span class="keyword">if</span> (temperatures[i] &lt;= temperatures[stack.peek()]) &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;</span><br><span class="line">                ans[stack.peek()] = i - stack.peek();</span><br><span class="line">                stack.remove();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496.下一个更大元素 I"></a>496.下一个更大元素 I</h2><p><code>nums1</code> 中数字 <code>x</code> 的 <strong>下一个更大元素</strong> 是指 <code>x</code> 在 <code>nums2</code> 中对应位置 <strong>右侧</strong> 的 <strong>第一个</strong> 比 <code>x</code> 大的元素。</p>
<p>给你两个 <strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，下标从 <strong>0</strong> 开始计数，其中<code>nums1</code> 是 <code>nums2</code> 的子集。</p>
<p>对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足 <code>nums1[i] == nums2[j]</code> 的下标 <code>j</code> ，并且在 <code>nums2</code> 确定 <code>nums2[j]</code> 的 <strong>下一个更大元素</strong> 。如果不存在下一个更大元素，那么本次查询的答案是 <code>-1</code> 。</p>
<p>返回一个长度为 <code>nums1.length</code> 的数组 <code>ans</code> 作为答案，满足 <code>ans[i]</code> 是如上所述的 <strong>下一个更大元素</strong> 。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p><strong>注意题目中说是两个没有重复元素 的数组 nums1 和 nums2</strong>。</p>
<p>没有重复元素，我们就可以用map来做映射了。根据数值快速找到下标，还可以判断nums2[i]是否在nums1中出现过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">    map.put(nums1[i], i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length];</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();<span class="comment">//单调栈</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">        map.put(nums1[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.fill(res, -<span class="number">1</span>);</span><br><span class="line">    stack.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums2.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums2[i] &lt; nums2[stack.peek()]) &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums2[i] &gt; nums2[stack.peek()]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(nums2[stack.peek()])) &#123;</span><br><span class="line">                    res[map.get(nums2[stack.peek()])] = nums2[i];</span><br><span class="line">                &#125;</span><br><span class="line">                stack.remove();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="503-下一个更大元素II"><a href="#503-下一个更大元素II" class="headerlink" title="503.下一个更大元素II"></a>503.下一个更大元素II</h2><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>“拼接”一个数组到后面模拟循环数组，用取模<code>%</code>模拟，而不是扩充<code>nums</code></p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElements(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">    Arrays.fill(res, -<span class="number">1</span>);</span><br><span class="line">    stack.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; size * <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i % size] &lt;= nums[stack.peek() % size]) &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[i % size] &gt; nums[stack.peek() % size]) &#123;</span><br><span class="line">                res[stack.peek() % size] = nums[i % size];</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h2><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><img src="https://code-thinking-1253855093.cos.ap-guangzhou.myqcloud.com/pics/20210713205038.png" alt="img" style="zoom:150%;" /></p>
<ul>
<li>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]</li>
<li>输出：6</li>
<li>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</li>
</ul>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力双指针法"><a href="#暴力双指针法" class="headerlink" title="暴力双指针法"></a>暴力双指针法</h4><p>每一列雨水的高度，取决于，该列<strong>左侧最高的柱子</strong>和<strong>右侧最高的柱子</strong>中最矮的那个柱子的高度。</p>
<p>并且<strong>要注意第一个柱子和最后一个柱子不接雨水</strong></p>
<h4 id="双指针优化"><a href="#双指针优化" class="headerlink" title="双指针优化"></a>双指针优化</h4><p>我们把每一个位置的左边最高高度记录在一个数组上（maxLeft），右边最高高度记录在一个数组上（maxRight），这样就避免了重复计算。</p>
<h4 id="单调栈解法"><a href="#单调栈解法" class="headerlink" title="单调栈解法"></a>单调栈解法</h4><ul>
<li><p>如果当前遍历的元素（柱子）高度小于栈顶元素的高度，就把这个元素加入栈中，因为栈里本来就要保持从小到大的顺序（从栈头到栈底）。</p>
</li>
<li><p>如果当前遍历的元素（柱子）高度等于栈顶元素的高度，要跟更新栈顶元素，因为遇到相相同高度的柱子，需要使用最右边的柱子来计算宽度。</p>
</li>
<li><p>如果当前遍历的元素（柱子）高度大于栈顶元素的高度，此时就出现凹槽了；</p>
<blockquote>
<p>取栈顶元素，将栈顶元素弹出，这个就是凹槽的底部，也就是中间位置，下标记为mid，对应的高度为height[mid]</p>
<p>此时大家应该可以发现其实就是<strong>栈顶和栈顶的下一个元素以及要入栈的元素，三个元素来接水！</strong></p>
<p>那么雨水高度是 min(凹槽左边高度, 凹槽右边高度) - 凹槽底部高度，代码为：<code>int h = min(height[st.top()], height[i]) - height[mid];</code></p>
<p>雨水的宽度是 凹槽右边的下标 - 凹槽左边的下标 - 1（因为只求中间宽度），代码为：<code>int w = i - st.top() - 1 ;</code></p>
</blockquote>
<p>此时的栈顶元素st.top()，就是凹槽的左边位置，下标为st.top()，对应的高度为height[st.top()]（就是图中的高度2）。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210223092629946.png" alt="42.接雨水2" style="zoom:50%;" /></p>
</li>
</ul>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="双指针优化-1"><a href="#双指针优化-1" class="headerlink" title="双指针优化"></a>双指针优化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">twoPointTrap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> height.length;</span><br><span class="line">    <span class="type">int</span>[] maxLeft = <span class="keyword">new</span> <span class="title class_">int</span>[size];<span class="comment">//左边最高高度</span></span><br><span class="line">    <span class="type">int</span>[] maxRight = <span class="keyword">new</span> <span class="title class_">int</span>[size];<span class="comment">//右边最高高度</span></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    maxLeft[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">    maxRight[size - <span class="number">1</span>] = height[size - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>; l &lt; size; l++) &#123;</span><br><span class="line">        maxLeft[l] = Math.max(height[l - <span class="number">1</span>], maxLeft[l - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> size - <span class="number">2</span>; r &gt;= <span class="number">0</span>; r--) &#123;</span><br><span class="line">        maxRight[r] = Math.max(height[r + <span class="number">1</span>], maxRight[r + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= size - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        col = Math.min(maxLeft[i], maxRight[i]) - height[i];</span><br><span class="line">        <span class="keyword">if</span> (col &gt; <span class="number">0</span>) sum += col;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">monotonicStackTrap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> height.length;</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    stack.push(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">water</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height[i] &lt; height[stack.peek()]) &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (height[i] == height[stack.peek()]) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> height[stack.pop()];</span><br><span class="line">                <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmpHeight</span> <span class="operator">=</span> Math.min(height[i], height[stack.peek()]) - mid;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> i - stack.peek() - <span class="number">1</span>;</span><br><span class="line">                    water += width * tmpHeight;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> water;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84.柱状图中最大的矩形"></a>84.柱状图中最大的矩形</h2><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>只有栈里从大到小的顺序，才能保证栈顶元素找到左右两边第一个小于栈顶元素的柱子。</p>
<p>所以本题单调栈的顺序正好与接雨水反过来。</p>
<p>大家应该可以发现其实就是<strong>栈顶和栈顶的下一个元素以及要入栈的三个元素组成了我们要求最大面积的高度和宽度</strong></p>
<p>主要就是分析清楚如下三种情况：</p>
<ul>
<li>情况一：当前遍历的元素heights[i]大于栈顶元素heights[st.top()]的情况</li>
<li>情况二：当前遍历的元素heights[i]等于栈顶元素heights[st.top()]的情况</li>
<li>情况三：当前遍历的元素heights[i]小于栈顶元素heights[st.top()]的情况</li>
</ul>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();<span class="comment">//单调栈，下一个比当前高度小的柱子位置</span></span><br><span class="line">    <span class="type">int</span>[] extendHeights = <span class="keyword">new</span> <span class="title class_">int</span>[heights.length + <span class="number">2</span>];<span class="comment">//左右两边扩充0</span></span><br><span class="line">    System.arraycopy(heights, <span class="number">0</span>, extendHeights, <span class="number">1</span>, heights.length);</span><br><span class="line">    heights = extendHeights;</span><br><span class="line">    stack.push(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>, w = <span class="number">0</span>, area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (heights[i] &gt; heights[stack.peek()]) &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (heights[stack.peek()] == heights[i]) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; heights[i] &lt; heights[stack.peek()]) &#123;</span><br><span class="line">                h = heights[stack.pop()];<span class="comment">//这里弹出了</span></span><br><span class="line">                w = i - stack.peek() - <span class="number">1</span>;</span><br><span class="line">                area = Math.max(area, w * h);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code_Musing</category>
      </categories>
      <tags>
        <tag>monotonic_stack</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录-图论</title>
    <url>/2024/06/03/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%9B%BE%E8%AE%BA/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p><strong>本节包括：</strong></p>
<ul>
<li>理论基础(dfs和bfs)</li>
<li>岛屿问题</li>
<li>并查集</li>
</ul>
<span id="more"></span>
<h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>dfs是可一个方向去搜，不到黄河不回头，直到遇到绝境了，搜不下去了，再换方向（换方向的过程就涉及到了回溯）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(参数)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本节点所连接的其他节点) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        dfs(图，选择的节点); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>bfs是先把本节点所连接的所有节点遍历一遍，走到下一个节点的时候，再把连接节点的所有节点遍历一遍，搜索方向更像是广度，四面八方的搜索过程。</p>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>广搜的搜索方式就适合于解决<strong>两个点之间的最短路径问题。</strong></p>
<p>因为广搜是从起点出发，以起始点为中心一圈一圈进行搜索，一旦遇到终点，记录之前走过的节点就是一条最短路。</p>
<h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a>200. 岛屿数量</h2><p>给你一个由<code>1</code>（陆地）和<code>0</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h4><p>dfs，从四个方向遍历，访问过的陆地将其沉没</p>
<h4 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h4><p><strong>只要加入队列就代表 走过，就需要标记，而不是从队列拿出来的时候再去标记走过</strong>。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="dfs-1"><a href="#dfs-1" class="headerlink" title="dfs"></a>dfs</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                dfs(grid, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= grid.length || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    grid[i][j] = <span class="string">&#x27;0&#x27;</span>;<span class="comment">//沉没陆地</span></span><br><span class="line">    <span class="comment">//逆时针遍历</span></span><br><span class="line">    dfs(grid, i + <span class="number">1</span>, j);</span><br><span class="line">    dfs(grid, i, j + <span class="number">1</span>);</span><br><span class="line">    dfs(grid, i - <span class="number">1</span>, j);</span><br><span class="line">    dfs(grid, i, j - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bfs-1"><a href="#bfs-1" class="headerlink" title="bfs"></a>bfs</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] dir = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;<span class="comment">//四个方向</span></span><br><span class="line"><span class="type">boolean</span>[][] visited;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands2</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[grid.length][grid[<span class="number">0</span>].length];<span class="comment">//是否访问过标志</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    bfs(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        Deque&lt;<span class="type">int</span>[]&gt; queen = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queen.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, j&#125;);</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queen.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span>[] cur = queen.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> cur[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> cur[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextx</span> <span class="operator">=</span> x + dir[k][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">nexty</span> <span class="operator">=</span> y + dir[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= grid.length || nexty &lt; <span class="number">0</span> || nexty &gt;= grid[<span class="number">0</span>].length || grid[nextx][nexty] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (grid[nextx][nexty] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; !visited[nextx][nexty]) &#123;</span><br><span class="line">                    queen.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nextx, nexty&#125;);</span><br><span class="line">                    visited[nextx][nexty] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="797-所有可能的路径"><a href="#797-所有可能的路径" class="headerlink" title="797.所有可能的路径"></a>797.所有可能的路径</h2><p>给你一个有 <code>n</code> 个节点的 <strong>有向无环图（DAG）</strong>，请你找出所有从节点 <code>0</code> 到节点 <code>n-1</code> 的路径并输出（<strong>不要求按特定顺序</strong>）</p>
<p> <code>graph[i]</code> 是一个从节点 <code>i</code> 可以访问的所有节点的列表（即从节点 <code>i</code> 到节点 <code>graph[i][j]</code>存在一条有向边）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：graph = [[1,2],[3],[3],[]]</span><br><span class="line">输出：[[0,1,3],[0,2,3]]</span><br><span class="line">解释：有两条路径 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3</span><br></pre></td></tr></table></figure>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>通过dfs遍历和回溯</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AllPathsSourceTarget</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">allPathsSourceTarget</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">        path.add(<span class="number">0</span>);</span><br><span class="line">        dfs(graph, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] graph, <span class="type">int</span> node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == graph.length - <span class="number">1</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; graph[node].length; i++) &#123;</span><br><span class="line">            path.add(graph[node][i]);</span><br><span class="line">            dfs(graph, graph[node][i]);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);<span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a>695. 岛屿的最大面积</h2><p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code> 。</p>
<p><strong>岛屿</strong> 是由一些相邻的 <code>1</code> (代表土地) 构成的组合，这里的「相邻」要求两个 <code>1</code> 必须在 <strong>水平或者竖直的四个方向上</strong> 相邻。你可以假设 <code>grid</code> 的四个边缘都被 <code>0</code>（代表水）包围着。</p>
<p>岛屿的面积是岛上值为 <code>1</code> 的单元格的数目。</p>
<p>计算并返回 <code>grid</code> 中最大的岛屿面积。如果没有岛屿，则返回面积为 <code>0</code> 。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>类似岛屿数量，只不过每次dfs都要计算面积</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxAreaOfIsland</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxArea</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmpArea</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                tmpArea = dfs(grid, i, j);</span><br><span class="line">                maxArea = Math.max(tmpArea, maxArea);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmpArea</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= grid.length || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[i][j] = <span class="number">0</span>;<span class="comment">//沉没岛屿</span></span><br><span class="line">    tmpArea++;</span><br><span class="line">    tmpArea += dfs(grid, i + <span class="number">1</span>, j);</span><br><span class="line">    tmpArea += dfs(grid, i, j + <span class="number">1</span>);</span><br><span class="line">    tmpArea += dfs(grid, i - <span class="number">1</span>, j);</span><br><span class="line">    tmpArea += dfs(grid, i, j - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> tmpArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1020-飞地的数量"><a href="#1020-飞地的数量" class="headerlink" title="1020. 飞地的数量"></a>1020. 飞地的数量</h2><p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code> ，其中 <code>0</code> 表示一个海洋单元格、<code>1</code> 表示一个陆地单元格。</p>
<p>一次 <strong>移动</strong> 是指从一个陆地单元格走到另一个相邻（<strong>上、下、左、右</strong>）的陆地单元格或跨过 <code>grid</code> 的边界。</p>
<p>返回网格中 <strong>无法</strong> 在任意次数的移动中离开网格边界的陆地单元格的数量。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>求每个岛屿的面积，如果岛屿能跨过边界，不计入飞地，不能跨越边界，计入飞地</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span> || i == grid.length - <span class="number">1</span> || j == <span class="number">0</span> || j == grid[<span class="number">0</span>].length - <span class="number">1</span>) canFly = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumEnclaves</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> canFly;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numEnclaves</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">enclaves</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> tmpArea;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                tmpArea = dfs(grid, i, j);</span><br><span class="line">                <span class="keyword">if</span> (!canFly) enclaves += tmpArea;</span><br><span class="line">                canFly = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enclaves;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmpArea</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= grid.length || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        grid[i][j] = <span class="number">0</span>;<span class="comment">//沉没岛屿</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || i == grid.length - <span class="number">1</span> || j == <span class="number">0</span> || j == grid[<span class="number">0</span>].length - <span class="number">1</span>) canFly = <span class="literal">true</span>;</span><br><span class="line">        tmpArea++;</span><br><span class="line">        tmpArea += dfs(grid, i + <span class="number">1</span>, j);</span><br><span class="line">        tmpArea += dfs(grid, i, j + <span class="number">1</span>);</span><br><span class="line">        tmpArea += dfs(grid, i - <span class="number">1</span>, j);</span><br><span class="line">        tmpArea += dfs(grid, i, j - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> tmpArea;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a>130. 被围绕的区域</h2><p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code> ，找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>依然是从地图周边出发，将周边空格相邻的’O’都做上标记，然后在遍历一遍地图，遇到 ‘O’ 且没做过标记的，那么都是地图中间的’O’，全部改成’X’就行。</p>
<ol>
<li>步骤一：深搜或者广搜将地图周边的’O’全部改成’A’</li>
<li>步骤二：在遍历地图，将’O’全部改成’X’（地图中间的’O’改成了’X’），将’A’改回’O’（保留的地图周边的’O’）</li>
</ol>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solve</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dir = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> board.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//四周dfs遍历&quot;O&quot;,将其标记为“A”</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dfs(board, i, <span class="number">0</span>);</span><br><span class="line">            dfs(board, i, n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dfs(board, <span class="number">0</span>, j);</span><br><span class="line">            dfs(board, m - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (board[i][j]) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">                        board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">                        board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//处理当前节点</span></span><br><span class="line">            board[i][j] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            <span class="comment">//当前的都是O</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextX</span> <span class="operator">=</span> i + dir[k][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextY</span> <span class="operator">=</span> j + dir[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (nextX &lt; <span class="number">0</span> || nextX &gt;= board.length || nextY &lt; <span class="number">0</span> || nextY &gt;= board[<span class="number">0</span>].length)<span class="comment">//校验是否越界</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                dfs(board, nextX, nextY);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="417-太平洋大西洋水流问题"><a href="#417-太平洋大西洋水流问题" class="headerlink" title="417. 太平洋大西洋水流问题"></a>417. 太平洋大西洋水流问题</h2><p>有一个 <code>m × n</code> 的矩形岛屿，与 <strong>太平洋</strong> 和 <strong>大西洋</strong> 相邻。 <strong>“太平洋”</strong> 处于大陆的左边界和上边界，而 <strong>“大西洋”</strong> 处于大陆的右边界和下边界。</p>
<p>这个岛被分割成一个由若干方形单元格组成的网格。给定一个 <code>m x n</code> 的整数矩阵 <code>heights</code> ， <code>heights[r][c]</code> 表示坐标 <code>(r, c)</code> 上单元格 <strong>高于海平面的高度</strong> 。</p>
<p>岛上雨水较多，如果相邻单元格的高度 <strong>小于或等于</strong> 当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。</p>
<p>返回网格坐标 <code>result</code> 的 <strong>2D 列表</strong> ，其中 <code>result[i] = [ri, ci]</code> 表示雨水从单元格 <code>(ri, ci)</code> 流动 <strong>既可流向太平洋也可流向大西洋</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/06/08/waterflow-grid.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]</span><br><span class="line">输出: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]</span><br></pre></td></tr></table></figure>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>分别从太平洋和大西洋海岸逆流，用不同的数组标记pacific和atlantic，可以逆流就记为true，最后只有pacific和atlantic都可以逆流到达才加入结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (atlantic[i][j] &amp;&amp; pacific[i][j]) &#123;</span><br><span class="line">    res.add(List.of(i, j));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始海岸要分别对pacific和atlantic设为true。</p>
<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] dirs = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;<span class="comment">//四个方向</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pacificAtlantic</span><span class="params">(<span class="type">int</span>[][] heights)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> heights.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> heights[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">boolean</span>[][] pacific = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];<span class="comment">//是否从太平洋访问过</span></span><br><span class="line">    <span class="type">boolean</span>[][] atlantic = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];<span class="comment">//是否从大西洋访问过</span></span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        dfs(heights, pacific, i, <span class="number">0</span>);<span class="comment">//左列太平洋</span></span><br><span class="line">        pacific[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        dfs(heights, atlantic, i, n - <span class="number">1</span>);<span class="comment">//右列大西洋</span></span><br><span class="line">        atlantic[i][n - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        dfs(heights, pacific, <span class="number">0</span>, j);<span class="comment">//上行太平洋</span></span><br><span class="line">        pacific[<span class="number">0</span>][j] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        dfs(heights, atlantic, m - <span class="number">1</span>, j);<span class="comment">//下行大西洋</span></span><br><span class="line">        atlantic[m - <span class="number">1</span>][j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (atlantic[i][j] &amp;&amp; pacific[i][j]) &#123;</span><br><span class="line">                res.add(List.of(i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] heights, <span class="type">boolean</span>[][] visited, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] dir : dirs) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextR</span> <span class="operator">=</span> r + dir[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextC</span> <span class="operator">=</span> c + dir[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nextR &lt; <span class="number">0</span> || nextR &gt;= heights.length || nextC &lt; <span class="number">0</span> || nextC &gt;= heights[<span class="number">0</span>].length || visited[nextR][nextC])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (heights[r][c] &lt;= heights[nextR][nextC]) &#123;</span><br><span class="line">            visited[nextR][nextC] = <span class="literal">true</span>;<span class="comment">//可以向上逆流</span></span><br><span class="line">            dfs(heights, visited, nextR, nextC);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="827-最大人工岛"><a href="#827-最大人工岛" class="headerlink" title="827.最大人工岛"></a>827.最大人工岛</h2><p>给你一个大小为 <code>n x n</code> 二进制矩阵 <code>grid</code> 。<strong>最多</strong> 只能将一格 <code>0</code> 变成 <code>1</code> 。</p>
<p>返回执行此操作后，<code>grid</code> 中最大的岛屿面积是多少？</p>
<p><strong>岛屿</strong> 由一组上、下、左、右四个方向相连的 <code>1</code> 形成。</p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>只要用一次深搜把每个岛屿的面积记录下来就好。</p>
<p>第一步：一次遍历地图，得出各个岛屿的面积，并做编号记录。可以使用map记录，key为岛屿编号，value为岛屿面积 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;; <span class="comment">// 四个方向</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> mark)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (grid[x][y] != <span class="number">1</span> || grid[x][y] == <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">// 终止条件：访问过的节点 或者 遇到海水</span></span><br><span class="line">    grid[x][y] = mark; <span class="comment">// 给陆地标记新标签</span></span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextx</span> <span class="operator">=</span> x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">nexty</span> <span class="operator">=</span> y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= grid.size() || nexty &lt; <span class="number">0</span> || nexty &gt;= grid[<span class="number">0</span>].size()) <span class="keyword">continue</span>;  <span class="comment">// 越界了，直接跳过</span></span><br><span class="line">        dfs(grid, nextx, nexty, mark);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">largestIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.size(), m = grid[<span class="number">0</span>].size();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span> ,<span class="type">int</span>&gt; gridNum;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mark</span> <span class="operator">=</span> <span class="number">2</span>; <span class="comment">// 记录每个岛屿的编号</span></span><br><span class="line">        <span class="type">bool</span> <span class="variable">isAllGrid</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// 标记是否整个地图都是陆地</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) isAllGrid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                    dfs(grid, i, j, mark); <span class="comment">// 将与其链接的陆地都标记上 true</span></span><br><span class="line">                    gridNum[mark] = count; <span class="comment">// 记录每一个岛屿的面积</span></span><br><span class="line">                    mark++; <span class="comment">// 记录下一个岛屿编号</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步：在遍历地图，遍历0的方格（因为要将0变成1），并统计该1（由0变成的1）周边岛屿面积，将其相邻面积相加在一起，遍历所有 0 之后，就可以得出 选一个0变成1 之后的最大面积。</p>
<h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><p>太长，略</p>
<h2 id="127-单词接龙"><a href="#127-单词接龙" class="headerlink" title="127.单词接龙"></a>127.单词接龙</h2><p>字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：</p>
<ul>
<li>序列中第一个单词是 beginWord 。</li>
<li>序列中最后一个单词是 endWord 。</li>
<li>每次转换只能改变一个字母。</li>
<li>转换过程中的中间单词必须是字典 wordList 中的单词。</li>
<li>给你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。</li>
</ul>
<p>示例 1：</p>
<ul>
<li>输入：beginWord = “hit”, endWord = “cog”, wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]</li>
<li>输出：5</li>
<li>解释：一个最短转换序列是 “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”, 返回它的长度 5。</li>
</ul>
<h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p><strong>这里无向图求最短路，广搜最为合适，广搜只要搜到了终点，那么一定是最短的路径</strong>。因为广搜就是以起点中心向四周扩散的搜索。</p>
<ul>
<li>本题是一个无向图，需要用标记位，标记着节点是否走过，否则就会死循环！</li>
<li>本题给出集合是数组型的，可以转成set结构，查找更快一些</li>
</ul>
<h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class="line">    HashSet&lt;String&gt; wordSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordList);</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//记录路径长度</span></span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();<span class="comment">//bfs队列</span></span><br><span class="line">    queue.offer(beginWord);</span><br><span class="line">    map.put(beginWord, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!wordSet.contains(endWord)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> queue.poll(); <span class="comment">//取出队头单词</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">path</span> <span class="operator">=</span> map.get(word); <span class="comment">//获取到该单词的路径长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123; <span class="comment">//遍历单词的每个字符</span></span><br><span class="line">            <span class="type">char</span>[] chars = word.toCharArray(); <span class="comment">//将单词转换为char array，方便替换</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">k</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; k &lt;= <span class="string">&#x27;z&#x27;</span>; k++) &#123; <span class="comment">//从&#x27;a&#x27; 到 &#x27;z&#x27; 遍历替换</span></span><br><span class="line">                chars[i] = k; <span class="comment">//替换第i个字符</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">newWord</span> <span class="operator">=</span> String.valueOf(chars); <span class="comment">//得到新的字符串</span></span><br><span class="line">                <span class="keyword">if</span> (newWord.equals(endWord)) &#123;  <span class="comment">//如果新的字符串值与endWord一致，返回当前长度+1</span></span><br><span class="line">                    <span class="keyword">return</span> path + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (wordSet.contains(newWord) &amp;&amp; !map.containsKey(newWord)) &#123; <span class="comment">//如果新单词在set中，但是没有访问过</span></span><br><span class="line">                    map.put(newWord, path + <span class="number">1</span>); <span class="comment">//记录单词对应的路径长度</span></span><br><span class="line">                    queue.offer(newWord);<span class="comment">//加入队尾</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//未找到</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="841-钥匙和房间"><a href="#841-钥匙和房间" class="headerlink" title="841.钥匙和房间"></a>841.钥匙和房间</h2><p>有 <code>n</code> 个房间，房间按从 <code>0</code> 到 <code>n - 1</code> 编号。最初，除 <code>0</code> 号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。</p>
<p>当你进入一个房间，你可能会在里面找到一套不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。</p>
<p>给你一个数组 <code>rooms</code> 其中 <code>rooms[i]</code> 是你进入 <code>i</code> 号房间可以获得的钥匙集合。如果能进入 <strong>所有</strong> 房间返回 <code>true</code>，否则返回 <code>false</code>。</p>
<h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>BFS思想，通过队列遍历钥匙打开房间，每次打开房间，将钥匙放入队列，已经打开的门跳过。</p>
<h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CanVisitAllRooms</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canVisitAllRooms</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> rooms.size();</span><br><span class="line">        <span class="type">int</span>[] visited = <span class="keyword">new</span> <span class="title class_">int</span>[n];<span class="comment">//是否打开了房间</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//准备进入第一个房间拿到钥匙</span></span><br><span class="line">        queue.offer(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">openRooms</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curKey</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (visited[curKey] == <span class="number">0</span>) &#123;<span class="comment">//没有打开过这个房间，现在打开，获取钥匙</span></span><br><span class="line">                visited[curKey] = <span class="number">1</span>;</span><br><span class="line">                openRooms++;</span><br><span class="line">                List&lt;Integer&gt; keys = rooms.get(curKey);</span><br><span class="line">                <span class="keyword">for</span> (Integer key : keys) &#123;</span><br><span class="line">                    queue.offer(key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (openRooms == n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="463-岛屿的周长"><a href="#463-岛屿的周长" class="headerlink" title="463. 岛屿的周长"></a>463. 岛屿的周长</h2><p>给定一个 <code>row x col</code> 的二维网格地图 <code>grid</code> ，其中：<code>grid[i][j] = 1</code> 表示陆地， <code>grid[i][j] = 0</code> 表示水域。</p>
<p>网格中的格子 <strong>水平和垂直</strong> 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p>
<p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p>
<h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><p>统计陆地面积，四个方向有遇到陆地，相交边加一</p>
<blockquote>
<p>其实可以只考虑两个方向，上边和左边的相交边两倍就是重叠的边</p>
</blockquote>
<h3 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] dir = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;<span class="comment">//四个方向</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">islandPerimeter</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">interEdges</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;<span class="comment">//只有一个岛，不用考虑之后</span></span><br><span class="line">                area++;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">nextX</span> <span class="operator">=</span> i + dir[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">nextY</span> <span class="operator">=</span> j + dir[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (nextX &lt; <span class="number">0</span> || nextX &gt;= grid.length || nextY &lt; <span class="number">0</span> || nextY &gt;= grid[<span class="number">0</span>].length || grid[nextX][nextY] == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    interEdges++;<span class="comment">//有相交的边，那么加一</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area * <span class="number">4</span> - interEdges;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">islandPerimeter</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">interEdges</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;<span class="comment">//只有一个岛，不用考虑之后</span></span><br><span class="line">                area++;</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i - <span class="number">1</span>][j] == <span class="number">1</span>) interEdges++;</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i][j - <span class="number">1</span>] == <span class="number">1</span>) interEdges++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area * <span class="number">4</span> - interEdges * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并查集理论"><a href="#并查集理论" class="headerlink" title="并查集理论"></a>并查集理论</h2><p>并查集主要有两个功能：</p>
<ul>
<li>将两个元素添加到一个集合中。</li>
<li>判断两个元素在不在同一个集合</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将v，u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span>; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == father[u]) <span class="keyword">return</span> u; <span class="comment">// 如果根就是自己，直接返回</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">find</span>(father[u]); <span class="comment">// 如果根不是自己，就根据数组下标一层一层向下找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>在实现 find 函数的过程中，我们知道，通过递归的方式，不断获取father数组下标对应的数值，最终找到这个集合的根。</p>
<p>搜索过程像是一个多叉树中从叶子到根节点的过程，如果这棵多叉树高度很深的话，每次find函数 去寻找根的过程就要递归很多次，我们的目的只需要知道这些节点在同一个根下就可以，所以对这棵多叉树的构造只需要这样就可以了，如图：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230602103040.png" alt="img" style="zoom:50%;" /></p>
<p>除了根节点其他所有节点都挂载根节点下，这样我们在寻根的时候就很快，只需要一步，</p>
<blockquote>
<p>我们只需要在递归的过程中，让 father[u] 接住递归函数 find(father[u]) 的返回结果。</p>
<p>因为 find 函数向上寻找根节点，father[u] 表述 u 的父节点，那么让 father[u] 直接获取 find函数 返回的根节点，这样就让节点 u 的父节点 变成根节点。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == father[u]) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> father[u] = <span class="built_in">find</span>(father[u]); <span class="comment">// 路径压缩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rank[u] &lt;= rank[v]) father[u] = v; <span class="comment">// rank小的树合入到rank大的树</span></span><br><span class="line">    <span class="keyword">else</span> father[v] = u;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rank[u] == rank[v] &amp;&amp; u != v) rank[v]++; <span class="comment">// 如果两棵树高度相同，则v的高度+1，因为上面 if (rank[u] &lt;= rank[v]) father[u] = v; 注意是 &lt;=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1971-寻找图中是否存在路径"><a href="#1971-寻找图中是否存在路径" class="headerlink" title="1971. 寻找图中是否存在路径"></a>1971. 寻找图中是否存在路径</h2><p>有一个具有 <code>n</code> 个顶点的 <strong>双向</strong> 图，其中每个顶点标记从 <code>0</code> 到 <code>n - 1</code>（包含 <code>0</code> 和 <code>n - 1</code>）。图中的边用一个二维整数数组 <code>edges</code> 表示，其中 <code>edges[i] = [ui, vi]</code> 表示顶点 <code>ui</code> 和顶点 <code>vi</code> 之间的双向边。 每个顶点对由 <strong>最多一条</strong> 边连接，并且没有顶点存在与自身相连的边。</p>
<p>请你确定是否存在从顶点 <code>source</code> 开始，到顶点 <code>destination</code> 结束的 <strong>有效路径</strong> 。</p>
<p>给你数组 <code>edges</code> 和整数 <code>n</code>、<code>source</code> 和 <code>destination</code>，如果从 <code>source</code> 到 <code>destination</code> 存在 <strong>有效路径</strong> ，则返回 <code>true</code>，否则返回 <code>false</code> 。</p>
<h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><p>采用并查集，一定要压缩路径，不然会超时</p>
<h3 id="代码实现-10"><a href="#代码实现-10" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidPath</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] father;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validPath</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges, <span class="type">int</span> source, <span class="type">int</span> destination)</span> &#123;</span><br><span class="line">        father = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">            join(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSame(source, destination);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; father.length; i++) &#123;</span><br><span class="line">            father[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (u == father[u]) <span class="keyword">return</span> u;</span><br><span class="line">        <span class="keyword">return</span> father[u] = find(father[u]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">        u = find(u);</span><br><span class="line">        v = find(v);</span><br><span class="line">        <span class="keyword">return</span> u == v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">        u = find(u);</span><br><span class="line">        v = find(v);</span><br><span class="line">        <span class="keyword">if</span> (u == v) <span class="keyword">return</span>;</span><br><span class="line">        father[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="684-冗余连接"><a href="#684-冗余连接" class="headerlink" title="684.冗余连接"></a>684.冗余连接</h2><p>树可以看成是一个连通且 <strong>无环</strong> 的 <strong>无向</strong> 图。</p>
<p>给定往一棵 <code>n</code> 个节点 (节点值 <code>1～n</code>) 的树中添加一条边后的图。添加的边的两个顶点包含在 <code>1</code> 到 <code>n</code> 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 <code>n</code> 的二维数组 <code>edges</code> ，<code>edges[i] = [ai, bi]</code> 表示图中在 <code>ai</code> 和 <code>bi</code> 之间存在一条边。</p>
<p>请找出一条可以删去的边，删除后可使得剩余部分是一个有着 <code>n</code> 个节点的树。如果有多个答案，则返回数组 <code>edges</code> 中最后出现的那个。</p>
<h3 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h3><p>那么我们就可以从前向后遍历每一条边（因为优先让前面的边连上），边的两个节点如果不在同一个集合，就加入集合（即：同一个根节点）。</p>
<ul>
<li>节点A 和节点 B 不在同一个集合，那么就可以将两个 节点连在一起。</li>
<li>如果边的两个节点已经出现在同一个集合里，说明着边的两个节点已经连在一起了，再加入这条边一定就出现环了。</li>
</ul>
<h3 id="代码实现-11"><a href="#代码实现-11" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] findRedundantConnection(<span class="type">int</span>[][] edges) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> edges.length;</span><br><span class="line">    father = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (!isSame(u, v)) &#123;</span><br><span class="line">            join(u, v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> edge;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="685-冗余连接II"><a href="#685-冗余连接II" class="headerlink" title="685.冗余连接II"></a>685.冗余连接II</h2><p>在本问题中，有根树指满足以下条件的 <strong>有向</strong> 图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。</p>
<p>输入一个有向图，该图由一个有着 <code>n</code> 个节点（节点值不重复，从 <code>1</code> 到 <code>n</code>）的树及一条附加的有向边构成。附加的边包含在 <code>1</code> 到 <code>n</code> 中的两个不同顶点间，这条附加的边不属于树中已存在的边。</p>
<p>结果图是一个以边组成的二维数组 <code>edges</code> 。 每个元素是一对 <code>[ui, vi]</code>，用以表示 <strong>有向</strong> 图中连接顶点 <code>ui</code> 和顶点 <code>vi</code> 的边，其中 <code>ui</code> 是 <code>vi</code> 的一个父节点。</p>
<p>返回一条能删除的边，使得剩下的图是有 <code>n</code> 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。</p>
<h3 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h3><p>那么有如下三种情况：</p>
<ol>
<li>前两种情况是出现入度为2的点，如图：</li>
</ol>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/685.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5II1.png" alt="img" style="zoom:50%;" /></p>
<blockquote>
<p>分别对这两条边删除，观察是否还能构成树，返回最后出现在给定二维数组的答案，因此用到了栈</p>
</blockquote>
<ol>
<li>第三种情况是没有入度为2的点，那么图中一定出现了有向环（<strong>注意这里强调是有向环！</strong>）</li>
</ol>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/685.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5II2.png" alt="img" style="zoom:50%;" /></p>
<blockquote>
<p>按照如果新加入的边的两点如果有相同的根节点，那么舍弃</p>
</blockquote>
<h3 id="代码实现-12"><a href="#代码实现-12" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] findRedundantDirectedConnection(<span class="type">int</span>[][] edges) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> edges.length;</span><br><span class="line">    father = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span>[] inDegrees = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];<span class="comment">//节点入度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">twoDegreesIdx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//计算入度为2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">        inDegrees[edges[i][<span class="number">1</span>]]++;</span><br><span class="line">        <span class="keyword">if</span> (inDegrees[edges[i][<span class="number">1</span>]] == <span class="number">2</span>) twoDegreesIdx = edges[i][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegrees[edges[i][<span class="number">1</span>]] == <span class="number">2</span>) &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stack.size() == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (solveTwoInDegrees(edges, stack.peek())) <span class="keyword">return</span> edges[stack.peek()];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            <span class="keyword">return</span> edges[stack.peek()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> edges[removeCircleEdge(edges)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeCircleEdge</span><span class="params">(<span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isSame(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>])) &#123;<span class="comment">//有环</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> join(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">solveTwoInDegrees</span><span class="params">(<span class="type">int</span>[][] edges, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; edges.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == i) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (isSame(edges[j][<span class="number">0</span>], edges[j][<span class="number">1</span>])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> join(edges[j][<span class="number">0</span>], edges[j][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code_Musing</category>
      </categories>
      <tags>
        <tag>graph_theory</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客论坛项目-前期</title>
    <url>/2024/06/04/%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E7%A4%BE%E5%8C%BA/%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p><strong>本节包括：</strong></p>
<ul>
<li>springMVC</li>
<li>SpringBoot</li>
<li>MyBatis</li>
</ul>
<span id="more"></span>
<h2 id="idea环境搭建"><a href="#idea环境搭建" class="headerlink" title="idea环境搭建"></a>idea环境搭建</h2><h3 id="安装maven"><a href="#安装maven" class="headerlink" title="安装maven"></a>安装maven</h3><p>配置user setting file</p>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/05/29/93211_image-20240529114248035.png" alt="image-20240529114248035" style="zoom:50%;" /></p>
<h3 id="创建maven项目"><a href="#创建maven项目" class="headerlink" title="创建maven项目"></a>创建maven项目</h3><p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/05/29/26610_image-20240529103158428.png" alt="image-20240529103158428" style="zoom:67%;" /></p>
<h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><p>IoC：Inversion of Control控制反转。传统的Java项目是程序员手动用new来实例化对象，而Spring是用IoC容器来管理对象（Spring中把需要管理的对象称为Bean）</p>
<p>控制：即实例化对象的权力<br>反转：由程序员手动用new关键词实例化变为Spring IoC容器管理实例化对象</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>Spring容器是一个管理Bean的容器，在Spring的定义里，所有IoC容器都要实现接口BeanFactory</p>
<p>由于<code>BeanFactory</code>功能不够强大，因此在BeanFactory的基础上还设计了一个更高级的接口<code>ApplicationContext</code>。ApplicationContext是BeanFactory的子接口，除此之外，ApplicationContext还提供了集成AOP、管理消息资源、发布事件、在应用层注入上下文等信息</p>
<h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p>我们可以把 <code>@SpringBootApplication</code>看作是 <code>@Configuration、@EnableAutoConfiguration、@ComponentScan</code> 注解的集合。<br>其中<br>@Configuration：代表这是一个Java配置类<br>@ComponentScan：扫描被@Component (@Service、@Controller、@Mapper等)注解的 Bean<br>@EnableAutoConfiguration：启用 SpringBoot 的自动配置机制</p>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>@Autowired会根据属性找到对应的Bean并注入。</p>
<p><code>@Primary</code>告诉IoC容器，当有多个同类型的Bean时，优先使用我注入</p>
<p><code>@Primary</code>可能修饰多个类，此时就不能单用@Primary来消除歧义，<code>@Qualifier</code>的配置项value需要一个字符串定义，这样Autowired就会通过类型和名称一起找到Bean</p>
<h2 id="spirngMVC入门"><a href="#spirngMVC入门" class="headerlink" title="spirngMVC入门"></a>spirngMVC入门</h2><h3 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h3><p><img src="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview/http_request.png" alt="一个基础的 HTTP 请求" style="zoom:50%;" /></p>
<h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><ol>
<li>三层架构<br>-表现层、业务层、数据访问层</li>
<li>MVC<br>-Model:模型层<br>-View:视图层<br>-Controller:控制层</li>
<li>核心组件<br>-前端控制器：DispatcherServlet</li>
</ol>
<p><img src="https://gitee.com/hollis7/pictures/raw/master/2024/06/03/93206_image-20240603164921159.png" alt="image-20240603164921159" style="zoom: 33%;" /></p>
<h3 id="thymeleaf"><a href="#thymeleaf" class="headerlink" title="thymeleaf"></a>thymeleaf</h3><p>开发是 建议关闭<code>thymeleaf</code>缓存，实时更新页面，部署时打开</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.thymeleaf.cache</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>
<p><a href="https://docs.spring.io/spring-boot/docs/3.2.7-SNAPSHOT/reference/html/application-properties.html#appendix.application-properties">手册</a></p>
<h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><h4 id="RequestMapping-RequestParam"><a href="#RequestMapping-RequestParam" class="headerlink" title="@RequestMapping@RequestParam"></a>@RequestMapping@RequestParam</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/students&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getStudents</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(name = &quot;current&quot;, required = false, defaultValue = &quot;1&quot;)</span> <span class="type">int</span> current,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestParam(name = &quot;limit&quot;, required = false, defaultValue = &quot;10&quot;)</span> <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">    System.out.println(current);</span><br><span class="line">    System.out.println(limit);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;some students&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RequestMapping-PathVariable"><a href="#RequestMapping-PathVariable" class="headerlink" title="@RequestMapping@PathVariable"></a>@RequestMapping@PathVariable</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/students/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getStudent</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span> &#123;</span><br><span class="line">    System.out.println(id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;a student&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/students&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">saveStudent</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    System.out.println(age);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>static/student.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/community/welcome/students&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        年龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;save&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="响应HTML数据"><a href="#响应HTML数据" class="headerlink" title="响应HTML数据"></a>响应HTML数据</h3><h4 id="ModelAndView-addObject"><a href="#ModelAndView-addObject" class="headerlink" title="ModelAndView addObject"></a>ModelAndView addObject</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/teacher&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">getTeacher</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">mav</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    mav.addObject(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    mav.addObject(<span class="string">&quot;age&quot;</span>, <span class="number">30</span>);</span><br><span class="line">    mav.setViewName(<span class="string">&quot;/demo/view&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Model-addAttribute-推荐"><a href="#Model-addAttribute-推荐" class="headerlink" title="Model addAttribute(推荐)"></a>Model addAttribute(推荐)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/school&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getSchool</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;北京大学&quot;</span>);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;age&quot;</span>, <span class="number">80</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/demo/view&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="响应JSON数据"><a href="#响应JSON数据" class="headerlink" title="响应JSON数据"></a>响应JSON数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/emp&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">getEmp</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; emp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    emp.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    emp.put(<span class="string">&quot;age&quot;</span>, <span class="number">23</span>);</span><br><span class="line">    emp.put(<span class="string">&quot;salary&quot;</span>, <span class="number">8000.00</span>);</span><br><span class="line">    <span class="keyword">return</span> emp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><h3 id="Mysql和MyBatis配置"><a href="#Mysql和MyBatis配置" class="headerlink" title="Mysql和MyBatis配置"></a>Mysql和MyBatis配置</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># DataSourceProperties</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/community?characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=Hongkong</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">passwd</span></span><br><span class="line"><span class="attr">spring.datasource.type</span>=<span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.maximum-pool-size</span>=<span class="string">15</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.minimum-idle</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.idle-timeout</span>=<span class="string">30000</span></span><br><span class="line"><span class="comment"># MybatisProperties</span></span><br><span class="line"><span class="attr">mybatis.mapper-locations</span>=<span class="string">classpath:mapper/*.xml</span></span><br><span class="line"><span class="attr">mybatis.type-aliases-package</span>=<span class="string">com.hdb.community.entity</span></span><br><span class="line"><span class="attr">mybatis.configuration.useGeneratedKeys</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">mybatis.configuration.mapUnderscoreToCamelCase</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
<h3 id="构造实体User"><a href="#构造实体User" class="headerlink" title="构造实体User"></a>构造实体User</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hdb.community.entity;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String salt;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> type;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> status;</span><br><span class="line">    <span class="keyword">private</span> String activationCode;</span><br><span class="line">    <span class="keyword">private</span> String headerUrl;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构建UserMapper"><a href="#构建UserMapper" class="headerlink" title="构建UserMapper"></a>构建UserMapper</h3><p>操作数据库数据的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hdb.community.dao;</span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    User <span class="title function_">selectById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line"></span><br><span class="line">    User <span class="title function_">selectByName</span><span class="params">(String username)</span>;</span><br><span class="line"></span><br><span class="line">    User <span class="title function_">selectByEmail</span><span class="params">(String email)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insertUser</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateStatus</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> status)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateHeader</span><span class="params">(<span class="type">int</span> id, String headerUrl)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updatePassword</span><span class="params">(<span class="type">int</span> id, String password)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="配置user-mapper-xml"><a href="#配置user-mapper-xml" class="headerlink" title="配置user-mapper.xml"></a>配置user-mapper.xml</h3><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;insertFields&quot;</span>&gt;</span></span><br><span class="line">    username</span><br><span class="line">    , password, salt, email, type, status, activation_code, header_url, create_time</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    insert into user(<span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;insertFields&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span>) values</span><br><span class="line">    (#&#123;username&#125;,#&#123;password&#125;,#&#123;salt&#125;,#&#123;email&#125;,#&#123;type&#125;,#&#123;status&#125;,#&#123;activationCode&#125;, #&#123;headerUrl&#125;, #&#123;createTime&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>parameterType=&quot;User&quot;</code>此参数指定了传递给 <code>insertUser</code> 操作的参数类型。在本例中，参数类型为 <code>User</code>，表示该方法将接收一个 <code>User</code> 对象作为参数。</li>
<li><code>keyProperty=&quot;id&quot;</code>此参数用于指定将要插入记录的主键值应该映射到 <code>User</code> 对象的哪个属性。在本例中，<code>keyProperty</code> 设置为 “id”，这意味着 MyBatis 会将数据库生成的 ID 值赋值给 <code>User</code> 对象的 <code>id</code> 属性。</li>
</ul>
<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateStatus&quot;</span>&gt;</span></span><br><span class="line">    update user</span><br><span class="line">    set status = #&#123;status&#125;</span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateHeader&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="debug模式"><a href="#debug模式" class="headerlink" title="debug模式"></a>debug模式</h3><p>为了调试时能发现mybatis的sql语法错误，因此将模式调整为debug模式</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging.level.com.hdb.community.dao</span>=<span class="string">debug</span></span><br><span class="line"><span class="attr">建议：</span></span><br><span class="line"><span class="attr">logging.level.com.hdb.community</span>=<span class="string">debug</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>forum</tag>
        <tag>nowcoder</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot项目调试</title>
    <url>/2024/06/05/%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E7%A4%BE%E5%8C%BA/springboot%E9%A1%B9%E7%9B%AE%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p><strong>本节包括：</strong></p>
<ul>
<li>日志类</li>
</ul>
<span id="more"></span>
<h2 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h2><p>采用<code>org.slf4j.Logger</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = CommunityApplication.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggerTests</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(LoggerTests.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLogger</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(logger.getName());</span><br><span class="line"></span><br><span class="line">        logger.debug(<span class="string">&quot;debug log&quot;</span>);</span><br><span class="line">        logger.info(<span class="string">&quot;info log&quot;</span>);</span><br><span class="line">        logger.warn(<span class="string">&quot;warn log&quot;</span>);</span><br><span class="line">        logger.error(<span class="string">&quot;error log&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Logger配置"><a href="#Logger配置" class="headerlink" title="Logger配置"></a>Logger配置</h2><p>不推荐，没有分类，也没有考虑日志文件过大问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logging.file.name=C:/data/tmpDown/community.log</span><br></pre></td></tr></table></figure>
<p><strong>推荐：</strong></p>
<p><code>logback-spirng.xml</code>放在<code>resource</code>目录下</p>
<p>超过5M会创建新的日志文件，超过30天删除</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- error file --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE_ERROR&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;LOG_PATH&#125;/$&#123;APPDIR&#125;/log_error.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;LOG_PATH&#125;/$&#123;APPDIR&#125;/error/log-error-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>5MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">append</span>&gt;</span>true<span class="tag">&lt;/<span class="name">append</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d %level [%thread] %logger&#123;10&#125; [%file:%line] %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">charset</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span>&gt;</span>error<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>只需要该模板的几处</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">contextName</span>&gt;</span>community<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_PATH&quot;</span> <span class="attr">value</span>=<span class="string">&quot;C:\data\tmpDown&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;APPDIR&quot;</span> <span class="attr">value</span>=<span class="string">&quot;community&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.hdb.community&quot;</span> <span class="attr">level</span>=<span class="string">&quot;debug&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>forum</tag>
        <tag>nowcoder</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客论坛项目-前期</title>
    <url>/2024/06/05/%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E7%A4%BE%E5%8C%BA/%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E5%BC%80%E5%8F%911/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer"/>

<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p><strong>本节包括：</strong></p>
<ul>
<li>首页开发</li>
<li>帖子列表处理</li>
<li>帖子分页查询</li>
</ul>
<span id="more"></span>
<h2 id="论坛帖子查询"><a href="#论坛帖子查询" class="headerlink" title="论坛帖子查询"></a>论坛帖子查询</h2><h4 id="1-数据层"><a href="#1-数据层" class="headerlink" title="1 数据层"></a>1 数据层</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hdb.community.dao;</span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DiscussPostMapper</span> &#123;</span><br><span class="line">    List&lt;DiscussPost&gt; <span class="title function_">selectDiscussPosts</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> offset, <span class="type">int</span> limit)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @Param注解用于给参数取别名,</span></span><br><span class="line">    <span class="comment">// 如果只有一个参数,并且在&lt;if&gt;里使用,则必须加别名.</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">selectDiscussPostRows</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span> <span class="type">int</span> userId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.hdb.community.dao.DiscussPostMapper&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;selectFields&quot;</span>&gt;</span></span><br><span class="line">    id</span><br><span class="line">    , user_id, title, content, type, status, create_time, comment_count, score</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectDiscussPosts&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hdb.community.entity.DiscussPost&quot;</span>&gt;</span></span><br><span class="line">    select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;selectFields&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span> from discuss_post where status != 2</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userId!=0&quot;</span>&gt;</span></span><br><span class="line">        and user_id= #&#123;userId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    order by type desc, create_time desc</span><br><span class="line">    limit #&#123;offset&#125;,#&#123;limit&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectDiscussPostRows&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span></span><br><span class="line">    select count(id) from discuss_post where status != 2</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;userId!=0&quot;</span>&gt;</span></span><br><span class="line">        and user_id= #&#123;userId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意limit分页和sql语法</p>
<h4 id="2-业务层"><a href="#2-业务层" class="headerlink" title="2 业务层"></a>2 业务层</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hdb.community.service;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiscussPostService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscussPostMapper discussPostMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;DiscussPost&gt; <span class="title function_">findDiscussPosts</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> offset, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> discussPostMapper.selectDiscussPosts(userId, offset, limit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDiscussPostRows</span><span class="params">(<span class="type">int</span> userId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> discussPostMapper.selectDiscussPostRows(userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模板黏贴"><a href="#模板黏贴" class="headerlink" title="模板黏贴"></a>模板黏贴</h2><p><code>css, img, js</code> 复制到项目static下</p>
<p><code>site、index.html</code>复制到templates目录下</p>
<h2 id="开发视图层"><a href="#开发视图层" class="headerlink" title="开发视图层"></a>开发视图层</h2><h3 id="资源引入修改"><a href="#资源引入修改" class="headerlink" title="资源引入修改"></a>资源引入修改</h3><p>资源应用，css，js等路径需要加上th，让thymeleaf自己去寻找static目录下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/css/global.css&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/js/global.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/js/index.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscussPostService discussPostService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;/index&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getIndexPage</span><span class="params">(Model model)</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;DiscussPost&gt; list = discussPostService.findDiscussPosts(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; discussPosts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (list != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (DiscussPost post : list) &#123;</span><br><span class="line">                Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                map.put(<span class="string">&quot;post&quot;</span>, post);</span><br><span class="line">                <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findUserById(post.getUserId());</span><br><span class="line">                map.put(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">                discussPosts.add(map);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;discussPosts&quot;</span>, discussPosts);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>map存储数据，存储用户和帖子信息，List数据发送到前端</p>
<h3 id="帖子列表处理"><a href="#帖子列表处理" class="headerlink" title="帖子列表处理"></a>帖子列表处理</h3><p>删除重复的列表，循环即可</p>
<p>利用thymeleaf的each进行循环</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;media pb-3 pt-3 mb-3 border-bottom&quot;</span> <span class="attr">th:each</span>=<span class="string">&quot;map:$&#123;discussPosts&#125;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>帖子title</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">th:utext</span>=<span class="string">&quot;$&#123;map.post.title&#125;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>判断语句</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;badge badge-secondary bg-primary&quot;</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;map.post.type==1&#125;&quot;</span>&gt;</span>置顶<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;badge badge-secondary bg-danger&quot;</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;map.post.status==1&#125;&quot;</span>&gt;</span>精华<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>thymeleaf时间格式化</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">u</span> <span class="attr">class</span>=<span class="string">&quot;mr-3&quot;</span> <span class="attr">th:utext</span>=<span class="string">&quot;$&#123;map.user.username&#125;&quot;</span>&gt;</span>寒江雪<span class="tag">&lt;/<span class="name">u</span>&gt;</span> 发布于 <span class="tag">&lt;<span class="name">b</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#dates.format(map.post.createTime,&#x27;yyyy-MM-dd HH:mm:ss&#x27;)&#125;&quot;</span>&gt;</span>2019-04-15 15:32:18<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>#dates.format(var,&#39;yyyy-MM-dd HH:mm:ss&#39;)</code>是thymeleaf内置的时间格式化工具，<code>yyyy-MM-dd HH:mm:ss</code>是开发者填入的参数</p>
<h3 id="分页封装"><a href="#分页封装" class="headerlink" title="分页封装"></a>分页封装</h3><h4 id="Page"><a href="#Page" class="headerlink" title="Page"></a>Page</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Page</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前页码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 显示上限</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 数据总数(用于计算总页数)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rows;</span><br><span class="line">    <span class="comment">// 查询路径(用于复用分页链接)</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCurrent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前页的起始行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOffset</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// current * limit - limit</span></span><br><span class="line">        <span class="keyword">return</span> (current - <span class="number">1</span>) * limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取总页数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTotal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// rows / limit [+1]</span></span><br><span class="line">        <span class="keyword">if</span> (rows % limit == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rows / limit;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rows / limit + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取起始页码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFrom</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> current - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> from &lt; <span class="number">1</span> ? <span class="number">1</span> : from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取结束页码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> current + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> getTotal();</span><br><span class="line">        <span class="keyword">return</span> to &gt; total ? total : to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>set方法需要做一些校验</p>
<h4 id="html配置"><a href="#html配置" class="headerlink" title="html配置"></a>html配置</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;mt-5&quot;</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;page.rows&gt;0&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;pagination justify-content-center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;page-item&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;page-link&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;$&#123;page.path&#125;(current=1)&#125;&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">th:class</span>=<span class="string">&quot;|page-item $&#123;page.current==1?&#x27;disabled&#x27;:&#x27;&#x27;&#125;|&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;page-link&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;$&#123;page.path&#125;(current=$&#123;page.current-1&#125;)&#125;&quot;</span>&gt;</span>上一页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">th:class</span>=<span class="string">&quot;|page-item $&#123;i==page.current?&#x27;active&#x27;:&#x27;&#x27;&#125;|&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">th:each</span>=<span class="string">&quot;i:$&#123;#numbers.sequence(page.from,page.to)&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;page-link&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;$&#123;page.path&#125;(current = $&#123;i&#125;)&#125;&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;i&#125;&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">th:class</span>=<span class="string">&quot;|page-item $&#123;page.current==page.total?&#x27;disabled&#x27;:&#x27;&#x27;&#125;|&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;page-link&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;$&#123;page.path&#125;(current=$&#123;page.current+1&#125;)&#125;&quot;</span>&gt;</span>下一页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;page-item&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;page-link&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;$&#123;page.path&#125;(current=$&#123;page.total&#125;)&#125;&quot;</span>&gt;</span>末页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>$&#123;page.current==1?&#39;disabled&#39;:&#39;&#39;</code>是首页不可以点击上一页</p>
<p><code>th:class=&quot;|page-item $&#123;i==page.current?&#39;active&#39;:&#39;&#39;&#125;|&quot;</code>点亮当前页按钮</p>
<p>`th:each=”i:$</p>
]]></content>
      <categories>
        <category>nowcoder</category>
      </categories>
      <tags>
        <tag>forum</tag>
        <tag>nowcoder</tag>
      </tags>
  </entry>
</search>
