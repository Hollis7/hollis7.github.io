---
title: Hello World
categories:
- my_post
tags:
- centos7 5.3
---
#### 引入构造函数

```c++
引入构造函数
#include<iostream>
#include<string>
#define DEFAULT_BUF_SIZE 64
using namespace std;
class CString {
	char* buf;
	int size;
public:
	bool copy(char* str);
	char* get();
	CString();
	void deinit();
};
CString::CString() {
	size = DEFAULT_BUF_SIZE;
	buf = new char[size];
}
bool CString::copy(char* str) {
	if (str == NULL)
		return false;
	if ((strlen(str) + 1) > size)
		return false;
	strcpy_s(buf, strlen(str) + 1, str);
	return true;
}
char* CString::get() { return buf; }
void CString::deinit() {
	if (buf != NULL)
		delete[]buf;
}
int main() {
	CString aStr;
	char character1[] = "hello";
	aStr.copy(character1);
	char* p = aStr.get();
	if (p == NULL)
		cout << "str is NULL" << endl;
	else cout << "str is :" << character1<<endl<< aStr.get() << endl;
	aStr.deinit();
	system("pause");
	return 0;


}
```

#### 析构函数

~~~c++
#include<iostream>
#include<string>
#define DEFAULT_BUF_SIZE 64
using namespace std;
class CString {
	char* buf;
	int size;
public:
	bool copy(char* str);
	char* get();
	CString();
	~CString();
    //自动初始化和释放
};
CString::CString() {
	size = DEFAULT_BUF_SIZE;
	buf = new char[size];
}
bool CString::copy(char* str) {
	if (str == NULL)
		return false;
	if ((strlen(str) + 1) > size)
		return false;
	strcpy_s(buf, strlen(str) + 1, str);
	return true;
}
char* CString::get() { return buf; }
CString::~CString() {//替代delete函数，防止内存泄漏
	if (buf != NULL)
		delete[]buf;
}
int main() {
	CString aStr;
	char character1[] = "hello";
	aStr.copy(character1);
	char* p = aStr.get();
	if (p == NULL)
		cout << "str is NULL" << endl;
	else cout << "str is :" << character1 << endl << aStr.get() << endl;
	system("pause");
	return 0;


}
~~~

#### 重载构造函数

~~~c++
#include<iostream>
#include<string>
#define DEFAULT_BUF_SIZE 64
using namespace std;
class CString {
	char* buf;
	int size;
public:
	bool copy(char* str);
	char* get();
	CString();
	~CString();
	CString(int n);
	CString(char* str);
	//void deinit();
};
CString::CString() {
	size = DEFAULT_BUF_SIZE;
	buf = new char[size];
}
CString::CString(int n) {
	if (n > 0) {
		size = n;
		buf = new char[size];
	}
}
CString::CString(char* str) {
	if (str != NULL) {
		size = strlen(str) + 1;
		buf = new char[size];
		strcpy_s(buf, size, str);
	}
}
bool CString::copy(char* str) {
	if (str == NULL)
		return false;
	if ((strlen(str) + 1) > size)
		return false;
	strcpy_s(buf, strlen(str) + 1, str);
	return true;
}
char* CString::get() { return buf; }
CString::~CString() {
	if (buf != NULL)
		delete[]buf;
}

int main() {
	CString str1;//此时调用的是CString()构造函数
	char character1[] = "Welcome";
	str1.copy(character1);

	CString str2(16);//此时调用的是CString(int n)构造函数
	char character2[] = "to";
	str2.copy(character2);

	char character3[] = "Uestc";
	CString str3(character3);//此时调用的是CString(char*)构造函数

	char* p = str1.get();
	if (p == NULL)
		cout << "str1 is NULL" << endl;
	else
		cout << "strl is:" << p << endl;
	p = str2.get();
	if (p == NULL)
	 cout << "str2 is NULL" << endl;
	else cout << "str2 is:" << p << endl;
	p = str3.get();
	if (p == NULL)
	 cout << "str3 is NULL" << endl;
	else cout << "str3 is:" << p << endl;
	system("pause");
	return 0;
}
~~~

#### 对象数组

与任何其他数据类型一样，可以创建对象数组。以CString类为例，CString对象数组的声明语句如下：

> CString stringArray [8];

数组中的每个元素都代表一个CString对象，因此可以通过下标的方式访问每一个对象元素，进而访问该对象的公有成员。例如：

> stringArray [index].copy (str); (其中：0≤index＜8，str指向一个字符串)

定义数组必然涉及数组元素初始化问题，对象数组也不例外。对象数组的初始化过程，实际上就是调用构造函数对每一个数组元素进行初始化的过程，至于调用哪个构造函数则取决于在声明数组时所给出的数组元素的初始值。
例8-7 用例8-6定义的CString字符串类，作为数组元素操作，参考程序如下。

```c++
//8-7.cpp
int main (){
CString strArray [3]=(CString(),CString (10),CString("chengdu"));
strArray [0].copy ("Welcome");
strArray [1].copy ("to");
for(int i=0;i<3;i++){
    char *p=strArray [i].get();
    cout<<p<<"";
}
return 0;
}
```

#### 对象指针

与C语言类似，可以使用指向对象的指针变量来访问对象以及对象的公有成员。以CString类为例，CString对象指针的定义和用法示例如下。 

```c++
int main() {
	CString *pstr;
	CString str(10);
	pstr = &str;
	char str1[] = "hello";
	pstr->copy(str1);
	char* p = pstr->get();
	cout << "str: " << p << endl;
	system("pause");
	return 0;
}
```

上述代码中，pstr指向str对象，pstr也就代表了str对象，**因此通过pstr可以调用CSring类中定义的公有函数copy 和get。**

对象指针还可以指向通过new方式动态创建的对象。例如：

```c++
CString *pstr;
pstr=new CString(16);
pstr->copy(str1);
char* p = pstr->get();
cout << "str: " << p << endl;
delete pstr;
```

==**new创建，delete释放**==

#### 对象指针作为传参

```c++
void changeString_2(CString* pstr) {
	char word2[] = "Hello World";
	pstr->copy(word2);
}
int main() {
	CString str(32);
	char* p;
	char word1[] = "hello China";
	str.copy(word1);
	p = str.get();
	cout << "before change:" << p << endl;
	changeString_2(&str);
	p = str.get();
	cout << "after change:" << p << endl;
	system("pause");
	return 0;
}
```

#### 对象引用作为指针

```c++
void changeString_3(CString &refstr) {
	char word2[] = "Hello World";
	refstr.copy(word2);
}
```

### 静态成员

#### 静态数据成员

> 类的所有对象共享静态数据成员，因此无论建立多少个该类的对象，静态数据成员只有
> 一份副本。==静态数据成员属于类，而不属于具体的对象==。

#### 友元函数

```c++
class Point{
    ...
friend float Distance(Point a, Point b);
};
float Distance (Point a, Point b){
float dx,dy;
dx=a.x-b.x;
dy=a.y-b.y;
return sgrt (dx dx+ dy  dy);
}
int main(){
Point pl(3.0,5,0);
Point p2(4.0,6.0);
float d=Distance(pl, p2);
cout <<*The distance is:"c<d<<endl;
system("pause”);
return 0;
       }
```

> Distance是普通函数，按理来说该函数不能直接引用对象的非public成员。但一旦把其声明为Point类的**友元函数**，这种限制就打破了，允许在 Distance函数中直接引用包括private在内的任何访问控制属性的成员。正如我们所看到的那样，Distance函数中无须再调用Getx和GetY公有成员函数来获取“点”的坐标。

> 友元函数本身不属于类的成员函数，**因此友元函数没有this指针**。友元函数的调用方式和普通函数是一样的

#### 友元类

以下面的X、Y类为例，在X中声明Y是X的友元类(因为Y的定义在X的后面，因此需要在X前面对Y进行向前声明，以便能够编译通过)，==**然后Y定义中的所有成员函数都可以直接操作X的所有访问属性的成员。**==

```c++
class Y;//向前说明
class X{
int x;
friend class Y;//将类Y声明为类×的友元类
public:
void show(){cout <<x;}
};

class Y{
public:
void SetX(X &obj,int v){
obj.x=v；//可以直接操作obj对象的privat属性的数据成员x
}
};

int main(){
X xobj;
Y yobj;
yobj.SetX(xobj,5);
xobj.show();
system("pause");
return 0;
}//输出：5
```

当然了，我们也可以把一个类的某几个成员函数说明为另外一个类的友元函数。比如，在类Y中有SetX和fune两个成员函数，我们只想将SetX声明为X的友元函数，那么只需要在X中将该函数进行友元声明。==**此时，Y中只有这个SetX成员函数可以访问X的私有成员，而Y的func函数是不能直接访问X的私有成员的，而只能通过X提供的公有成员函数间接访问。**==

```c++
#include<iostream>
#include<string>
using namespace std;
class X;//向前说明
class Y {
public:
	void SetX(X &obj, int v);
	void func(X &obj) {  };
};

class X {
	int x;
	friend void Y::SetX(X &obj, int v);//只将类Y的SetX声明为类x的友元函数	
public:
	void show() {
		cout << x;
	}
};
void Y::SetX(X &obj, int v) {
	obj.x = v;//可以直接操作obj对象的private属性的数据成员x
}
int main() {
	X xobj;
	Y yobj;
	yobj.SetX(xobj, 5);
	xobj.show();
	return 0;
}
//输出：5
```

### 常对象

#### 常成员

常成员函数的定义方式如下：

```
返回类型  成员函数名(参数表)   const;
```

==必须是要将const关键字放在函数原型的后面，如果将const放在函数原型的前面，意味着函数的返回值是一个常量，语义和常成员函数完全不同==。
(1)下面的代码可以帮助我们了解常对象定义与使用方式，以及常见的错误及原因。

```c++
int main(){
const CString str1 ("hello");//定义常对象str1
CString str2 ("world");
char *p;
strl=str2; //编译错误!str1为常对象,不能被赋值
p=str1.get (); //编译错误,因为get不是常成员函数,不能被常对象str1调用cout <<"strl:"<<p<<endl;
system("pause");
return0;
}
```

由于strl是常对象，strl=str2；语句意图修改常对象strl，因此会发生编译错误。对于常对象，只能调用常成员函数，由于get不是常成员函数，因此p=str1.get()；语句会发生编译错误。如果想让常对象strl调用get函数，则需要将 get函数改为常成员函数，如下所示：

```c++
class CString{
char  *get() const；//在函数原型后面加上const，声明为常成员函数
}；
char *CString::get() const(return buf;)//类外实现常成员函数，函数名称后面也要加 const
```

**用一个简单的例子来分析如何定义和使用常数据成员：**

```c++
#include<iostream>
#include<string>
using namespace std;
class Employee {
	const unsigned int id;//工号
	float salary;//工资
public:
	Employee(unsigned newID, float newSalary) :id(newID) {
		//id=newID;//因为id是常数据成员,因此不能以赋值语句形式对id进行初始化
		salary = newSalary;
	}
	unsigned int getID()const { return id; }
	float getSalary() { return salary; }
	void setSalary(float newSalary) { salary = newSalary; }
};
int main() {
	Employee employee(45, 3000);
	cout << "employee Info:" << endl;
	cout << "id:" << employee.getID() << endl;
	cout << "salary:" << employee.getSalary() << endl;
	system("pause");
	return 0;
}
```

### 练习

//first

```c++
#include<iostream>
#include<string>
using namespace std;
class MyClass {
public:
	int number;
	void set(int i);
};
	int number = 3;
	void MyClass::set(int i) {
		number = i;
	}
	int main() {
		MyClass my1;
		int number = 10;
		my1.set(5);
		cout << my1.number << endl; 
		my1.set(number);
		cout << my1.number << endl; 
		my1.set(::number);
		cout << my1.number;
	}
//输出:
5
10
3
```

//second

```c++
#include<iostream>
#include<string>
using namespace std;
class Location {
public:
	int x, y;
	void init(int initX, int initY) {
		x = initX;
		y = initY;
	}
	int GetX() { return x; }
	int GetY() { return y; }
};
	void display(Location& rL) {
		cout << rL.GetX() << " " << rL.GetY() << endl;
	}
	void main() {
		Location A[5] = { {0,0},{1,1},{2,2},{3,3},{4,4} };
		Location * rA = A;
		A[3].init(5, 3);
		rA->init(7, 8);
		for (int i = 0; i < 5; ++i)
			display(*(rA++));
	}
//DISPLAY:
7 8
1 1
2 2
5 3
4 4
```

### Complex和运算符重载

```c++
//用友元函数重载complex类+运算符
#include <iostream>
using namespace std;
class Complex {
	double re, im;
public:
	Complex(double r = 0.0, double i = 0.0) :re(r), im(i) {};
	friend Complex operator + (Complex c1, Complex c2);
	void GetReANDIm();
};
void Complex::GetReANDIm() {
	cout << "实部：" << this->re << endl << "虚部：" << this->im << endl;
}
Complex operator + (Complex c1, Complex c2) {
	Complex t;
	t.re = c1.re + c2.re;
	t.im = c1.im + c2.im;
	return t;
}
	int main(){
		Complex c1(1, 2);
	c1 = c1 + 27;
	c1.GetReANDIm();
	c1 = 27 + c1;
	c1.GetReANDIm();
	system("pause");
	return 0;
	}
//output:
实部：28
虚部：2
实部：55
虚部：2

```

```c++
//用友元函数重载输出流<<运算符
#include <iostream>
using namespace std;
class Complex {
	double re, im;
public:
	Complex(double r = 0.0, double i = 0.0) :re(r), im(i) {};
	friend Complex operator + (Complex c1, Complex c2);
	void GetReANDIm();
	friend ostream& operator << (ostream& out, Complex& obj);
};
void Complex::GetReANDIm() {
	cout << "实部：" << this->re << endl << "虚部：" << this->im << endl;
}
Complex operator + (Complex c1, Complex c2) {
	Complex t;
	t.re = c1.re + c2.re;
	t.im = c1.im + c2.im;
	return t;
}
ostream& operator<< (ostream& out, Complex& obj) {
	out << obj.re << "+" << obj.im << "i";
		return out;
}
int main() {
	Complex obj(3, 4);
	cout << "the obj is:" << endl;
	cout << obj << endl;

	Complex obj2(7, 7);
	cout << "the obj2 is(before):" << endl;
	cout << obj2<< endl;

	obj2 = obj + obj2;
	cout << "the obj2 is(before):" << endl;
	cout << obj2 << endl;

	system("pause");
	return 0;
}
//output:
the obj is:
3+4i
the obj2 is(before):
7+7i
the obj2 is(before):
10+11i
```

### 赋值兼容原则

```c++
#include<iostream>
using namespace std;
class animal {
public:
	void eat() { cout << "animal is eating"<<endl; };
};
class dog : public animal {
public:
	void eat() { cout << "dog is eating" << endl; };
};
int main() {
	animal a;
	dog d;
	d.eat();//输出"dog is eating"
	a = d;//成功,因为"所有的狗都是动物"
	a.eat();//输出"animal is eating";
	animal& ref_a = d;
	ref_a.eat();//输出"animal is eating";
	animal* pointer_a = &d;
	pointer_a->eat();//输出"animal is eating"; 
	return 0;
}
//output：
dog is eating
animal is eating
animal is eating
animal is eating
    
```

### 虚函数

#### 概念理解

只有在程序运行时才能确定基ShoppingCard指针所指向对象的类型，而只有在确定对象的类型后才能确定调用哪consume 函数。C++中的虚函数能够帮助我们达到这一目的。我们只需要对基类ShoppingCard 中的consume函数稍加修改，用virtual关键字定义为虚函数，如下所示：

```c++
class ShoppingCard{
public:
virtualbool consume (float money ) {...}
};
```

此时，consume函数的调用匹配不取决于指针类型(即ShoppingCard指针)，**而取决于指针所指向的对象。由于指针所指向的对象在程序运行时才能确定，因此consume函数的调用匹配也只会在程序运行时进行，这一过程就是所谓的动态绑定。**

#### 虚函数使用步骤

**下面，我们总结一下定义和使用虚函数的过程**
1、在基类中用virtual关键字将成员函数声明为虚函数。
2 、在派生类中重定义基类的虚函数，但要求函数的原型(包括返回值类型、函数名、参数列表)必须完全相同。
3、==定义基类指针或引用，使其指向基类或派生类对象==。当通过该指针或引用调用函数时，该函数体现虚拟性。

#### 以Print为例

```c++
//9-17.cpp
#include <iostream>
using namespace std;
class Base {
public:
	virtual void Print() { cout << "I am Base\n"; };
};
class Derived :public Base {
public:
	void Print() { cout << "I am Derived\n"; };
};
int main() {
	Base base, *p;
	Derived derived;
	p= &base;
	p->Print();//调用基类的Print
	p = &derived;
	p->Print();//调用派生类的Print
    system("pause");
	return 0;
}
//output:
I am Base
I am Derived
```

#### 虚函数表VTABLE

在程序编译阶段：编译器为定义了虚函数的类建立一张虚函数表VTABLE(即函数指针数组)，表中的每个元素保存的是每个虚函数的地址(即虚函数第一条指令的地址)。如果派生类重新定义了基类的虚函数，那么派生类的虚函数表将保存新函数的地址；否则，派生类的虚函数表将保存基类所定义的虚函数地址。同时，用一个虚函数表指针VPTR指向这张表的入口。

从前面的章节我们知道，一个对象的内存空间由数据成员构成，事实上，编译器为定义了虚函数的类的对象还添加了一个隐藏成员，该隐藏成员保存的是==虚函数表指针VPTR==。当一个对象被创建时，==在构造函数完成数据成员初始化后会初始化VPTR==，**让VPTR指向该对象所属类的虚函数表**(注：初始化VPTR的代码由编译器额外添加，对程序员来说完全透明)。以示例9-17为例，基类对象、派生类对象、虚函数表、VPTR的关系如图所示。

<img src="E:\软件\typora picture huang\image-20210131203906237.png" alt="image-20210131203906237" style="zoom:67%;" />

#### 虚析构函数

对于良好的程序设计来说，需要将基类的析构函数声明为虚函数是有必要的，即便该析构函数不执行任何操作。

#### 纯虚函数及抽象类

​	我们知道，图形是一块有轮廓边界的区域。对于一个图形来说，它有周长和面积。由于“图形”本身是一个抽象的概念，因此要获知一个抽象图形的周长和面积是不可能的，除非明确知道是哪种图形。例如，圆、长方形都是图形，能够根据相应的数学公式计算这两类图形的周长和面积。此外，即便是不规则的图形，也可以通过数学方法来计算(例如，可以通过积分计算面积)。

​	下面，用Shape、Circle、Rectangle 3个类来分别描述图形、圆以及长方形，不难看出，Circle和 Rectangle都是Shape的派生类，这3个类的继承关系为：Circle---->Shape<----Rectangle。

​	对于Shape类来说，该类中计算周长的函数(Perimeter)和计算面积的函数(Area)只能声明为==纯虚函数==，因为我们没法写出如何计算周长和面积的代码，此时，Shape类就是一个抽象类，而且是接口类。而对于Circle和 Rectangle，需要实现这两个纯虚函数，因为可以根据数学公式写出相应的计算代码。

```c++
#include <iostream>
using namespace std;
const float pi = 3.14;
class Shape {
public:
	virtual float Perimeter() = 0;
	virtual float Area() = 0;
};
class Circle :public Shape {
	float r;
public:
	Circle(float r) { this->r = r; }
	float Perimeter() { return 2 * pi * r; }
	float Area() { return pi * r * r; }
};
class Rectangle :public Shape {
	float l, h;
public:
	Rectangle(float l, float h) { this->l = l, this->h = h; }
	float Perimeter() { return 2 * (l + h); }
	float Area() { return l * h; }
};
int main() {
	Shape* p;
	Circle circle(5);
	Rectangle rectangle(3, 4);
	p = &circle;
	cout << "Perimeter:" << p->Perimeter() << "," << "Area:" << p->Area() << endl;
	p = &rectangle;
	cout << "Perimeter:" << p->Perimeter() << "," << "Area:" << p->Area() << endl;
	system("pause");
	return 0;
}
//output:
Perimeter:31.4,Area:78.5
Perimeter:14,Area:12
```

