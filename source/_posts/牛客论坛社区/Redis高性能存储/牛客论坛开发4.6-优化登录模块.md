---
title: 牛客论坛项目-优化登录模块
categories:
- nowcoder
tags:
- Redis
- nowcoder
---
<meta name="referrer" content="no-referrer"/>

## 内容

**本节包括：**

- redis优化登录模块

<!--more-->

## redis优化的登录模块

使用Redis存储验证码

- 验证码需要频繁的访问与刷新，对性能要求较高
- 验证码不需永久保存，通常在很短的时间后就会失效。
- 分布式部署时，存在Session共享的问题

使用Redis存储登录凭证

- 处理每次请求时，都要查询用户的登录凭证，访问的频率非常高。

使用Redis缓存用户信息

- 处理每次请求时，都要根据凭证查询用户信息，访问的频率非常高

## 具体实现

### 登录验证码优化

#### 修改RedisKeyUtil

~~~java
private static final String PREFIX_KAPTCHA = "kaptcha";
// 登录验证码
public static String getKaptchaKey(String owner) {
    return PREFIX_KAPTCHA + SPLIT + owner;
}
~~~

#### 修改LoginController

~~~java
@RequestMapping(path = "/kaptcha", method = RequestMethod.GET)
public void getKaptcha(HttpServletResponse response/*, HttpSession session*/) {
    // 生成验证码
    String text = kaptchaProducer.createText();
    BufferedImage image = kaptchaProducer.createImage(text);

    // 将验证码存入session
    //session.setAttribute("kaptcha", text);

    // 验证码的归属
    String kaptchaOwner = CommunityUtil.generateUUID();
    Cookie cookie = new Cookie("kaptchaOwner", kaptchaOwner);
    cookie.setMaxAge(60);
    cookie.setPath(contextPath);
    response.addCookie(cookie);

    // 将验证码存入Redis
    String redisKey = RedisKeyUtil.getKaptchaKey(kaptchaOwner);
    redisTemplate.opsForValue().set(redisKey, text, 60, TimeUnit.SECONDS);
    // 将突图片输出给浏览器
    response.setContentType("image/png");
    try {
        OutputStream os = response.getOutputStream();
        ImageIO.write(image, "png", os);
    } catch (IOException e) {
        logger.error("响应验证码失败:" + e.getMessage());
    }
}

@RequestMapping(path = "/login", method = RequestMethod.POST)
public String login(String username, String password, String code, boolean rememberme,
                    Model model, /*HttpSession session, */HttpServletResponse response,
                    @CookieValue("kaptchaOwner") String kaptchaOwner) {
    // 检查验证码
    // String kaptcha = (String) session.getAttribute("kaptcha");
    String kaptcha = null;
    if (StringUtils.isNotBlank(kaptchaOwner)) {
        String redisKey = RedisKeyUtil.getKaptchaKey(kaptchaOwner);
        kaptcha = (String) redisTemplate.opsForValue().get(redisKey);
    }

    if (StringUtils.isBlank(kaptcha) || StringUtils.isBlank(code) || !kaptcha.equalsIgnoreCase(code)) {
        model.addAttribute("codeMsg", "验证码不正确!");
        return "/site/login";
    }

    // 检查账号,密码
    int expiredSeconds = rememberme ? REMEMBER_EXPIRED_SECONDS : DEFAULT_EXPIRED_SECONDS;
    Map<String, Object> map = userService.login(username, password, expiredSeconds);
    if (map.containsKey("ticket")) {
        Cookie cookie = new Cookie("ticket", map.get("ticket").toString());
        cookie.setPath(contextPath);
        cookie.setMaxAge(expiredSeconds);
        response.addCookie(cookie);
        return "redirect:/index";
    } else {
        model.addAttribute("usernameMsg", map.get("usernameMsg"));
        model.addAttribute("passwordMsg", map.get("passwordMsg"));
        return "/site/login";
    }
}
~~~

### 登录凭证优化

#### 修改RedisKeyUtil

~~~java
private static final String PREFIX_TICKET = "ticket";
// 登录的凭证
public static String getTicketKey(String ticket) {
    return PREFIX_TICKET + SPLIT + ticket;
}
~~~

#### 废弃LoginTicketMapper

~~~java
@Mapper
@Deprecated
public interface LoginTicketMapper {
~~~

`@Deprecated`表示不推荐这个组件使用

#### 修改UserService

~~~java
@Autowired
private RedisTemplate redisTemplate;
~~~

~~~java
 public Map<String, Object> login(String username, String password, int expiredSeconds) {
      ......
        // 生成登录凭证
        LoginTicket loginTicket = new LoginTicket();
        loginTicket.setUserId(user.getId());
        loginTicket.setTicket(CommunityUtil.generateUUID());
        loginTicket.setStatus(0);
        loginTicket.setExpired(new Date(System.currentTimeMillis() + expiredSeconds * 1000));
//        loginTicketMapper.insertLoginTicket(loginTicket);
        String redisKey = RedisKeyUtil.getTicketKey(loginTicket.getTicket());
        redisTemplate.opsForValue().set(redisKey, loginTicket);

        map.put("ticket", loginTicket.getTicket());
        return map;
    }
~~~

~~~java
public void logout(String ticket) {
    //        loginTicketMapper.updateStatus(ticket, 1);
    String redisKey = RedisKeyUtil.getTicketKey(ticket);
    LoginTicket loginTicket = (LoginTicket) redisTemplate.opsForValue().get(redisKey);
    loginTicket.setStatus(1);
    redisTemplate.opsForValue().set(redisKey, loginTicket);
}

public LoginTicket findLoginTicket(String ticket) {
    //        return loginTicketMapper.selectByTicket(ticket);
    String redisKey = RedisKeyUtil.getTicketKey(ticket);
    return (LoginTicket) redisTemplate.opsForValue().get(redisKey);
}
~~~

### 缓存用户信息

每次更新用户信息要及时清除redis缓存信息

#### 续写RedisKeyUtil

~~~java
private static final String PREFIX_USER = "user";
public static String getUserKey(int userId) {
    return PREFIX_USER + SPLIT + userId;
}
~~~

#### 修改UserService

~~~java
// 1.优先从缓存中取值
private User getCache(int userId) {
    String redisKey = RedisKeyUtil.getUserKey(userId);
    return (User) redisTemplate.opsForValue().get(redisKey);
}

// 2.取不到时初始化缓存数据
private User initCache(int userId) {
    User user = userMapper.selectById(userId);
    String redisKey = RedisKeyUtil.getUserKey(userId);
    redisTemplate.opsForValue().set(redisKey, user, 3600, TimeUnit.SECONDS);
    return user;
}
// 3.数据变更时清除缓存数据
private void clearCache(int userId) {
    String redisKey = RedisKeyUtil.getUserKey(userId);
    redisTemplate.delete(redisKey);
}
~~~

~~~java
public LoginTicket findLoginTicket(String ticket) {
    //        return loginTicketMapper.selectByTicket(ticket);
    String redisKey = RedisKeyUtil.getTicketKey(ticket);
    return (LoginTicket) redisTemplate.opsForValue().get(redisKey);
}

public int updateHeader(int userId, String headerUrl) {
    //        return userMapper.updateHeader(userId, headerUrl);
    int rows = userMapper.updateHeader(userId, headerUrl);
    clearCache(userId);
    return rows;
}
~~~

