---
title: JVM-基础篇
categories:
- JVM
tags:
- java
- JVM
---
<meta name="referrer" content="no-referrer"/>

# 内容

**本节包括：**

- 初识JVM
- 字节码文件详解

<!--more-->

## JVM概念

JVM 全称是 Java Virtual Machine，中文译名 Java虚拟机。

JVM 本质上是一个运行在计算机上的程序，**他的职责是运行Java字节码文件**。

![image-20240401094801514](https://gitee.com/hollis7/pictures/raw/master/2024/04/01/66078_image-20240401094801514.png)

## JVM的功能

**解释和运行**：对字节码文件中的指令，实时的解释成机器码，让计算机执行

**内存管理**：自动为对象、方法等分配内存；自动的垃圾回收机制，回收不再使用的对象

**即时编译**：对热点代码进行优化，提升执行效率（性能提高、支持跨平台性）

> windows：windows机器码
>
> Linux：Linux机器码

## 常见的 JVM 虚拟机

常见的JVM有HotSpot、GraalVM、OpenJ9等，另外DragonWell龙井JDK

> GraalVM：不仅让解决了单体应用中多语言整合的难题，同时也提升了这些语言运行时的效率。极高的性能、极快的启动速度也更适用于当下的云原生架构

## 字节码文件的组成

### 基础信息

魔数、字节码文件对应的Java版本号、访问标识（public final等等）、父类和接口

#### Magic魔数

文件是无法通过文件扩展名来确定文件类型的，文件扩展名可以随意修改，不影响文件的内容。
软件使用文件的头几个字节（文件头）去校验文件的类型，如果软件不支持该种类型就会出错。
Java字节码文件中，将文件头称为magic魔数。

`CA FE BA BE`

#### 主副版本号

 版本号的作用主要是判断当前字节码的版本和运行时的JDK是否兼容。

**1.2之后大版本号计算方法就是**:
主版本号 - 44
比如主版本号52就是JDK8

### 常量池

保存了字符串常量、类或接口名、字段名主要在字节码指令中使用

常量池中的数据都有一个编号，编号从1开始。在字段或者字节码指令中通过编号可以快速的找到对应的数据。**字节码指令中通过编号引用到常量池的过程称之为符号引用。**

### 字段

当前类或接口声明的字段信息

### 方法

当前类或接口声明的方法信息
字节码指令

> 操作数栈是临时存放数据的地方，局部变量表是存放方法中的局部变量的位置

### 属性

类的属性，比如源码的文件名

内部类的列表等

## 类的生命周期 

类的生命周期描述了一个类加载、使用、卸载的整个过程

加载--->连接--->初始化--->使用--->卸载

### 加载阶段

1、加载（Loading）阶段第一步是类加载器根据类的**全限定名**通过不同的渠道以**二进制流的方式获取字节码信息**。

> 本地文件    动态代理生成   通过网络传输的类

2、 类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到**内存的方法区**中。

> 生成一个InstanceKlass对象，保存类的所有信息，里边还包含实现特定功能比如多态的信息。

3、同时，Java虚拟机还会在堆中生成一份与方法区中数据类似的`java.lang.Class`对象。

> 作用是在Java代码中去获取类的信息以及存储静态字段的数据（JDK8及之后）。

对于开发者来说，只需要访问堆中的Class对象而不需要访问方法区中所有信息。

这样Java虚拟机就能很好地控制开发者访问数据的范围。

### 连接阶段

#### 验证

1、连接（Linking）阶段的第一个环节是验证，验证的主要目的是检测Java字节码文件是否遵守了《Java虚拟机规
范》中的约束。

#### 准备

为静态变量（static）分配内存并设置初始值

![image-20240402203413692](https://gitee.com/hollis7/pictures/raw/master/2024/04/02/48627_image-20240402203413692.png)

>  final修饰的基本数据类型的静态变量，准备阶段直接会将代码中的值进行赋值。

#### 解析

解析阶段主要是将常量池中的符号引用替换为直接引用。

> 直接引用不再使用编号，而是使用内存中地址进行访问具体的数据。

### 初始化阶段

初始化阶段会执行静态代码块中的代码，并为静态变量赋值

初始化阶段会执行字节码文件中`clinit`部分的字节码指令

> 数组的创建不会导致数组中元素的类进行初始化。
>
> final修饰的变量如果赋值的内容需要执行指令才能得出结果，会执行clinit方法进行初始化

## 类加载器

 类加载器（ClassLoader）是Java虚拟机提供给应用程序去实现获取类和接口字节码数据的技术。

### 分类

一类是Java代码中实现的，一类是Java虚拟机底层源码实现的。

<img src="https://gitee.com/hollis7/pictures/raw/master/2024/04/02/42066_image-20240402212806960.png" alt="image-20240402212806960" style="zoom: 50%;" />

#### 启动类加载器

启动类加载器（Bootstrap ClassLoader）是由Hotspot虚拟机提供的、使用C++编写的类加载器。

#### Java中的默认类加载器

扩展类加载器和应用程序类加载器都是JDK中提供的、使用Java编写的类加载器。

它们的源码都位于`sun.misc.Launche`r中，是一个静态内部类。继承自URLClassLoader。具备通过目录或者指定jar包将字节码文件加载到内存中。

![image-20240402213046095](https://gitee.com/hollis7/pictures/raw/master/2024/04/02/86817_image-20240402213046095.png)

## 双亲委派机制

- 保证类加载的安全性（String不能覆盖）
- 避免重复加载

双亲委派机制指的是：当一个类加载器接收到加载类的任务时，**会自底向上查找是否加载过再由顶向下进行加载**。

### 主动加载一个类

1. 使用Class.forName方法，使用当前类的类加载器去加载指定的类。
2. 获取到类加载器，通过类加载器的loadClass方法指定某个类加载器加载。

~~~java
//获取main方法所在类的类加载器，应用程序类加载器
ClassLoader classLoader = Demo2.class.getClassLoader();
System.out.println("classLoader = " + classLoader);
//使用应用程序类加载器加载com.hdb.day2.classloader.my.A
Class<?> clazz = classLoader.loadClass("com.hdb.day2.classloader.my.A");
System.out.println("clazz = " + clazz);
~~~

### 父类加载器

每个Java实现的类加载器中保存了一个成员变量叫“父”（Parent）类加载器，可以理解为它的上级，并不是继承关系。

- 应用程序类加载器的parent父类加载器是扩展类加载器，而扩展类加载器的parent是空。
- 启动类加载器使用C++编写，没有上级类加载器。

在类加载的过程中，每个类加载器都会先检查是否已经加载了该类，**如果已经加载则直接返回，否则会**
**将加载请求委派给父类加载器。**

## 打破双亲委派机制

### 自定义类加载器

一个Tomcat程序中是可以运行多个Web应用的，如果这两个应用中出现了**相同限定名的类**，比如Servlet类，Tomcat要保证这两个类都能加载并且它们应该是不同的类。

如果不打破双亲委派机制，当应用类加载器加载Web应用1中的MyServlet之后，Web应用2中相同限定名的
MyServlet类就无法被加载了。

> Tomcat使用了自定义类加载器来实现应用之间类的隔离。每一个应用会有一个独立的类加载器加载对应的类。

自定义类加载器父类是`AppClassLoader`

<img src="https://gitee.com/hollis7/pictures/raw/master/2024/04/17/14845_image-20240417202413197.png" alt="image-20240417202413197" style="zoom:50%;" />

### 线程上下文类加载器

JDBC案例

<img src="https://gitee.com/hollis7/pictures/raw/master/2024/04/17/88254_image-20240417203635137.png" alt="image-20240417203635137" style="zoom: 50%;" />

1、启动类加载器加载DriverManager。
 2、在初始化DriverManager时，通过SPI机制加载jar包中的myql驱动。
 3、SPI中利用了线程上下文类加载器（应用程序类加载器）去加载类并创建对象。

> 这种由启动类加载器加载的类，委派应用程序类加载器去加载类的方式，打破了双亲委派机制。> 

~~~java
public static <S> ServiceLoader<S> load(Class<S> service) {
    ClassLoader cl = Thread.currentThread().getContextClassLoader();
    return ServiceLoader.load(service, cl);
}
~~~

### Osgi框架的类加载器

它存在同级之间的类加载器的委托加载。OSGi还使用类加载器实现了热部署的功能。

发现存在一个小bug，但是用户急着使用，如果重新打包再发布需要一个多小时的时间，所以希望能使用arthas尽快的将这个问题修复。

## 运行时数据区

<img src="https://gitee.com/hollis7/pictures/raw/master/2024/04/17/13789_image-20240417211425030.png" alt="image-20240417211425030" style="zoom:50%;" />

- 程序计数器
  Java虚拟机栈
  本地方法栈
- 方法区
  堆

### 1-程序计数器

在代码执行过程中，程序计数器会记录下一行字节码指令的地址。执行完当前指令之后，虚拟机的执行引擎根据程序计数器执行下一行指令。

在多线程的情况下，程序计数器用于**记录当前线程执行的位置**，当线程被切换回来的时候能够知道它上次执行的位置。

程序计数器可以控制程序指令的进行，实现分支、跳转、异常等逻辑。

#### 程序计数器在运行中会出现内存溢出吗？

内存溢出指的是程序在使用某一块内存区域时，存放的数据需要占用的内存大小超过了虚拟机能提供的内存上限。

**因为每个线程只存储一个固定长度的内存地址，程序计数器是不会发生内存溢出的**

### 2-Java虚拟机栈

Java虚拟机栈（Java Virtual Machine Stack）**采用栈的数据结构来管理方法调用中的基本数据**，先 进后出（First In Last Out）,每一个方法的调用使用一个栈帧（Stack Frame）来保存。

~~~java
public class FrameDemo {
    public static void main(String[] args) {
        A();
    }

    public static void A() {
        System.out.println("A执行了...");
        B();
    }

    public static void B() {
        System.out.println("B执行了...");
        C();
    }

    public static void C() {
        System.out.println("C执行了...");
        throw new RuntimeException("测试");
    }
}
~~~

~~~bash
Exception in thread "main" java.lang.RuntimeException: 测试
	at com.hdb.day3.frame.FrameDemo.C(FrameDemo.java:21)
	at com.hdb.day3.frame.FrameDemo.B(FrameDemo.java:16)
	at com.hdb.day3.frame.FrameDemo.A(FrameDemo.java:11)
	at com.hdb.day3.frame.FrameDemo.main(FrameDemo.java:6)
~~~

Java虚拟机栈随着线程的创建而创建，而回收则会在线程的销毁时进行。由于方法可能会在不同线程中执行，**每个线程都会包含一个自己的虚拟机栈**。

#### 栈帧的组成

##### 局部变量表

局部变量表的作用是在方法执行过程中存放所有的局部变量

> 栈帧中的局部变量表是一个数组，数组中每一个位置称之为槽（slot），long和double类型占用两个槽，其他类型占用一个槽。
>
>  为了节省空间，局部变量表中的槽是可以复用的，一旦某个局部变量不再生效，当前槽就可以再次被使用

实例方法中的序号为0的位置存放的是this，指的是当前调用方法的对象，运行时会在内存中存放实例对象的地址。

方法参数也会保存在局部变量表中，其顺序与方法中参数定义的顺序一致。



局部变量表保存的内容有：**实例方法的this对象，方法的参数，方法体中声明的局部变量**。

##### 操作数栈

操作数栈是栈帧中虚拟机在执行指令过程中用来存放**中间数据**的一块区域。他是一种栈式的数据结构，如果一条指令将一个值压入操作数栈，则后面的指令可以弹出并使用该值。

在**编译期**就可以确定操作数栈的最大深度，从而在执行时正确的分配内存大小。

##### 帧数据

- 当前类的字节码指令引用了其他类的属性或者方法时，需要将符号引用（编号）转换成对应的**运行时常量池中的内存地址**。**动态链接**就保存了编号到运行时常量池的内存地址的映射关系。
- **方法出口**指的是方法在正确或者异常结束时，当前栈帧会被弹出，同时程序计数器应该指向上一个栈帧中的下一条指令的地址。所以在当前栈帧中，需要存储此方法出口的地址。

#### 栈内存溢出

 Java虚拟机栈如果栈帧过多，占用内存超过栈内存可以分配的最大大小就会出现内存溢出。

### 3-堆

**创建出来的对象都存在于堆上**

栈上的局部变量表中，可以存放堆上对象的引用。静态变量也可以存放堆对象的引用，通过静态变量就可以实
现对象在线程之间共享。

堆内存大小是有上限的，当对象一直向堆中放入对象达到上限之后，就会抛出`OutOfMemory`错误。

**堆空间有三个需要关注的值，used total max。**

- used指的是当前已使用的**堆内存**，total是java虚拟机已经分配的可用堆内存，max是java虚拟机可以分配的最大堆内存。
-  随着堆中的对象增多，当total可以使用的内存即将不足时，java虚拟机会继续分配内存给堆

### 4- 方法区

方法区是存放基础信息的位置，线程共享，主要包含三部分内容

#### 类的基本信息

每个类的**基本信息**（元信息），一般称之为`InstanceKlass`对象。在类的加载阶段完成。

#### 运行时常量池

运行时常量池:字节码文件中通过编号查表的方式找到常量，这种常量池称为静态常量池。当常量池加载到内存中之后，可以通过内存地址快速的定位到常量池中的内容，这种常量池称为**运行时常量池**。

每款Java虚拟机在实现上都各不相同。Hotspot设计如下:

JDK7及之前的版本将方法区存放在**堆区域中的永久代空间**，堆的大小由虚拟机参数来控制。
JDK8及之后的版本将方法区存放在**元空间**中，**元空间位于操作系统维护的直接内存中**，默认情况下只要不
超过操作系统承受的上限，可以一直分配。

##### 直接内存

在 JDK 1.4 中引入了 NIO 机制，使用了直接内存，主要为了解决以下两个问题:

1. Java堆中的对象如果不再使用要回收，回收时会影响对象的创建和使用。
2. IO操作比如读文件，需要先把文件读入直接内存（缓冲区）再把数据复制到Java堆中，现在直接放入直接内存即可，同时Java堆上维护直接内存的引用，减少了数据复制的开销。写文件也是类似的思路。

#### 字符串常量池

StringBuilder 拼接字符串使用 append，然后 toString 创建一个字符串对象，存放在堆内存中，和字符串常量池中的地址不相同

~~~java
public static void main(String[] args) {
    String a = "1";
    String b = "2";
    String c = "12";
    String d = a + b;
    System.out.println(c == d);
}//false
~~~

:arrow_down:和编译有关

~~~java
String d = "1" + "2";
System.out.println(c == d);//true
~~~

JDK7及之后版本中，`intern ()` 方法会把第一次遇到的**字符串的引用**放入字符串常量池。“java”启动时就被放入了字符串常量池。

~~~java
public static void main(String[] args) {
    String s1 = new StringBuilder().append("think").append("123").toString();

    System.out.println(s1.intern() == s1);
//        System.out.println(s1.intern() == s1.intern());

    String s2 = new StringBuilder().append("ja").append("va").toString();

    System.out.println(s2.intern() == s2);
}
~~~

## 方法区的回收

方法区中能回收的内容主要就是不再使用的类。
判定一个类可以被卸载。需要同时满足下面三个条件：
**1、此类所有实例对象都已经被回收，在堆中不存在任何该类的实例对象以及子类对象。**
**2、加载该类的类加载器已经被回收。**
**3、该类对应的 java.lang.Class 对象没有在任何地方被引用。**

## 手动触发回收

如果需要手动触发垃圾回收，可以调用`System.gc()`方法。

> 调用System.gc()方法并不一定会立即回收垃圾，仅仅是向Java虚拟机发送一个垃圾回收的请求，具体是否需要 执行垃圾回收Java虚拟机会自行判断。

## 堆上对象回收

Java中的对象是否能被回收，是根据对象是否被引用来决定的。如果对象被引用了，说明该对象还在使用，不允许被回收。

~~~java
public class ReferenceCounting {
    public static void main(String[] args) {
        A a1 = new A();
        B b1 = new B();
        a1.b = b1;
        b1.a = a1;
    }
}

class A {
    B b;
}

class B {
    A a;
}
~~~

如果在main方法中最后执行 `a1 = null ，b1 = null`，是否能回收A和B对象呢？
可以回收，方法中已经没有办法使用引用去访问A和B对象了。

<img src="https://gitee.com/hollis7/pictures/raw/master/2024/04/28/97503_image-20240428205116025.png" alt="image-20240428205116025" style="zoom:50%;" />

## 如何判断堆上的对象没有被引用？

**引用计数法**会为每个对象维护一个引用计数器，当对象被引用时加1，取消引用时减1。

> 每次引用和取消引用都需要维护计数器，对系统性能会有一定的影响
>
> 存在循环引用问题，所谓循环引用就是当A引用B，B同时引用A时会出现对象无法回收的问题。

### 可达性分析法

可达性分析将对象分为两类：**垃圾回收的根对象（GC Root）和普通对象**，对象与对象之间存在引用关系。

> Garbage Collection Root

#### GC Root对象

- 线程Thread对象。
- 系统类加载器加载的`java.lang.Class`对象。
- 监视器对象，用来保存同步锁`synchronized`关键字持有的对象。
- 本地方法调用时使用的**全局对象**。

### 常见对象引用

#### 软引用

软引用相对于强引用是一种比较弱的引用关系，**如果一个对象只有软引用关联到它，当程序内存不足时，就会将软引用中的数据进行回收。**

~~~java
byte[] bytes = new byte[1024 * 1024 * 100];
SoftReference<byte[]> softReference = new SoftReference<>(bytes);
~~~

软引用中的对象如果在内存不足时回收，SoftReference对象本身也需要被回收。

1、软引用创建时，通过构造器传入引用队列
2、在软引用中包含的对象被回收时，该软引用对象会被放入引用队列
3、通过代码遍历引用队列，将SoftReference的强引用删除



**使用软引用实现学生数据的缓存**

<img src="https://gitee.com/hollis7/pictures/raw/master/2024/05/15/25757_image-20240515113202168.png" alt="image-20240515113202168" style="zoom: 33%;" />

#### 弱引用

弱引用的整体机制和软引用基本一致，**区别在于弱引用包含的对象在垃圾回收时，不管内存够不够都会直接被回收。**

弱引用主要在`ThreadLocal`中使用

#### 虚引用

虚引用也叫幽灵引用/幻影引用，不能通过虚引用对象获取到包含的对象。**虚引用唯一的用途是当对象被垃圾回收器回收时可以接收到对应的通知。**

直接内存中为了及时知道直接内存对象不再使用，从而回收内存，使用了虚引用来实现。

#### 终结器引用

 终结器引用，对象回收时可以自救，不建议使用

##  垃圾回收算法

<img src="https://gitee.com/hollis7/pictures/raw/master/2024/05/23/70659_image-20240523154607464.png" alt="image-20240523154607464" style="zoom:50%;" />

### 垃圾回收算法的评价标准

java垃圾回收过程会通过单独的GC线程来完成，但是不管使用哪一种GC算法，**都会有部分阶段需要停止所**
**有的用户线程**。这个过程被称之为Stop The World简称**STW**，如果STW时间过长则会影响用户的使用。

#### 吞吐量

吞吐量指的是CPU用于执行用户代码的时间与CPU总执行时间的比值，即：

吞吐量=执行用户代码时间/（执行用户代码时间+GC时间）。

吞吐量数值越高，垃圾回收的效率就越高。

#### 最大暂停时间

最大暂停时间指的是所有在垃圾回收过程中的STW时间最大值

最大暂停时间越短，用户使用系统时受到的影响就越短。

#### 堆使用效率

不同垃圾回收算法，对堆内存的使用方式是不同的。比如**标记清除算法**，可以使用完整的堆内存。而**复制算**
**法**会将堆内存一分为二，每次只能使用一半内存。从堆使用效率上来说，标记清除算法要优于复制算法。

### 标记清除算法

1.标记阶段，将所有存活的对象进行标记。Java中使用**可达性分析算法**，从GC Root开始通过**引用链**遍历出
所有存活对象。
2.清除阶段，从内存中删除没有被标记也就是非存活对象。

#### 优缺点

优点：实现简单，只需要在第一阶段给每个对象维护标志位，第二阶段删除对象即可。
缺点：

1.碎片化问题

> 由于内存是连续的，所以在对象被删除之后，内存中会出现很多细小的可用内存单元。如果我们需要的是一
> 个比较大的空间，很有可能这些内存单元的大小过小无法进行分配

2.分配速度慢。

由于内存碎片的存在，需要维护一个空闲链表，极有可能发生每次需要遍历到链表的最后才能获得合适的内存空间。

### 复制算法

复制算法的核心思想是：
1.准备两块空间From空间和To空间，每次在对象分配阶段，只能使用其中一块空间（From空间）。
2.在垃圾回收GC阶段，将From中存活对象复制到To空间。
3.将两块空间的From和To名字互换。

![image-20240523152214156](https://gitee.com/hollis7/pictures/raw/master/2024/05/23/36378_image-20240523152214156.png)

#### 复制算法的优缺点

**优点：**

**吞吐量高**

复制算法只需要遍历一次存活对象复制到To空间即可，比标记-整理算法少了一次遍历的过程，因而性能较好，但是不如标记-清除算法，因为标记清除算法不需要进行对象的移动

**不会发生碎片化**

复制算法在复制之后就会将对象按顺序放入To空间中，所以对象以外的区域都是可用空间，不存在碎片化内存空间。

**缺点：**

内存使用效率低

每次只能让一半的内存空间来为创建对象使用

### 标记整理算法

1.标记阶段，将所有存活的对象进行标记。Java中使用可达性分析算法，从GC Root开始通过引用链遍历出
所有存活对象。
2.整理阶段，将存活对象移动到堆的一端。清理掉存活对象的内存空间。

#### 优缺点

##### 内存使用效率高

整个堆内存都可以使用，不会像复制算法只能使用半个堆内存

##### 不会发生碎片化

在整理阶段可以将对象往内存的一侧进行移动，剩下的空间都是可以分配对象的有效空间

##### 整理阶段的效率不高

### 分代垃圾回收算法

<img src="https://gitee.com/hollis7/pictures/raw/master/2024/05/23/77824_image-20240523155326181.png" alt="image-20240523155326181" style="zoom: 40%;" />

分代回收时，创建出来的对象，首先会被放入Eden伊甸园区。
随着对象在Eden区越来越多，如果Eden区满，新创建的对象已经无法放入，就会触发年轻代的GC，称为Minor GC或者Young GC。
Minor GC会把需要eden中和From需要回收的对象回收，把没有回收的对象放入To区。

接下来，S0会变成To区，S1变成From区。当eden区满时再往里放入对象，依然会发生Minor GC。
此时会回收eden区和S1(from)中的对象，并把eden和from区中剩余的对象放入S0。
注意：每次Minor GC中都会为对象记录他的年龄，初始值为0，每次GC完加1。

如果Minor GC后对象的年龄达到阈值（最大15，默认值和垃圾回收器有关），对象就会被晋升至老年代。
当老年代中空间不足，无法放入新的对象时，先尝试minor gc如果还是不足，就会触发Full GC，Full GC会对整个堆进行垃圾回收。
如果Full GC依然无法回收掉老年代的对象，那么当对象继续放入老年代时，就会抛出**Out Of Memory**异常。

## 垃圾回收器

### 分代GC算法的背景

1、可以通过调整年轻代和老年代的比例来适应不同类型的应用程序，提高内存的利用率和性能。

2、新生代和老年代使用不同的垃圾回收算法，新生代一般选择复制算法，老年代可以选择标记-清除和标记-整理算法，由程序员来选择灵活度较高。

3、分代的设计中允许只回收新生代（minor gc），如果能满足对象分配的要求就不需要对整个堆进行回收（full gc），STW时间就会减少。

### 垃圾回收器分类

| **Serial**                       | **单线程串行** | **新生代** | **复制算法**       | **响应速度优先** | **单CPU环境下的Client模式**               |
| :------------------------------- | -------------- | :--------- | :----------------- | :--------------- | :---------------------------------------- |
| **Serial Old**                   | 单线程串行     | 老年代     | 标记-整理          | 响应速度优先     | 单CPU环境下的Client模式、CMS的后备预案    |
| **ParNew**                       | 并行           | 新生代     | 复制算法           | 响应速度优先     | 多CPU环境时在Server模式下与CMS配合        |
| **CMS**（concurrent mark Sweep） | 并发           | 老年代     | 标记-清除          | 响应速度优先     | 集中在互联网站或B/S系统服务端上的Java应用 |
| **Parallel Scavenge**            | 并行           | 新生代     | 复制算法           | 吞吐量优先       | 在后台运算而不需要太多交互的任务          |
| **Parallel Old**                 | 并行           | 老年代     | 标记-整理          | 吞吐量优先       | 在后台运算而不需要太多交互的任务          |
| **G1**                           | 并发           | both       | 标记-整理+复制算法 | 响应速度优先     | 面向服务端应用，将来替换CMS               |

![image-20240524195456736](https://gitee.com/hollis7/pictures/raw/master/2024/05/24/34055_image-20240524195456736.png)

### 组合一

#### 年轻代-Serial垃圾回收器

Serial是是一种单线程串行回收年轻代的垃圾回收器。

在进行垃圾回收的时候必须暂停其他所有的工作线程（ `Stop The World` ），直到它收集结束。

#### 老年代-Serial Old垃圾回收器

SerialOld是Serial垃圾回收器的老年代版本，采用单线程串行回收

> CMS在特殊情况下会调用Serial Old

### 组合二

#### 年轻代-ParNew垃圾回收器

ParNew垃圾回收器本质上是对Serial在多 CPU下的优化，使用**多线程进行垃圾回收**

#### 老年代- CMS(Concurrent Mark Sweep)垃圾回收器

CMS垃圾回收器关注的是系统的暂停时间， **允许用户线程和垃圾回收线程在某些步骤中同时执行**，减少了用户线程的等待时间。

`CMS` 垃圾回收基于**标记清除算法**实现，整个过程分为四个步骤：

- 初始标记： 暂停所有用户线程（`Stop The World`），记录直接与 `GC Roots` 直接相连的对象 。
- 并发标记：从`GC Roots`开始对堆中对象进行可达性分析，找出存活对象，耗时较长，但是不需要停顿用户线程。
- 重新标记： 在并发标记期间对象的引用关系可能会变化，需要重新进行标记。此阶段也会暂停所有用户线程。
- 并发清除：清除标记对象，这个阶段也是可以与用户线程同时并发的。

优点：并发收集，停顿时间短

缺点：标记清除算法导致收集结束有**大量空间碎片**。

**产生浮动垃圾**，在并发清理阶段用户线程还在运行，会不断有新的垃圾产生，这一部分垃圾出现在标记过程之后，`CMS`无法在当次收集中回收它们，只好等到下一次垃圾回收再处理；

### 组合三

#### 年轻代-Parallel Scavenge垃圾回收器

Parallel Scavenge是JDK8默认的年轻代垃圾回收器， 多线程并行回收，关注的是系统的**吞吐量**。具备自动调整堆内存大小的特点。

> jdk8

#### 老年代-Parallel Old垃圾回收器

Parallel Old是为Parallel Scavenge收集器 设计的老年代版本，利用多线程并发收集。

**具备自动调整堆内存大小的特点。**

**优点：**
并发收集，在多核CPU下效率较高

**缺点：**

暂停时间会比较长

### G1垃圾回收器

G1的整个堆会被划分成多个大小相等的区域，称之为区Region，区域不要求是连续的。分为Eden、Survivor、 Old区、Humongous区。Region的大小通过堆空间大小/2048计算得到，也可以通过参数-XX:G1HeapRegionSize=32m指定(其 中32m指定region大小为32M)，Region size必须是2的指数幂，取值范围从1M到32M。

#### G1垃圾回收器 – 年轻代回收

年轻代回收（Young GC），回收Eden区和Survivor区中不用的对象。会导致STW，G1中可以通过参数 -XX:MaxGCPauseMillis=n（默认200） 设置每次垃圾回收时的最大暂停时间毫秒数，G1垃圾回收器会尽可能地 保证暂停时间。

#### 执行流程

1. 新创建的对象会存放在Eden区。当G1判断年轻代区不足（**max默认60%**），无法分配对象时需要回收时会执行
   Young GC。
2. 标记出Eden和Survivor区域中的存活对象，
3. 根据配置的最大暂停时间选择某些区域将存活对象复制到一个新的Survivor区中（年龄+1），清空这些区域。

<img src="https://gitee.com/hollis7/pictures/raw/master/2024/05/27/43821_image-20240527205613763.png" alt="image-20240527205613763" style="zoom:50%;" />

> G1在进行Young GC的过程中会去记录每次垃圾回收时每个Eden区和Survivor区的平均耗时，以作为下次回收时的参考依据。这样就可以根据配置的最大暂停时间计算出本次回收时最多能回收多少个Region区域了

4. 后续Young GC时与之前相同，只不过Survivor区中存活对象会被搬运到另一个Survivor区。

5. 当某个存活对象的年龄到达阈值（默认15），将被放入老年代。

> 部分对象如果大小超过Region的一半，会直接放入老年代，这类老年代被称为Humongous区。比如堆内存是4G，每个Region是2M，只要一个大对象超过了1M就被放入Humongous区，如果对象过大会横跨多个Region。

6. 多次回收之后，会出现很多Old老年代区，此时总堆占有率达到阈值时 （ -XX:InitiatingHeapOccupancyPercent默认45% ）会触发混合回收MixedGC。**回收所有年轻代和部分老年代的对象以及大对象区。**采用复制算法来完成。

7. 混合回收分为：初始标记（initial mark）、并发标记（concurrent mark）、最终标记（remark或者Finalize
   Marking）、并发清理（cleanup）

![image-20240527212527361](https://gitee.com/hollis7/pictures/raw/master/2024/05/27/70501_image-20240527212527361.png)

8.  G1对老年代的清理会选择存活度最低的区域来进行回收，这样可以保证回收效率最高，这也是G1（Garbage
   first）名称的由来。

> 如果清理过程中发现没有足够的空Region存放转移的对象，会出现Full GC。单线程执行标记-整理算法，
> 此时会导致用户线程的暂停。所以尽量保证应该用的堆内存有一定多余的空间。
