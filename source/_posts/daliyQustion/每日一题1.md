---
title: 每日一题-1
categories:
- dailyQuestion
tags:
- java
- leetcode
- daily
---
<meta name="referrer" content="no-referrer"/>

# 内容

**本节包括：**

- 每日一题1

<!--more-->

## 2129.将标题首字母大写

给你一个字符串 `title` ，它由单个空格连接一个或多个单词组成，每个单词都只包含英文字母。请你按以下规则将每个单词的首字母 **大写** ：

- 如果单词的长度为 `1` 或者 `2` ，所有字母变成小写。
- 否则，将单词首字母大写，剩余字母变成小写。

请你返回 **大写后** 的 `title` 。

### 思路-初步实现

定义左右指针：

1. 原来字符串加一个空格，保证处理逻辑一致
2. right -left <=2，所有字母小写
3. right-left>2,首字母大写
4. 处理一个单词后，向后移动
5. 去掉字符串的末尾空格

~~~java
public String capitalizeTitle(String title) {
        int left = 0;
        int right = 0;

        StringBuilder stringBuilder = new StringBuilder(title);
        stringBuilder.append(' ');
        int length = stringBuilder.length();
        StringBuilder res = new StringBuilder();
        while (right < length) {
            while (stringBuilder.charAt(right) != ' ') {
                right++;
            }
            //此时right处为空格
            if (right - left <= 2) {
                while (left < right) {
                    res.append(Character.toLowerCase(stringBuilder.charAt(left)));
                    left++;
                }
            } else {
                //首字母大写
                res.append(Character.toUpperCase(stringBuilder.charAt(left)));
                left++;
                while (left < right) {
                    res.append(Character.toLowerCase(stringBuilder.charAt(left)));
                    left++;
                }

            }
            res.append(' ');

            //处理下一个单词
            right = right + 1;
            left = right;
        }
        return res.toString().trim();
    }
~~~

### 优化

~~~java
public String capitalizeTitle(String title) {
        StringBuilder sb = new StringBuilder(title);
        int n = title.length();
        int l = 0, r = 0;
        while (r < n) {
            while (r < n && sb.charAt(r) != ' ') {
                ++r;
            }
            /*先确定单个单词的右上限 */
            if (r - l > 2) {
                sb.setCharAt(l, Character.toUpperCase(sb.charAt(l)));
                ++l;
            }
            while (l < r) {
                sb.setCharAt(l, Character.toLowerCase(sb.charAt(l)));
                ++l;
            }
            l = r + 1;
            ++r;
        }
        return sb.toString();
    }
~~~

## 1261.在受污染的二叉树中查找元素

给出一个满足下述规则的二叉树：

1. `root.val == 0`
2. 如果 `treeNode.val == x` 且 `treeNode.left != null`，那么 `treeNode.left.val == 2 * x + 1`
3. 如果 `treeNode.val == x` 且 `treeNode.right != null`，那么 `treeNode.right.val == 2 * x + 2`

现在这个二叉树受到「污染」，所有的 `treeNode.val` 都变成了 `-1`。

请你先还原二叉树，然后实现 `FindElements` 类：

- `FindElements(TreeNode* root)` 用受污染的二叉树初始化对象，你需要先把它还原。
- `bool find(int target)` 判断目标值 `target` 是否存在于还原后的二叉树中并返回结果。

### 思路

树的创建过程省略

- find函数的实现要注意查看数的还原过程，左子树一定是奇数，右子树一定是偶数
- 假设target存在，从树的底部向上查找，并用栈记录左右子树的查找方向一直到根节点
- 从根节点开始，取出栈中的值，依次向下遍历，如果遍历过程中栈指示的方向为空，那么返回false；否则返回true

**坑：由于多次查询，上一次查询时可能栈没有清空，需要先手动清空栈，再往栈中插入方向指示数值**

~~~java
public class FindElements {
    TreeNode root;
    Stack<Integer> stack = new Stack<>();

    public FindElements(TreeNode root) {
        if (root == null) return;
        else root.val = 0;
        buildTree(root);
        this.root = root;
    }

    public boolean find(int target) {
        TreeNode cur = root;
        stack.clear();
        findPath(target);
        while (!stack.isEmpty()) {
            if (stack.pop() == 0) {
                if (cur.left != null) {
                    cur = cur.left;
                } else return false;
            } else {
                if (cur.right != null) {
                    cur = cur.right;
                } else return false;
            }
        }
        return true;
    }

    public void buildTree(TreeNode root) {
        if (root.left != null) {
            root.left.val = root.val * 2 + 1;
            buildTree(root.left);
        }
        if (root.right != null) {
            root.right.val = root.val * 2 + 2;
            buildTree(root.right);
        }
    }

    public void findPath(int target) {
        if (target == 0) return;
        if (target % 2 == 0) {
            target = (target - 2) / 2;
            stack.push(1);//1代表右子树

        } else {
            target = (target - 1) / 2;
            stack.push(0);//0代表左子树
        }
        findPath(target);
    }
}
~~~

## 2864.最大二进制奇数

给你一个二进制字符串s,其中至少包含一个'1'。
你必须按某种方式重新排列字符串中的位，使得到的二进制数字是可以由该组合生成的最大二进制奇数。
以字符串形式，表示并返回可以由给定组合生成的最大二进制奇数。
注意返回的结果字符串可以含前导零。

**示例 1：**

```
输入：s = "010"
输出："001"
解释：因为字符串 s 中仅有一个 '1' ，其必须出现在最后一位上。所以答案是 "001" 。
```

**示例 2：**

```
输入：s = "0101"
输出："1001"
解释：其中一个 '1' 必须出现在最后一位上。而由剩下的数字可以生产的最大数字是 "100" 。所以答案是 "1001" 。
```

### 思路

记录0和1的次数，字符串末尾需要一个1，最前面用1填充，中间用0填充

### 代码实现

~~~java
public class MaximumOddBinaryNumber {
    public String maximumOddBinaryNumber(String s) {
        StringBuilder res = new StringBuilder();
        int[] counts = new int[2];//记录0和1的次数
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '0') {
                counts[0]++;
            } else {
                counts[1]++;
            }
        }
        while (counts[1] > 1) {
            res.append('1');
            counts[1]--;
        }
        while (counts[0] > 0) {
            res.append('0');
            counts[0]--;
        }
        res.append('1');

        return res.toString();
    }
}
~~~

### 思路2

创建s.length()的char数组，只记录1的次数cnt，0的次数等于s.length()-cnt

## 2789.合并后数组中的最大元素

给你一个下标从 **0** 开始、由正整数组成的数组 `nums` 。

你可以在数组上执行下述操作 **任意** 次：

- 选中一个同时满足 `0 <= i < nums.length - 1` 和 `nums[i] <= nums[i + 1]` 的整数 `i` 。将元素 `nums[i + 1]` 替换为 `nums[i] + nums[i + 1]` ，并从数组中删除元素 `nums[i]` 。

返回你可以从最终数组中获得的 **最大** 元素的值。

**示例 1：**

```
输入：nums = [2,3,7,9,3]
输出：21
解释：我们可以在数组上执行下述操作：
- 选中 i = 0 ，得到数组 nums = [5,7,9,3] 。
- 选中 i = 1 ，得到数组 nums = [5,16,3] 。
- 选中 i = 0 ，得到数组 nums = [21,3] 。
最终数组中的最大元素是 21 。可以证明我们无法获得更大的元素。
```

### 思路 贪心算法 倒叙遍历

为了使数组的最大值最大，**我们可以贪心地做尽可能多的合并**，直到整个数组都不能进行合并。

合并的要求是后面的数字不小于前面的数字，我们就尽可能先合并靠后的数字，使其尽快能大，才能够合并前面的数字。

### 代码实现

~~~java
 public long maxArrayValue(int[] nums) {
        long sum = nums[nums.length - 1];
        for (int i = nums.length - 2; i >= 0; i--) {
            if (nums[i] <= sum) {//可以合并
                sum += nums[i];
            } else {
                sum = nums[i];
            }
        }
        return sum;
    }
~~~

## 2312.卖木头块

给你两个整数 `m` 和 `n` ，分别表示一块矩形木块的高和宽。同时给你一个二维整数数组 `prices` ，其中 `prices[i] = [hi, wi, pricei]` 表示你可以以 `pricei` 元的价格卖一块高为 `hi` 宽为 `wi` 的矩形木块。

每一次操作中，你必须按下述方式之一执行切割操作，以得到两块更小的矩形木块：

- 沿垂直方向按高度 **完全** 切割木块，或
- 沿水平方向按宽度 **完全** 切割木块

在将一块木块切成若干小木块后，你可以根据 `prices` 卖木块。你可以卖多块同样尺寸的木块。你不需要将所有小木块都卖出去。你 **不能** 旋转切好后木块的高和宽。

请你返回切割一块大小为 `m x n` 的木块后，能得到的 **最多** 钱数。

注意你可以切割木块任意次。

**示例 1：**

```
输入：m = 3, n = 5, prices = [[1,4,2],[2,2,7],[2,1,3]]
输出：19
解释：上图展示了一个可行的方案。包括：
- 2 块 2 x 2 的小木块，售出 2 * 7 = 14 元。
- 1 块 2 x 1 的小木块，售出 1 * 3 = 3 元。
- 1 块 1 x 4 的小木块，售出 1 * 2 = 2 元。
总共售出 14 + 3 + 2 = 19 元。
19 元是最多能得到的钱数。
```

### 思路-动态规划

**状态转移方程**

如果x>1,那么我们可以沿水平方向将木块切成两部分，它们的高分别是i(1≤i<x)和x-i,宽均为y。因此我们可以得到状态转移方程：
$$
f ( x , y ) = \max _ { 1 \leq i < x } \left\{ f ( i , y ) + f ( x - i , y ) \right\}
$$
如果y>1，那么我们可以沿垂直方向将木块切成两部分，它们的宽分别是j(1≤j<y)和y-j了，高均为x。因此我们可以得到状态转移方程：
$$
f ( x , y ) = \max _ { 1 \leq j < y } \left\{ f ( x , j ) + f ( x , y - j ) \right\}
$$
**存储键值**

通过将 x 左移 16 位（相当于 x * 2^16）然后对其与 y 进行按位异或操作来生成哈希值。

### 代码实现

~~~java
public class SellingWood {
    public long sellingWood(int m, int n, int[][] prices) {
        Map<Long, Integer> value = new HashMap<>();

        //通过hi和wi映射pricei
        for (int[] price : prices) {

            value.put(pairHash(price[0], price[1]), price[2]);
        }
        long[][] memo = new long[m + 1][n + 1];
        for (long[] row : memo) {
            Arrays.fill(row, -1);
        }
        return dfs(m, n, value, memo);
    }

    public long dfs(int x, int y, Map<Long, Integer> value, long[][] memo) {
        if (memo[x][y] != -1) {
            return memo[x][y];
        }
        long key = pairHash(x, y);
        long ret = value.getOrDefault(key, 0);
        if (x > 1) {
            for (int i = 1; i < x; i++) {
                ret = Math.max(ret, dfs(i, y, value, memo) + dfs(x - i, y, value, memo));
            }
        }
        if (y > 1) {
            for (int j = 1; j < y; j++) {
                ret = Math.max(ret, dfs(x, j, value, memo) + dfs(x, y - j, value, memo));
            }
        }
        memo[x][y] = ret;
        return ret;
    }

    public long pairHash(int x, int y) {
        return (long) x << 16 ^ y;
    }

    public static void main(String[] args) {
        int m = 3;
        int n = 5;
        int[][] prices = {{1, 4, 2}, {2, 2, 7}, {2, 1, 3}};
        SellingWood sellingWood = new SellingWood();
        long price = sellingWood.sellingWood(m, n, prices);
        System.out.println(price);
    }

}
~~~

### 优化

动态转移方程矩阵中存在重复运算i和x-i，可以砍半优化，

可以直接通过在状态转移矩阵中存储初始元素

### 优化代码

~~~java
class Solution {
    public long sellingWood(int m, int n, int[][] prices) {
        long[][] memo = new long[m + 1][n + 1];
        for (int[] price : prices) {
            memo[price[0]][price[1]] = price[2];
        }
        for (int x = 0; x <= m; x++) {
            for (int y = 0; y <= n; y++) {
                long max = memo[x][y];
                for (int i = 1; i <= (x >> 1); i++) {
                    max = Math.max(max, memo[i][y] + memo[x - i][y]);
                }
                for (int i = 1; i <= (y >> 1); i++) {
                    max = Math.max(max, memo[x][i] + memo[x][y - i]);
                }
                memo[x][y] = max;
            }
        }
        return memo[m][n];
    }
}
~~~

## 310.最小高度树

树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。

给你一棵包含 `n` 个节点的树，标记为 `0` 到 `n - 1` 。给定数字 `n` 和一个有 `n - 1` 条无向边的 `edges` 列表（每一个边都是一对标签），其中 `edges[i] = [ai, bi]` 表示树中节点 `ai` 和 `bi` 之间存在一条无向边。

可选择树中任何一个节点作为根。当选择节点 `x` 作为根节点时，设结果树的高度为 `h` 。在所有可能的树中，具有最小高度的树（即，`min(h)`）被称为 **最小高度树** 。

请你找到所有的 **最小高度树** 并按 **任意顺序** 返回它们的根节点标签列表。

树的 **高度** 是指根节点和叶子节点之间最长向下路径上边的数量。

### 思路

- 首先证明树的高度一定为$$m i n h e i g h t = \left[ \frac { m a x d i s t } { 2 } \right]$$
- 最小高度树的根节点一定存在于x到y的路径上

![image-20240317214158323](https://gitee.com/hollis7/pictures/raw/master/2024/03/17/40961_image-20240317214158323.png)

在此我们利用广度优先搜索来找到节点的最长路径，首先找到距离节点0的最远节点x，然后找到距离节点x的最远节点y，然后找到节点x与节点y的路径，然后找到根节点。

**边的存储方式：**

~~~java
 //存储多叉树
List<Integer>[] adj = new List[n];
for (int i = 0; i < n; i++) {
    adj[i] = new ArrayList<>();
}
for (int[] edge : edges) {
    adj[edge[0]].add(edge[1]);
    adj[edge[1]].add(edge[0]);
}
~~~

**构建多叉树**

~~~java
while (!queue.isEmpty()) {
    int curr = queue.poll();
    node = curr;
    for (int v : adj[curr]) {
        if (!visit[v]) {
            visit[v] = true;
            parent[v] = curr;
            queue.offer(v);
        }
    }
}
~~~

### 代码实现

~~~java
public class FindMinHeightTrees {
    public List<Integer> findMinHeightTrees(int n, int[][] edges) {
        List<Integer> res = new ArrayList<>();
        if (n == 1) {
            res.add(0);
            return res;
        }
        //存储多叉树
        List<Integer>[] adj = new List[n];
        for (int i = 0; i < n; i++) {
            adj[i] = new ArrayList<>();
        }
        for (int[] edge : edges) {
            adj[edge[0]].add(edge[1]);
            adj[edge[1]].add(edge[0]);
        }
        int[] parent = new int[n];
        Arrays.fill(parent, -1);
        /* 找到与节点 0 最远的节点 x */
        int x = findLongestNode(0, parent, adj);
        /* 找到与节点 x 最远的节点 y */
        int y = findLongestNode(x, parent, adj);
        /* 求出节点 x 到节点 y 的路径 */
        List<Integer> path = new ArrayList<>();
        parent[x] = -1;
        while (y != -1) {
            path.add(y);
            y = parent[y];
        }
        int m = path.size();
        if (m % 2 == 0) {
            res.add(path.get(m / 2 - 1));
        }
        res.add(path.get(m / 2));
        return res;
    }

    //构建多叉树
    public int findLongestNode(int u, int[] parent, List<Integer>[] adj) {
        int n = adj.length;
        Queue<Integer> queue = new ArrayDeque<>();
        boolean[] visit = new boolean[n];
        queue.offer(u);
        visit[u] = true;
        //以当前u为根节点，层序遍历
        int node = -1;
        while (!queue.isEmpty()) {
            int curr = queue.poll();
            node = curr;
            for (int v : adj[curr]) {
                if (!visit[v]) {
                    visit[v] = true;
                    parent[v] = curr;
                    queue.offer(v);
                }
            }
        }
        return node;
    }
}
~~~

## 303.区域和检索-数组不可变

给定一个整数数组  `nums`，处理以下类型的多个查询:

1. 计算索引 `left` 和 `right` （包含 `left` 和 `right`）之间的 `nums` 元素的 **和** ，其中 `left <= right`

实现 `NumArray` 类：

- `NumArray(int[] nums)` 使用数组 `nums` 初始化对象
- `int sumRange(int i, int j)` 返回数组 `nums` 中索引 `left` 和 `right` 之间的元素的 **总和** ，包含 `left` 和 `right` 两点（也就是 `nums[left] + nums[left + 1] + ... + nums[right]` )

###  代码实现

~~~java
public class NumArray {
    public int[] nums;

    public NumArray(int[] nums) {
        this.nums = new int[nums.length];
        System.arraycopy(nums, 0, this.nums, 0, nums.length);
    }

    public int sumRange(int left, int right) {
        int sum = 0;
        for (int i = left; i <= right; i++) {
            sum += this.nums[i];
        }
        return sum;
    }
}
~~~

## 1793.好子数组的最大分数

给你一个整数数组 `nums` **（下标从 0 开始）**和一个整数 `k` 。

一个子数组 `(i, j)` 的 **分数** 定义为 `min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1)` 。一个 **好** 子数组的两个端点下标需要满足 `i <= k <= j` 。

请你返回好子数组的最大可能 **分数** 。

### 思路

1. 初始化左右指针 `l` 和 `r`，分别指向索引 `k` 的左侧和右侧，**开空间**
2. 初始化变量 `maxMul` 为索引 `k` 处的元素值，即 `nums[k]`。
3. 进入一个循环，循环中进行以下操作：
   - 从当前值 `i`（初始值为 `nums[k]`）开始，分别向左右两侧扩展，直到找到左右两侧第一个小于当前值 `i` 的元素，分别更新左右指针 `l` 和 `r`。
   - 计算当前子数组的乘积，即 `(r - l - 1) * i`，并将其与 `maxMul` 比较，取较大值更新 `maxMul`。
   - 如果左指针 `l` 到达数组的开头且右指针 `r` 到达数组的末尾，则跳出循环。
   - 更新当前值 `i` 为左右两侧中较大的值，即 `Math.max(nums[l], nums[r])`。
4. 返回最大乘积 `maxMul`。****

### 代码实现

~~~java
public int maximumScore(int[] nums, int k) {
        int l = k - 1;
        int r = k + 1;
        int maxMul = nums[k];
        for (int i = nums[k]; ; ) {
            while (l > -1 && nums[l] >= i) {
                --l;
            }
            while (r < nums.length && nums[r] >= i) {
                r++;
            }
            maxMul = Math.max((r - l - 1) * i, maxMul);
            if (l == -1 && r == nums.length) {
                break;
            }
            i = Math.max((l == -1 ? -1 : nums[l]), (r == nums.length ? -1 : nums[r]));
        }
        return maxMul;

    }
~~~

## 322.零钱兑换

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。

### 思路-有错误

贪心+回溯

将coin排序，每次取符合条件的最大`coin[i]`

### 动态规划

~~~java
 public int coinChange(int[] coins, int amount) {
        int initialVal = amount + 1;
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, initialVal);
        dp[0] = 0;
        for (int i = 1; i <= amount; i++) {
            for (int coin : coins) {
                if (coin <= i) {
                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);
                }
            }
        }
        return dp[amount] == initialVal ? -1 : dp[amount];

    }
~~~

## 518.零钱兑换2

给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

### 思路1

回溯-会超时

### 代码实现

~~~java
int count = 0;
public int change(int amount, int[] coins) {
    Arrays.sort(coins);
    backtracking(amount, coins, 0);
    return count;
}

public void backtracking(int amount, int[] coins, int startIdx) {
    if (amount == 0) {

        ++count;
    }
    for (int i = startIdx; i < coins.length; i++) {
        if (amount >= coins[i]) {
            backtracking(amount - coins[i], coins, i);
        } else {
            break;
        }
    }
    //所有coin都不能找零
    return;
}
~~~

### 思路2 动态规划

### 代码实现

上述做法不会重复计算不同的排列。因为外层循环是遍历数组 `coins`的值，内层循环是遍历不同的金额之和，在计算 `dp[i]`的值时，可以确保金额之和等于`i`的硬币面额的顺序，由于顺序确定，因此不会重复计算不同的排列。

如果for循环嵌套错误，会出现：

```
int amount = 5;
int[] coins = {1, 2, 5};
//1，2，2
//2，2，1
```

~~~java
int[] dp;

public int change(int amount, int[] coins) {
    changeHelper(amount, coins);
    return dp[amount];
}

public void changeHelper(int amount, int[] coins) {
    Arrays.sort(coins);
    dp = new int[amount + 1];
    dp[0] = 1;
    for (int coin : coins) {
        for (int i = coin; i <= amount; i++) {
            dp[i] += dp[i - coin];
        }
    }
}
~~~

## 2580.统计将重叠区间合并成组的方案数

给你一个二维整数数组 `ranges` ，其中 `ranges[i] = [starti, endi]` 表示 `starti` 到 `endi` 之间（包括二者）的所有整数都包含在第 `i` 个区间中。

你需要将 `ranges` 分成 **两个** 组（可以为空），满足：

- 每个区间只属于一个组。
- 两个有 **交集** 的区间必须在 **同一个** 组内。

如果两个区间有至少 **一个** 公共整数，那么这两个区间是 **有交集** 的。

- 比方说，区间 `[1, 3]` 和 `[2, 5]` 有交集，因为 `2` 和 `3` 在两个区间中都被包含。

请你返回将 `ranges` 划分成两个组的 **总方案数** 。由于答案可能很大，将它对 `109 + 7` **取余** 后返回。

### 思路

1. 排序

2. 将有交集的集合进行合并：

   - 固定`r=ranges[i][1]`，只要 `r >= ranges[i][0]`不断移动向右移动`i`，并更新`r = Math.max(r, ranges[i][1])`，直到`i`到达终点或者`r<ranges[i][0]`

   - 每次中断更新次数

### 代码实现

~~~java
 public int countWays(int[][] ranges) {
        Arrays.sort(ranges, Comparator.comparingInt(a -> a[0]));
        int res = 1;
        for (int i = 0; i < ranges.length; ) {
            int r = ranges[i][1];
            while (i < ranges.length && r >= ranges[i][0]) {
                r = Math.max(r, ranges[i][1]);
                i++;
            }
            res = res * 2 % 1000000007;
        }
        return res;
    }
~~~

## 331. 验证二叉树的前序序列化

序列化二叉树的一种方法是使用 **前序遍历** 。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 `#`。

![img](https://assets.leetcode.com/uploads/2021/03/12/pre-tree.jpg)

例如，上面的二叉树可以被序列化为字符串 `"9,3,4,#,#,1,#,#,2,#,6,#,#"`，其中 `#` 代表一个空节点。

给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。

**保证** 每个以逗号分隔的字符或为一个整数或为一个表示 `null` 指针的 `'#'` 。

你可以认为输入格式总是有效的

- 例如它永远不会包含两个连续的逗号，比如 `"1,,3"` 。

**注意：**不允许重建树。

**提示:**

- `1 <= preorder.length <= 104`
- `preorder` 由以逗号 `“，”` 分隔的 `[0,100]` 范围内的整数和 `“#”` 组成

### 思路

我们可以定义一个概念，叫做槽位。一个槽位可以被看作「当前二叉树中正在等待被节点填充」的那些位置。

二叉树的建立也伴随着槽位数量的变化。每当遇到一个节点时：

- 如果遇到了空节点，则要消耗一个槽位；

- 如果遇到了非空节点，则除了消耗一个槽位外，还要再补充两个槽位。

- 此外，还需要将根节点作为特殊情况处理。


> 我们可以只维护一个计数器，用来记录槽位的变化，槽位提前变为0则返回为`false`，否则一直遍历直到最终能构成前序遍历。
>
> 数字读取时要注意可能不是一位数

### 代码实现

~~~java
 public boolean isValidSerialization(String preorder) {
        //定义槽位，用来存放节点和空节点，空节点消耗一个槽位，非空节点消耗一个节点并产生两个节点
        int slots = 1;
        int len = preorder.length();
        for (int i = 0; i < len; ) {
            if (slots == 0) return false;
            if (preorder.charAt(i) == ',') {
                i++;
            } else if (preorder.charAt(i) == '#') {
                slots--;
                i++;
            } else {//读取数字，如35
                while (i < len && preorder.charAt(i) != ',') {
                    i++;
                }
                slots++;
            }
        }
        return slots == 0;
    }
~~~

## 686.重复叠加字符串匹配

给定两个字符串 `a` 和 `b`，寻找重复叠加字符串 `a` 的最小次数，使得字符串 `b` 成为叠加后的字符串 `a` 的子串，如果不存在则返回 `-1`。

**注意：**字符串 `"abc"` 重复叠加 0 次是 `""`，重复叠加 1 次是 `"abc"`，重复叠加 2 次是 `"abcabc"`。

### 思路自己

计算b的next数组（前缀表），先判断a的长度大于b长度的情况，再判断b的长度大于a的情况，写一个拼接a的字符串函数。

存在超时问题

### 代码实现自己

~~~java
package mychar;

/**
 * 给定两个字符串 `a` 和 `b`，寻找重复叠加字符串 `a` 的最小次数，
 * 使得字符串 `b` 成为叠加后的字符串 `a` 的子串，如果不存在则返回 `-1`。
 * **注意：**字符串 `"abc"` 重复叠加 0 次是 `""`，重复叠加 1 次是 `"abc"`，重复叠加 2 次是 `"abcabc"`。
 */
public class RepeatedStringMatch {
    public int repeatedStringMatch(String a, String b) {
        int[] next = new int[b.length()];
        getNext(next, b);

        if (a.length() > b.length()) {//a比b长
            if (isContain(b, a, next)) return 1;
            String newA = getRepeatedStr(a, 2);
            if (isContain(b, newA, next)) return 2;
            else return -1;
        }

        //b比a长
        int k = b.length() / a.length();
        for (int i = k; i < k + a.length(); i++) {
            String newA = getRepeatedStr(a, i);//a拼接k次,newa可能和b一样长
            if (newA.length() == b.length()) {
                if (newA.equals(b)) return i;
            }
            if (isContain(b, newA, next)) return i;

        }
        return -1;

    }

    public void getNext(int[] next, String s) {
        int j = 0;
        next[0] = 0;
        for (int i = 1; i < s.length(); i++) {
            while (j > 0 && s.charAt(j) != s.charAt(i)) j = next[j - 1];
            if (s.charAt(j) == s.charAt(i)) j++;
            next[i] = j;
        }
    }

    /**
     * 判断b是否包含a
     *
     * @param a
     * @param b
     * @param next:a的next数组，前缀表
     * @return
     */
    public boolean isContain(String a, String b, int[] next) {
        if (a.length() > b.length()) return false;
        int j = 0;
        for (int i = 0; i < b.length(); i++) {
            while (j > 0 && b.charAt(i) != a.charAt(j)) j = next[j - 1];
            if (b.charAt(i) == a.charAt(j)) j++;
            if (j == a.length()) return true;
        }
        return false;
    }

    public String getRepeatedStr(String s, int k) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < k; i++) {
            sb.append(s);
        }
        return sb.toString();
    }

    public static void main(String[] args) {
        RepeatedStringMatch stringMatch = new RepeatedStringMatch();
        String a = "abab";
        String b = "aba";
        System.out.println(stringMatch.repeatedStringMatch(a, b));
    }
}
~~~

### 思路2调java库函数indexof

~~~java
class Solution {
    public int repeatedStringMatch(String a, String b) {
        StringBuilder sb = new StringBuilder();
        int ans = 0;
        int max = 2 * a.length() + b.length();
        while (sb.length() < max) {
            sb.append(a);
            ans++;
            if (sb.toString().indexOf(b) != -1) return ans;
        }
        return -1;
    }
}
~~~

