---
title: 代码随想录2二叉树
categories:
  - 代码随想录
tags:
  - coding
  - java
mathjax: true
---
<meta name="referrer" content="no-referrer"/>


## 内容

**本节包括：**

- 二叉树（部分）

## 二叉树的最大深度

推荐方法，递归法

~~~java
 public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
~~~

左子树和右子树的最大深度 *l* 和 *r*，那么该二叉树的最大深度即为
$$
m a x ( l , r ) + 1
$$

## 111.二叉树的最小深度

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

### 误区

不能简单粗暴的求`Math.min(minDepth(root.left),minDepth(root.right))+1`

因为当左右子树一空一不空的时候，该节点并不是叶子节点，应当选取不为空的分叉继续递归求二叉树的最小深度。

### 正确解法一：递归

~~~java
public int minDepth(TreeNode root) {
        if (root == null) return 0;
        //1、到达叶子节点
        if (root.left == null && root.right == null) return 1;
        int l = minDepth(root.left);
        int r = minDepth(root.right);
        //2、左右子树有一个为空，选择不为空的的分支，l和r其中国一个必为0
        if (root.left == null || root.right == null)
            return l + r + 1;
        //3、左右子树均不为空，子树最短路径+1
        return Math.min(l, r) + 1;
        
    }
~~~

情况1和二可以合并

~~~java
 public int minDepth(TreeNode root) {
       if(root == null) return 0;
        int m1 = minDepth(root.left);
        int m2 = minDepth(root.right);
        //1.如果左孩子和右孩子有为空的情况，直接返回m1+m2+1
        //2.如果都不为空，返回较小深度+1
        return root.left == null || root.right == null ? m1 + m2 + 1 : Math.min(m1,m2) + 1;
    }
~~~

### 正确解法二：层序遍历

~~~java
public int minDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int depth = 0;
        while (!queue.isEmpty()){
            int size = queue.size();
            depth++;
            TreeNode cur = null;
            for (int i = 0; i < size; i++) {
                cur = queue.poll();
                //如果当前节点的左右孩子都为空，直接返回最小深度
                if (cur.left == null && cur.right == null){
                    return depth;
                }
                if (cur.left != null) queue.offer(cur.left);
                if (cur.right != null) queue.offer(cur.right);
            }
        }
        return depth;
    }
~~~

## 226.翻转二叉树

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

### 方法

前序遍历，左右子树翻转

~~~java
public class InvertBinTree {
    public TreeNode invertTree(TreeNode root) {
        preOrderInvertTree(root);
        return root;
    }

    public void preOrderInvertTree(TreeNode node) {
        if (node == null) return;
        swapChild(node);
        preOrderInvertTree(node.left);
        preOrderInvertTree(node.right);
    }

    public void swapChild(TreeNode node) {
        TreeNode tmpNode = node.right;
        node.right = node.left;
        node.left = tmpNode;
    }
}
~~~

## 222.完全二叉树的节点个数

给你一棵 **完全二叉树** 的根节点 `root` ，求出该树的节点个数。

> 先求它的左子树的节点数量，再求右子树的节点数量，最后取总和再加一 （加1是因为算上当前中间节点）就是目前节点为根节点的节点数量。

~~~java
public int countNodes(TreeNode root) {
        if (root == null) return 0;
        return countNodes(root.left) + countNodes(root.right) + 1;
    }
~~~

## 110.平衡二叉树

给定一个二叉树，判断它是否是高度平衡的二叉树。

思路

比较每一个节点的左右子树的高度差是否大于1

### 错误解法

~~~java
public boolean isBalanced(TreeNode root) {
        return maxDepthBalance(root) != -1;

    }

    public int maxDepthBalance(TreeNode node) {
        if (node == null) return 0;
        return Math.abs(maxDepthBalance(node.left) - maxDepthBalance(node.right)) > 1 ? -1 : Math.max(maxDepthBalance(node.left), maxDepthBalance(node.right)) + 1;
    }
~~~

没有考虑到`maxDepthBalance(node.left) - maxDepthBalance(node.right)`其中或许已经存在-1这种结果而不是真实的高度了

### 正确解法

如果当前传入节点为根节点的二叉树已经不是二叉平衡树了，还返回高度的话就没有意义了。

所以如果已经不是二叉平衡树了，可以返回-1 来标记已经不符合平衡树的规则了。

~~~java
 public boolean isBalanced(TreeNode root) {
        return maxDepthBalance(root) != -1;

    }

    /**
     * 所以如果已经不是二叉平衡树了，可以返回-1 来标记已经不符合平衡树的规则了。
     *
     * @param node
     * @return
     */
    public int maxDepthBalance(TreeNode node) {
        if (node == null) return 0;
        int leftDepth = maxDepthBalance(node.left);
        if (leftDepth == -1) return -1;
        int rightDepth = maxDepthBalance(node.right);
        if (rightDepth == -1)
            return -1;
        if (Math.abs(leftDepth - rightDepth) > 1) return -1;

        return Math.max(leftDepth, rightDepth) + 1;
    }
~~~

## 257.二叉树的所有路径

给定一个二叉树，返回所有从根节点到叶子节点的路径。

说明: 叶子节点是指没有子节点的节点。

### 法一

采用采用递归和回溯的方法求取所有路径

~~~java
List<String> res = new ArrayList<>();
public List<String> binaryTreePaths(TreeNode root) {
    if (root == null) return res;
    //traversal方法
    List<Integer> paths = new ArrayList<>();//已经遍历的节点
    traversal(root, paths, res);
    return res;
}
 public void traversal(TreeNode node, List<Integer> paths, List<String> res) {
        paths.add(node.val);//加入当前节点到路径
        if (node.left == null && node.right == null) {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < paths.size() - 1; i++) {// 将paths里记录的路径转为string格式
                sb.append(paths.get(i)).append("->");
            }
            sb.append(paths.get(paths.size() - 1));//加上最后一个节点（单独处理）
            res.add(sb.toString());//加入一个叶子节点的路径
            return;
        }
        //遍历左右节点路径，并回溯
        if (node.left != null) {
            traversal(node.left, paths, res);
            paths.remove(paths.size() - 1);//回溯
        }
        if (node.right != null) {
            traversal(node.right, paths, res);
            paths.remove(paths.size() - 1);
        }
    }
~~~

### 法二

采用不断生长公共子节点的方法

~~~java
List<String> res = new ArrayList<>();

    public List<String> binaryTreePaths(TreeNode root) {
        if (root == null) return res;
        growthTraversal(root, "");
        return res;
    }
public void growthTraversal(TreeNode node, String s) {
    if (node.left == null && node.right == null) {
        res.add(new StringBuilder(s).append(node.val).toString());
        return;
    }
    String tmp = new StringBuilder(s).append(node.val).append("->").toString();
    if (node.left != null) {
        growthTraversal(node.left, tmp);
    }
    if (node.right != null) {
        growthTraversal(node.right, tmp);
    }
}
~~~

### 小技巧

> 使用StringBuilder进行字符串拼接通常比直接使用字符串相加的方式更高效。这是因为StringBuilder是可变的，允许在同一对象上进行多次追加操作，而不会每次都创建一个新的字符串对象。
