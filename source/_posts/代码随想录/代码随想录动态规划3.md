---
title: 代码随想录-动态规划3
categories:
- code_Musing
tags:
- dp
---
<meta name="referrer" content="no-referrer"/>

# 内容

**本节包括：**

- 最长递增序列

<!--more-->

## 674. 最长连续递增序列

给定一个未经排序的整数数组，找到最长且 **连续递增的子序列**，并返回该序列的长度。

**连续递增的子序列** 可以由两个下标 `l` 和 `r`（`l < r`）确定，如果对于每个 `l <= i < r`，都有 `nums[i] < nums[i + 1]` ，那么子序列 `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` 就是连续递增子序列。

### 思路

不断记录每次最长连续递增序列，最后返回`r-l`和`maxLen`的更大值，考虑到最后的r也有可能是一个最大值但是没有被`maxLen`保存。

### 代码实现

~~~java
public int findLengthOfLCIS(int[] nums) {
    int l = 0, r = 1;
    int maxLen = 1;
    for (r = 1; r < nums.length; r++) {
        if (nums[r] > nums[r - 1]) {
            continue;
        } else {
            maxLen = Math.max(r - l, maxLen);
            l = r;
        }
    }
    return Math.max(r - l, maxLen);
}
~~~

## 718. 最长重复子数组

给两个整数数组 `nums1` 和 `nums2` ，返回 *两个数组中 **公共的** 、长度最长的子数组的长度* 。

**示例 1：**

```
输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
输出：3
解释：长度最长的公共子数组是 [3,2,1] 
```

### 思路

1. 确定dp数组（dp table）以及下标的含义

`dp[i][j]` ：以下标`i - 1`为结尾的A，和以下标`j - 1`为结尾的B，最长重复子数组长度为`dp[i][j]`。 （**特别注意**： “以下标i - 1为结尾的A” 标明一定是 以A[i-1]为结尾的字符串 ）

2. 确定递推公式

根据`dp[i][j]`的定义，`dp[i][j]`的状态只能由`dp[i - 1][j - 1]`推导出来。

即当A[i - 1] 和B[j - 1]相等的时候，`dp[i][j] = dp[i - 1][j - 1] + 1`;

### 代码实现

~~~java
public int findLength(int[] nums1, int[] nums2) {
    //以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i][j]。
    int[][] dp = new int[nums1.length + 1][nums2.length + 1];
    int maxLen = 0;
    for (int i = 1; i <= nums1.length; i++) {
        for (int j = 1; j <= nums2.length; j++) {
            if (nums1[i - 1] == nums2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            }
            if (dp[i][j] > maxLen) maxLen = dp[i][j];
        }
    }
    return maxLen;
}
~~~

## 1143.最长公共子序列

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

- 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

### 思路

1. 定dp数组（dp table）以及下标的含义

`dp[i][j]`：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为`dp[i][j]`

2. 确定递推公式

主要就是两大情况： text1[i - 1] 与 text2[j - 1]相同，text1[i - 1] 与 text2[j - 1]不相同

如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以`dp[i][j] = dp[i - 1][j - 1] + 1;`

如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。

即：`dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])`;

### 代码实现

~~~java
public class LongestCommonSubsequence {
public int longestCommonSubsequence(String text1, String text2) {
    int[][] dp = new int[text1.length() + 1][text2.length() + 1];//长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为`dp[i][j]`
    for (int i = 1; i <= text1.length(); i++) {
        for (int j = 1; j <= text2.length(); j++) {
            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[text1.length()][text2.length()];
}
}
~~~

## 1035.不相交的线

在两条独立的水平线上按给定的顺序写下 `nums1` 和 `nums2` 中的整数。

现在，可以绘制一些连接两个数字 `nums1[i]` 和 `nums2[j]` 的直线，这些直线需要同时满足：

-  `nums1[i] == nums2[j]`
- 且绘制的直线不与任何其他连线（非水平线）相交。

请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。

以这种方法绘制线条，并返回可以绘制的最大连线数。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2019/04/26/142.png" alt="img" style="zoom: 12%;" />

### 思路

等价于最长公共子序列

### 代码实现

~~~java
public int maxUncrossedLines(int[] nums1, int[] nums2) {
        int[][] dp = new int[nums1.length + 1][nums2.length + 1];//dp[i][j]:数组[0,i-1]和数组[0,j-1]的最大连线数
        for (int i = 1; i <= nums1.length; i++) {
            for (int j = 1; j <= nums2.length; j++) {
                if (nums1[i - 1] == nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
                else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        return dp[nums1.length][nums2.length];

    }
~~~

## 53. 最大子序和

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组**是数组中的一个连续部分。

### 思路

`dp[i]`当前的子数组最大和包含i

状态转移方程： `dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);`

### 代码实现

~~~java
 public int maxSubArray(int[] nums) {
    int[] dp = new int[nums.length];
    int maxSum = nums[0];
    dp[0] = nums[0];//当前的子数组最大和
    for (int i = 1; i < nums.length; i++) {
        dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
        if (dp[i] > maxSum) maxSum = dp[i];
    }
    return maxSum;
}
~~~

## 392.判断子序列

给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`"ace"`是`"abcde"`的一个子序列，而`"aec"`不是）。



### 思路

简单略

### 代码实现

~~~java
 public boolean isSubsequence(String s, String t) {
    if (s.isEmpty()) return true;
    int sIdx = 0;
    for (int i = 0; i < t.length(); i++) {
        if (s.charAt(sIdx) == t.charAt(i)) sIdx++;
        if (sIdx == s.length()) return true;
    }

    return false;
}
~~~

## 115.不同的子序列

给你两个字符串 `s` 和 `t` ，统计并返回在 `s` 的 **子序列** 中 `t` 出现的个数，结果需要对$$ 1 0 ^ { 9 } + 7$$取模。

```
输入：s = "rabbbit", t = "rabbit"
输出：3
```

### 思路

1. 确定dp数组（dp table）以及下标的含义

`dp[i][j]`：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为`dp[i][j]`。

2. 确定递推公式

- s[i - 1] 与 t[j - 1]相等，`dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]`，`s：bagg` 和 `t：bag` 
- s[i - 1] 与 t[j - 1] 不相等，`dp[i][j] = dp[i - 1][j]`，我们求的是 s 中有多少个 t，而不是 求t中有多少个s，所以只考虑 s中删除元素的情况，即 不用s[i - 1]来匹配 的情况3

3. dp数组如何初始化

`dp[i][0]` 表示：以i-1为结尾的s可以随便删除元素，出现空字符串的个数。

那么`dp[0][j]`一定都是0，s如论如何也变成不了t。

~~~c++
vector<vector<long long>> dp(s.size() + 1, vector<long long>(t.size() + 1));
for (int i = 0; i <= s.size(); i++) dp[i][0] = 1;
for (int j = 1; j <= t.size(); j++) dp[0][j] = 0; // 其实这行代码可以和dp数组初始化的时候放在一起，但我为了凸显初始化的逻辑，所以还是加上了。
~~~

### 代码实现

~~~java
public class NumDistinct {
    public int numDistinct(String s, String t) {
        int[][] dp = new int[s.length() + 1][t.length() + 1];//以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为`dp[i][j]`。
        for (int i = 0; i <= s.length(); i++) dp[i][0] = 1;//t为空字符串
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 1; j <= t.length(); j++) {
                if (s.charAt(i - 1) == t.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                else dp[i][j] = dp[i - 1][j];
            }
        }
        return dp[s.length()][t.length()];
    }
}
~~~

## 583. 两个字符串的删除操作

给定两个单词 `word1` 和 `word2` ，返回使得 `word1` 和 `word2` **相同**所需的**最小步数**。

**每步** 可以删除任意一个字符串中的一个字符。

### 思路

1. 定dp数组（dp table）以及下标的含义

`dp[i][j]`：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。

这里dp数组的定义有点点绕，大家要撸清思路。

2. 确定递推公式

- 当word1[i - 1] 与 word2[j - 1]相同的时候
- 当word1[i - 1] 与 word2[j - 1]不相同的时候

当word1[i - 1] 与 word2[j - 1]相同的时候，`dp[i][j] = dp[i - 1][j - 1];`

当word1[i - 1] 与 word2[j - 1]不相同的时候，有三种情况：

情况一：删word1[i - 1]，最少操作次数为`dp[i - 1][j] + 1`

情况二：删word2[j - 1]，最少操作次数为`dp[i][j - 1] + 1`

情况三：同时删word1[i - 1]和word2[j - 1]，操作的最少次数为`dp[i - 1][j - 1] + 2`

那最后当然是取最小值，所以当word1[i - 1] 与 word2[j - 1]不相同的时候，递推公式：`dp[i][j] = min({dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1, dp[i][j - 1] + 1});`

因为 `dp[i][j - 1] + 1 = dp[i - 1][j - 1] + 2`，所以递推公式可简化为：`dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);`

3. dp数组如何初始化

从递推公式中，可以看出来，`dp[i][0]` 和 `dp[0][j]`是一定要初始化的。

`dp[i][0]`：word2为空字符串，以i-1为结尾的字符串word1要删除多少个元素，才能和word2相同呢，很明显`dp[i][0] = i`。

### 代码实现

~~~java
public int minDistance(String word1, String word2) {
    int[][] dp = new int[word1.length() + 1][word2.length() + 1];//以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。
    //初始化
    for (int i = 0; i <= word1.length(); i++) {
        dp[i][0] = i;
    }
    for (int j = 0; j <= word2.length(); j++) {
        dp[0][j] = j;
    }
    for (int i = 1; i <= word1.length(); i++) {
        for (int j = 1; j <= word2.length(); j++) {
            if (word1.charAt(i - 1) == word2.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1];
            else dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);//删除word1和删除word2
        }
    }
    return dp[word1.length()][word2.length()];
}
~~~

### 思路2

最长公共子序列

### 代码实现2

~~~java
public int longestCommonSubSequence(String word1, String word2) {
    int[][] dp = new int[word1.length() + 1][word2.length() + 1];//以word1[0,i-1】和word2[0,j-1]的醉成公共子序列的长度
    for (int i = 1; i <= word1.length(); i++) {
        for (int j = 1; j <= word2.length(); j++) {
            if (word1.charAt(i - 1) == word2.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1] + 1;
            else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
        }
    }
    return word1.length() + word2.length() - dp[word1.length()][word2.length()] * 2;
}
~~~

## 72. 编辑距离

给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

 

**示例 1：**

```
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

### 思路

1. 确定dp数组（dp table）以及下标的含义

**`dp[i][j]` 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为`dp[i][j]`**。

2. 确定递推公式

`if (word1[i - 1] == word2[j - 1])` 那么说明不用任何编辑，`dp[i][j]` 就应该是 `dp[i - 1][j - 1]`，即`dp[i][j] = dp[i - 1][j - 1]`;
`if (word1[i - 1] != word2[j - 1])`，此时就需要编辑了，如何编辑呢？

- 操作一：word1删除一个元素，那么就是以下标i - 2为结尾的word1 与 j-1为结尾的word2的最近编辑距离 再加上一个操作。即 `dp[i][j] = dp[i - 1][j] + 1`;
- 操作二：word2删除一个元素，那么就是以下标i - 1为结尾的word1 与 j-2为结尾的word2的最近编辑距离 再加上一个操作。即 `dp[i][j] = dp[i][j - 1] + 1;`
- 操作三：替换元素，word1替换word1[i - 1]，使其与word2[j - 1]相同，此时不用增删加元素。那么只需要一次替换的操作，就可以让 word1[i - 1] 和 word2[j - 1] 相同。所以 `dp[i][j] = dp[i - 1][j - 1] + 1`;

**word2添加一个元素，相当于word1删除一个元素**，例如 `word1 = "ad" ，word2 = "a"`，`word1`删除元素`'d'` 和 `word2`添加一个元素`'d'`，变成`word1="a", word2="ad"`， 最终的操作数是一样！ dp数组如下图所示意的：

### 代码实现

~~~java
public int minDistance(String word1, String word2) {
    int[][] dp = new int[word1.length() + 1][word2.length() + 1];
    for (int i = 0; i <= word1.length(); i++) dp[i][0] = i;
    for (int j = 0; j <= word2.length(); j++) dp[0][j] = j;
    for (int i = 1; i <= word1.length(); i++) {
        for (int j = 1; j <= word2.length(); j++) {
            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
//                    dp[i][j] = Math.min(Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1), dp[i - 1][j - 1] + 1);//删除word1，删除word2，替换
                dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;//优化：删除word1，删除word2，替换

            }
        }
    }
    return dp[word1.length()][word2.length()];
}
~~~

## 647. 回文子串

给你一个字符串 `s` ，请你统计并返回这个字符串中 **回文子串** 的数目。

**回文字符串** 是正着读和倒过来读一样的字符串。

**子字符串** 是字符串中的由连续字符组成的一个序列。

### 思路

#### 暴力法

两层for循环，遍历区间起始位置和终止位置，然后还需要一层遍历判断这个区间是不是回文。所以时间复杂度：O(n^3)

#### 动态规划

1. 确定dp

布尔类型的`dp[i][j]`：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是`dp[i][j]`为true，否则为false。

注意，一定是`i<=j`

2. 确定递推公式

在确定递推公式时，就要分析如下几种情况。

整体上是两种，就是s[i]与s[j]相等，s[i]与s[j]不相等这两种。

当s[i]与s[j]不相等，那没啥好说的了，`dp[i][j]`一定是false。

当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况

- 情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串
- 情况二：下标i 与 j相差为1，例如aa，也是回文子串
- 情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看`dp[i + 1][j - 1]`是否为true。

4. 确定遍历顺序

遍历顺序可有有点讲究了。

首先从递推公式中可以看出，情况三是根据`dp[i + 1][j - 1]`是否为true，在对`dp[i][j]`进行赋值true的。

`dp[i + 1][j - 1]` 在 `dp[i][j]`的左下角

**所以一定要从下到上，从左到右遍历，这样保证`dp[i + 1][j - 1]`都是经过计算的**。

#### 双指针法

首先确定回文串，就是找中心然后向两边扩散看是不是对称的就可以了。

**在遍历中心点的时候，要注意中心点有两种情况**。

一个元素可以作为中心点，两个元素也可以作为中心点。

### 代码实现

#### 动态规划

~~~java
public int countSubstrings(String s) {
    int result = 0;
    boolean[][] dp = new boolean[s.length()][s.length()];
    //i在前，j在后
    for (int i = s.length() - 1; i >= 0; i--) {
        for (int j = i; j < s.length(); j++) {
            if (s.charAt(i) == s.charAt(j)) {//可能是回文
                if (j - i <= 1) {//单独的a，或者bb
                    dp[i][j] = true;
                    result++;
                } else {
                    dp[i][j] = dp[i + 1][j - 1];
                    if (dp[i][j]) result++;//是回文，结果加一
                }

            }
        }

    }
    return result;
}
~~~

#### 双指针法

~~~java
public int countSubstrings2(String s) {
    int res = 0;
    for (int i = 0; i < s.length(); i++) {
        res += centerExtend(s, i, i);
        res += centerExtend(s, i, i + 1);
    }
    return res;
}

public int centerExtend(String s, int i, int j) {
    int res = 0;
    while (i >= 0 && j < s.length() && s.charAt(i) == s.charAt(j)) {
        i--;
        j++;
        res++;
    }
    return res;
}
~~~

## 516.最长回文子序列

给你一个字符串 `s` ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

### 思路

1. 确定dp数组（dp table）以及下标的含义

**`dp[i][j]`：字符串s在[i, j]范围内最长的回文子序列的长度为`dp[i][j]`**。

2. 确定递推公式

在判断回文子串的题目中，关键逻辑就是看s[i]与s[j]是否相同。

如果s[i]与s[j]相同，那么`dp[i][j] = dp[i + 1][j - 1] + 2;`

如果s[i]与s[j]不相同，说明s[i]和s[j]的同时加入 并不能增加[i,j]区间回文子序列的长度，那么分别加入s[i]、s[j]看看哪一个可以组成最长的回文子序列。

加入s[j]的回文子序列长度为`dp[i + 1][j]`。

加入s[i]的回文子序列长度为`dp[i][j - 1]`。

那么dp[i][j]一定是取最大的，即：`dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);`

3. dp数组如何初始化

首先要考虑当i 和j 相同的情况，从递推公式：`dp[i][j] = dp[i + 1][j - 1] + 2;` 可以看出 递推公式是计算不到 i 和j相同时候的情况。

所以需要手动初始化一下，当i与j相同，那么`dp[i][j]`一定是等于1的，即：一个字符的回文子序列长度就是1。

### 代码实现

~~~java
public int longestPalindromeSubseq(String s) {
    int[][] dp = new int[s.length()][s.length()];//[i,j]子序列中的最长回文长度
    for (int i = 0; i < s.length(); i++) {
        dp[i][i] = 1;//初始化
    }
    for (int i = s.length() - 1; i >= 0; i--) {
        for (int j = i + 1; j < s.length(); j++) {
            if (s.charAt(i) == s.charAt(j)) dp[i][j] = dp[i + 1][j - 1] + 2;//中心两点扩展0+2
            else {
                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[0][s.length() - 1];
}
~~~
