---
title: 代码随想录-动态规划2
categories:
- code_Musing
tags:
- dp
---
<meta name="referrer" content="no-referrer"/>

# 内容

**本节包括：**

- 完全背包
- 打家劫色
- 买卖股票

<!--more-->

## 完全背包

有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大。

完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：

~~~java
// 先遍历物品，再遍历背包
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = weight[i]; j <= bagWeight ; j++) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
~~~

## 52 携带研究材料

小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的重量，并且具有不同的价值。

小明的行李箱所能承担的总重量为 N，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料可以选择无数次，并且可以重复选择。

第一行包含两个整数，N，V，分别表示研究材料的种类和行李空间 

接下来包含 N 行，每行两个整数 wi 和 vi，代表第 i 种研究材料的重量和价值

### 代码实现

~~~java
public class CarryingResearchMaterials {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int serials = scanner.nextInt();
        int bagSize = scanner.nextInt();
        int[][] values = new int[serials][2];
        int[] dp = new int[bagSize + 1];//dp[j]代表容量为j的背包能装的最大价值
        for (int i = 0; i < serials; i++) {
            values[i][0] = scanner.nextInt();//存储重量
            values[i][1] = scanner.nextInt();//存储价值
        }
        for (int i = 0; i < serials; i++) {
            for (int j = values[i][0]; j <= bagSize; j++) {
                dp[j] = Math.max(dp[j], dp[j - values[i][0]] + values[i][1]);
            }
        }
        System.out.println(dp[bagSize]);
    }

}
~~~

## 518.零钱兑换II

给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

### 代码实现

~~~java
public int change(int amount, int[] coins) {
    int[] dp = new int[amount + 1];//存储amount=i时共有几种兑换方式
    dp[0] = 1;
    for (int i = 0; i < coins.length; i++) {
        for (int j = coins[i]; j <= amount; j++) {
            dp[j] += dp[j - coins[i]];
        }
    }
    return dp[amount];
}
~~~

## 377. 组合总和 Ⅳ

给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

```
输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
```

### 思路

**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。

### 代码实现

~~~java
 public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target + 1];//总数为target一共有多少种组合
        dp[0] = 1;
        for (int i = 0; i <= target; i++) {//遍历背包
            for (int j = 0; j < nums.length; j++) {//遍历物品
                if (i >= nums[j]) {
                    dp[i] += dp[i - nums[j]];
                }
            }
        }
        return dp[target];
    }
~~~

## 70. 爬楼梯（进阶版）

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬至多m (1 <= m < n)个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

输入描述：输入共一行，包含两个正整数，分别表示n, m

输出描述：输出一个整数，表示爬到楼顶的方法数。

输入示例：3 2

输出示例：3

提示：

当 m = 2，n = 3 时，n = 3 这表示一共有三个台阶，m = 2 代表你每次可以爬一个台阶或者两个台阶。

此时你有三种方法可以爬到楼顶。

- 1 阶 + 1 阶 + 1 阶段
- 1 阶 + 2 阶
- 2 阶 + 1 阶

### 代码实现

~~~java
public class StairClimb {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        int[] dp = new int[n + 1];//楼梯为n阶移动有多少种爬楼梯方法
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {//遍历楼梯
            for (int j = 1; j <= m; j++) {
                if (i >= j) {
                    dp[i] += dp[i - j];
                }
            }
        }
        System.out.println(dp[n]);
    }
}
~~~

## 322. 零钱兑换

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。

### 思路

- 凑足总额为j - coins[i]的最少个数为`dp[j - coins[i]]`，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]）
- 首先凑足总金额为0所需钱币的个数一定是0，那么`dp[0] = 0`;
- dp[j]必须初始化为一个最大的数，否则就会在`min(dp[j - coins[i]] + 1, dp[j])`比较的过程中被初始值覆盖。

### 代码实现

~~~java
public int coinChange(int[] coins, int amount) {
    int[] dp = new int[amount + 1];
    Arrays.fill(dp, amount + 1);//dp[i]最大值是amount
    dp[0] = 0;
    for (int i = 0; i < coins.length; i++) {
        for (int j = coins[i]; j <= amount; j++) {//遍历amount
            dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);
        }
    }
    if (dp[amount] > amount) return -1;
    else return dp[amount];
}
~~~

## 279.完全平方数

给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

### 思路

完全平方数就是物品（可以无限件使用），凑个正整数n就是背包，问凑满这个背包最少有多少物品？

### 代码实现

~~~java
public class NumSquares {
    public int numSquares(int n) {
        int[] dp = new int[n + 1];
        Arrays.fill(dp, n);
        dp[0] = 0;
        for (int i = 1; i * i <= n; i++) {//遍历物品
            for (int j = i * i; j <= n; j++) {//遍历背包
                dp[j] = Math.min(dp[j], dp[j - i * i] + 1);
            }
        }
        return dp[n];
    }
}
~~~

## 139.单词拆分

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 `s` 则返回 `true`。

**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

**示例 1：**

```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
```

### 思路

单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。

如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j < i ）。

所以递推公式是 if([j, i] 这个区间的子串出现在字典里 `&& dp[j]`是true) 那么 `dp[i] = true`。

### 代码实现

~~~java
public boolean wordBreak(String s, List<String> wordDict) {
    HashSet<String> set = new HashSet<>(wordDict);
    boolean[] dp = new boolean[s.length() + 1];//记录字符串位置i处是否可以拼接
    dp[0] = true;
    for (int i = 1; i <= s.length(); i++) {//遍历字符串
        for (int j = 0; j < i && !dp[i]; j++) {//遍历单词
            if (set.contains(s.substring(j, i)) && dp[j]) {
                dp[i] = true;
            }
        }
    }
    return dp[s.length()];
}
~~~

## 198.打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

**示例 2：**

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

### 思路

1. 确定dp数组（dp table）以及下标的含义

**dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]**。

2. 确定递推公式

决定dp[i]的因素就是第i房间偷还是不偷。

如果偷第i房间，那么`dp[i] = dp[i - 2] + nums[i]` ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。

3. dp数组如何初始化

从递推公式dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);可以看出，递推公式的基础就是dp[0] 和 dp[1]

从dp[i]的定义上来讲，dp[0] 一定是 nums[0]，dp[1]就是nums[0]和nums[1]的最大值即：dp[1] = max(nums[0], nums[1]);

### 代码实现

~~~java
public int rob(int[] nums) {
    if (nums.length == 1)
        return nums[0];
    int[] dp = new int[nums.length];//考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]
    dp[0] = nums[0];
    dp[1] = Math.max(nums[0], nums[1]);
    for (int i = 2; i < nums.length; i++) {
        dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
    }
    return dp[nums.length - 1];
}
~~~

## 213.打家劫舍II

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 **围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警** 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **在不触动警报装置的情况下** ，今晚能够偷窃到的最高金额。

### 思路

- 情况一：考虑不包含首尾元素

- 情况二：考虑包含首元素，不包含尾元素
- 情况三：考虑包含尾元素，不包含首元素

**情况二 和 情况三 都包含了情况一了，所以只考虑情况二和情况三就可以了**。

### 代码实现

~~~java
public class Robber2 {
    public int rob(int[] nums) {
        if (nums.length == 1) return nums[0];
        int houses = nums.length;
        return Math.max(robAction(nums, 0, houses - 2), robAction(nums, 1, houses - 1));
    }
    public int robAction(int[] nums, int start, int end) {
        if (end == start) return nums[start];
        int[] dp = new int[nums.length - 1];
        int dpIdx = 2;
        dp[0] = nums[start];
        dp[1] = Math.max(nums[start + 1], dp[0]);
        for (int i = start + 2; i <= end; i++) {
            dp[dpIdx] = Math.max(dp[dpIdx - 2] + nums[i], dp[dpIdx - 1]);
            dpIdx++;
        }
        return dp[nums.length - 2];
    }

}
~~~

## 337.打家劫舍 III

小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 `root` 。

除了 `root` 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 **两个直接相连的房子在同一天晚上被打劫** ，房屋将自动报警。

给定二叉树的 `root` 。返回 ***在不触动警报的情况下** ，小偷能够盗取的最高金额* 。

### 思路

不能用后续遍历然后直接动态规划

<img src="https://assets.leetcode.com/uploads/2021/03/10/rob2-tree.jpg" alt="img" style="zoom:50%;" />

比如后续遍历：1、3、4、1、5、3，正确答案是4+5=9，而直接动态变为：1+4+5=10，那是因为如果不偷4，1和3可以偷，这与题意不符

**正确做法**

1. dp数组（dp table）以及下标的含义：

**下标为0记录不偷该节点所得到的的最大金钱，下标为1记录偷该节点所得到的的最大金钱。**

2. 在遍历的过程中，如果遇到空节点的话，很明显，无论偷还是不偷都是0，所以就返回

3. 确定遍历顺序

首先明确的是使用后序遍历。 因为要通过递归函数的返回值来做下一步计算。

通过递归左节点，得到左节点偷与不偷的金钱。

通过递归右节点，得到右节点偷与不偷的金钱。

### 代码实现

~~~java
public class Robber3 {
    public int rob(TreeNode root) {
        int[] dp = robAction(root);
        return Math.max(dp[0], dp[1]);
    }

    /**
     * 后续遍历，分情况讨论父子节点偷还是不偷
     *
     * @param root
     * @return
     */
    public int[] robAction(TreeNode root) {
        int[] dp = new int[2];//dp[0]不偷，dp[1]偷当前节点获取的金额
        if (root == null) return dp;

        int[] leftDp = robAction(root.left);
        int[] rightDp = robAction(root.right);

        dp[0] = Math.max(leftDp[0], leftDp[1]) + Math.max(rightDp[0], rightDp[1]);//不偷获取的金额
        dp[1] = leftDp[0] + rightDp[0] + root.val;
        return dp;
    }
}
~~~

## 121. 买卖股票的最佳时机

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

### 思路1

贪心：遍历，选取当前股票最低谷，然后计算当前的利润和以往的利润，取最大值，直到遍历完毕。

### 代码实现1

~~~java
 public int maxProfit(int[] prices) {
    int low = prices[0];
    int profit = 0;
    for (int i = 1; i < prices.length; i++) {
        low = Math.min(low, prices[i]);
        profit = Math.max(profit, prices[i] - low);
    }
    return profit;
}
~~~

### 思路2

动态规划：

`dp[i][0]` 表示第i天持有股票所得最多现金

`dp[i][1]` 表示第i天不持有股票所得最多现金

效率太低且繁琐

### 代码实现2

~~~java
public int maxProfitDP(int[] prices) {
    //`dp[i][0]` 表示第i天持有股票所得最多现金
    //`dp[i][1]` 表示第i天不持有股票所得最多现金
    int[][] dp = new int[prices.length + 1][2];
    dp[0][0] = -prices[0];
    for (int i = 1; i < prices.length; i++) {
        dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);//i-1天持有股票，i-1天没有股票
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);///i-1天没有股票，第i卖股票
    }
    return Math.max(dp[prices.length - 1][0], dp[prices.length - 1][1]);
}
~~~

## 122.买卖股票的最佳时机II

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

返回 *你能获得的 **最大** 利润* 。

### 思路

贪心：只选取获利两天进行购买和出售

动态规划：类似`买卖股票的最佳时机`，只不过可以多次购买和卖出

### 代码实现

~~~java
 public int maxProfit(int[] prices) {
    int profit = 0;
    for (int i = 1; i < prices.length; i++) {
        int tmp = prices[i] - prices[i - 1];
        if (tmp > 0) profit += tmp;
    }
    return profit;
}
~~~

~~~java
 public int maxProfitDp(int[] prices) {
    //`dp[i][0]` 表示第i天持有股票所得最多现金
    //`dp[i][1]` 表示第i天不持有股票所得最多现金
    int[][] dp = new int[prices.length + 1][2];
    dp[0][0] = -prices[0];
    for (int i = 1; i < prices.length; i++) {
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);//i-1天持有股票，i-1天没有股票
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);///i-1天没有股票，第i卖股票
    }
    return Math.max(dp[prices.length - 1][0], dp[prices.length - 1][1]);
}
~~~

## 123.买卖股票的最佳时机III

给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

### 思路

**动态数组定义：**

一天一共就有五个状态，

没有操作 （其实我们也可以不设置这个状态）

1. 第一次持有股票
2. 第一次不持有股票
3. 第二次持有股票
4. 第二次不持有股票

达到`dp[i][1]`状态，有两个具体操作：

- 操作一：第i天买入股票了，那么`dp[i][1] = dp[i-1][0] - prices[i]`
- 操作二：第i天没有操作，而是沿用前一天买入的状态，即：`dp[i][1] = dp[i - 1][1]`

同理`dp[i][2]`也有两个操作：

- 操作一：第i天卖出股票了，那么`dp[i][2] = dp[i - 1][1] + prices[i]`
- 操作二：第i天没有操作，沿用前一天卖出股票的状态，即：`dp[i][2] = dp[i - 1][2]`

其他类似......

**初始化：**

第0天做第一次买入的操作，`dp[0][1] = -prices[0];`

第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后再买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。

所以第二次买入操作，初始化为：`dp[0][3] = -prices[0];`

### 代码实现

~~~java
 public int maxProfit(int[] prices) {
    //0. 没有操作 （其实我们也可以不设置这个状态）
    //1. 第一次持有股票
    //2. 第一次不持有股票
    //3. 第二次持有股票
    //4. 第二次不持有股票
    int[][] dp = new int[prices.length][5];
    dp[0][1] = -prices[0];
    dp[0][3] = -prices[0];
    for (int i = 1; i < prices.length; i++) {
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
        dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
        dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
        dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
    }
    return dp[prices.length - 1][4];
}
~~~

## 188.买卖股票的最佳时机IV

给你一个整数数组 `prices` 和一个整数 `k` ，其中 `prices[i]` 是某支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 `k` 笔交易。也就是说，你最多可以买 `k` 次，卖 `k` 次。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

### 思路

类似`买卖股票的最佳时机III`，只不过总结规律

### 代码实现

~~~java
 public int maxProfit(int k, int[] prices) {
    //dp[i][0]什么都不做
    //dp[i][2*k-1]第k次买入股票
    //dp[i][2*k]第k次卖出股票
    int[][] dp = new int[prices.length][k * 2 + 1];
    for (int i = 1; i <= k; i++) {
        dp[0][2 * i - 1] = -prices[0];//初始化
    }
    for (int i = 1; i < prices.length; i++) {
        for (int j = 1; j <= k; j++) {
            dp[i][j * 2 - 1] = Math.max(dp[i - 1][j * 2 - 1], dp[i - 1][j * 2 - 2] - prices[i]);//买入
            dp[i][j * 2] = Math.max(dp[i - 1][j * 2], dp[i - 1][j * 2 - 1] + prices[i]);//卖出
        }
    }
    return dp[prices.length - 1][2 * k];
}
~~~

## 309.最佳买卖股票时机含冷冻期

给定一个整数数组`prices`，其中第 `prices[i]` 表示第 `*i*` 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

### 思路

1. 确定dp数组以及下标的含义

`dp[i][j]`，第i天状态为j，所剩的最多现金为`dp[i][j]`。

具体可以区分出如下四个状态：

- 状态一：持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）
- 不持有股票状态，这里就有两种卖出股票状态
  - 状态二：保持卖出股票的状态（两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作）
  - 状态三：今天卖出股票
- 状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！

[递推公式](https://www.programmercarl.com/0309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F.html#%E6%80%9D%E8%B7%AF)

### 代码实现

~~~java
public int maxProfit(int[] prices) {
    /**
     * - 状态一：持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）
     * - 不持有股票状态，这里就有两种卖出股票状态
     *     - 状态二：保持卖出股票的状态（两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作）
     *     - 状态三：今天卖出股票
     * - 状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！
     */
    int[][] dp = new int[prices.length][4];
    dp[0][0] = -prices[0];
    for (int i = 1; i < prices.length; i++) {
        dp[i][0] = Math.max(dp[i - 1][0], Math.max(dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i]));
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][3]);
        dp[i][2] = dp[i - 1][0] + prices[i];
        dp[i][3] = dp[i - 1][2];
    }
    return Math.max(dp[prices.length - 1][3], Math.max(dp[prices.length - 1][1], dp[prices.length - 1][2]));
}
~~~

## 714.买卖股票的最佳时机含手续费

给定一个整数数组 `prices`，其中 `prices[i]`表示第 `i` 天的股票价格 ；整数 `fee` 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

**注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

**示例 1：**

```
输入：prices = [1, 3, 2, 8, 4, 9], fee = 2
输出：8
解释：能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8
```

### 思路

`dp[i][0]` 表示第i天持有股票所省最多现金。 `dp[i][1]` 表示第i天不持有股票所得最多现金

### 代码实现

~~~java
public int maxProfit(int[] prices, int fee) {
    int dp[][] = new int[prices.length][2];
    dp[0][0] = -prices[0];//0持有股票
    dp[0][1] = 0;//1卖出股票
    for (int i = 1; i < prices.length; i++) {
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);
    }
    return dp[prices.length - 1][1];
}
~~~

## 300.最长递增子序列

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]`是数组 `[0,3,1,6,2,2,7]` 的子序列。

### 思路

**dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度**

最终结果不一定是`dp[nums.length-1]`处取得最大值，最长递增子序列不一定包含组后一个数。

位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。

所以：`if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);`

### 代码实现

~~~java
public int lengthOfLIS(int[] nums) {
    int[] dp = new int[nums.length];//dp[i]以i为结尾的序列的最长递增子序列
    for (int i = 0; i < nums.length; i++) {
        dp[i] = 1;
    }
    int maxLen = 1;
    for (int i = 1; i < nums.length; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[i] > nums[j]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
            if (dp[i] > maxLen) maxLen = dp[i];//更新当前最长递增子序列长度
        }
    }
    return maxLen;
}
~~~

