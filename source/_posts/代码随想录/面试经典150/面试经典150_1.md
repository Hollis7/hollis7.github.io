---
title: 面试经典150_1
categories:
- code_Musing
tags:
- leetcode
- interview_classic
---
<meta name="referrer" content="no-referrer"/>

# 内容

**本节包括：**

- 常见面试题

<!--more-->

## 88.合并两个有序数组

给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。

请你 **合并** `nums2` 到 `nums1` 中，使合并后的数组同样按 **非递减顺序** 排列。

**注意：**最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。`nums2` 的长度为 `n` 。

 

**示例 1：**

```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
```

### 思路

双指针

### 代码实现

~~~java
public void merge(int[] nums1, int m, int[] nums2, int n) {
    int m_n = m + n;
    int[] resNums = new int[m_n];
    int l1 = 0;
    int l2 = 0;
    int pos = 0;
    while (l1 < m && l2 < n) {
        if (nums1[l1] <= nums2[l2]) {
            resNums[pos++] = nums1[l1++];
        } else {
            resNums[pos++] = nums2[l2++];
        }
    }
    if (l1 < m) {
        System.arraycopy(nums1, l1, resNums, pos, m - l1);
    } else {
        System.arraycopy(nums2, l2, resNums, pos, n - l2);
    }
    System.arraycopy(resNums, 0, nums1, 0, m_n);
}
~~~

## 80.删除有序数组中的重复项2

给你一个有序数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使得出现次数超过两次的元素**只出现两次** ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组** 并在使用 O(1) 额外空间的条件下完成。

 **示例 1：**

```
输入：nums = [1,1,1,2,2,3]
输出：5, nums = [1,1,2,2,3]
解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。 不需要考虑数组中超出新长度后面的元素。
```

### 思路

双指针，左指针l指向存储位置，右指针i指向当前位置，满足条件才更新

### 代码实现

~~~java
public int removeDuplicates(int[] nums) {
    if (nums.length <= 2) return nums.length;
    int l = 1;
    for (int i = 2; i < nums.length; i++) {
        if (nums[i] == nums[l - 1]) continue;
        else {
            nums[++l] = nums[i];
        }
    }
    return l + 1;
}
~~~

## 26.删除有序数组中的重复项

给你一个 **非严格递增排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。

考虑 `nums` 的唯一元素的数量为 `k` ，你需要做以下事情确保你的题解可以被通过：

- 更改数组 `nums` ，使 `nums` 的前 `k` 个元素包含唯一元素，并按照它们最初在 `nums` 中出现的顺序排列。`nums` 的其余元素与 `nums` 的大小不重要。
- 返回 `k` 。

### 思路

只要当前位置的值和前面有效位置的值不同，那么有效位置向后移动一位，并且赋值。

### 代码实现

~~~java
public int removeDuplicates(int[] nums) {
    int l = 0;
    for (int i = 1; i < nums.length; i++) {
        if (nums[i] != nums[l]) {
            nums[++l] = nums[i];
        }
    }
    return l + 1;
}
~~~

## 274.H指数

给你一个整数数组 `citations` ，其中 `citations[i]` 表示研究者的第 `i` 篇论文被引用的次数。计算并返回该研究者的 **`h` 指数**。

根据维基百科上 [h 指数的定义](https://baike.baidu.com/item/h-index/3991452?fr=aladdin)：`h` 代表“高引用次数” ，一名科研人员的 `h` **指数** 是指他（她）至少发表了 `h` 篇论文，并且 **至少** 有 `h` 篇论文被引用次数大于等于 `h` 。如果 `h` 有多种可能的值，**`h` 指数** 是其中最大的那个。

 

**示例 1：**

```
输入：citations = [3,0,6,1,5]
输出：3 
解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。
由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。
```

**提示：**

- `n == citations.length`
- `1 <= n <= 5000`
- `0 <= citations[i] <= 1000`

### 思路

先排序

首先第一种情况，当前论文引用次数有超过h篇论文，`h = citations[i];`

当前论文引用次数没有超过h篇论文，需要讨论：`i+1`，和`citations.length - i`两种情况：

- 第一个位置的引用次数大于i+1（有点问题）
- 当前论文引用次数大于剩余的论文篇数（必定满足了）

### 代码实现

~~~java
public int hIndex(int[] citations) {
    if (citations.length == 0) return 0;
    Arrays.sort(citations);
    int h = 0;
    for (int i = 0; i < citations.length; i++) {
        //至少有h篇论文大于h此
        if (citations[i] <= citations.length - i) {
            h = citations[i];
        } else {
            if (citations[0] > i + 1) {
                h = Math.max(h, i + 1);
            }
            h = Math.max(h, citations.length - i);
        }
    }
    return h;
}
~~~

### 思路2推荐

==排序，但是从后向前比==

根据 H 指数的定义，如果当前 H 指数为 h 并且在遍历过程中找到当前值 `citations[i]>h`，则说明我们找到了一篇被引用了至少 h+1 次的论文，所以将现有的 h 值加 1。继续遍历直到 h 无法继续增大。最后返回 h 作为最终答案。

作者：力扣官方题解

### 代码实现

~~~java
public int hIndex(int[] citations) {
    Arrays.sort(citations);
    int h = 0, i = citations.length - 1;
    while (i >= 0 && citations[i] > h) {
        h++;
        i--;
    }
    return h;
}
~~~

## 380. O(1)时间插入、册 删除和获取随机元素

实现`RandomizedSet` 类：

- `RandomizedSet()` 初始化 `RandomizedSet` 对象
- `bool insert(int val)` 当元素 `val` 不存在时，向集合中插入该项，并返回 `true` ；否则，返回 `false` 。
- `bool remove(int val)` 当元素 `val` 存在时，从集合中移除该项，并返回 `true` ；否则，返回 `false` 。
- `int getRandom()` 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 **相同的概率** 被返回。

你必须实现类的所有函数，并满足每个函数的 **平均** 时间复杂度为 `O(1)` 。

 

**示例：**

```
输入
["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"]
[[], [1], [2], [2], [], [1], [2], []]
输出
[null, true, false, true, 2, true, false, 2]

解释
RandomizedSet randomizedSet = new RandomizedSet();
randomizedSet.insert(1); // 向集合中插入 1 。返回 true 表示 1 被成功地插入。
randomizedSet.remove(2); // 返回 false ，表示集合中不存在 2 。
randomizedSet.insert(2); // 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。
randomizedSet.getRandom(); // getRandom 应随机返回 1 或 2 。
randomizedSet.remove(1); // 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。
randomizedSet.insert(2); // 2 已在集合中，所以返回 false 。
randomizedSet.getRandom(); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。
```

### 思路1

用map存储元素，插入和删除比较好实现，但是随机获取一个元素自动是采用遍历加随机数实现O（n）

### 代码实现

~~~java
public class RandomizedSet {
    private Map<Integer, Boolean> map;
    private Random random;

    public RandomizedSet() {
        map = new HashMap<>();
        random = new Random();
    }

    public boolean insert(int val) {
        if (map.containsKey(val)) {
            return false;
        } else {
            map.put(val, true);
            return true;
        }
    }

    public boolean remove(int val) {
        if (map.containsKey(val)) {
            map.remove(val);
            return true;
        } else {
            return false;
        }
    }

    public int getRandom() {
        int index = random.nextInt(map.size());
        for (Integer num : map.keySet()) {
            if (index == 0) return num;
            else --index;
        }
        return 0;
    }
}
~~~

### 思路

变长数组可以在 O(1) 的时间内完成获取随机元素操作，但是由于无法在 O(1) 的时间内判断元素是否存在，因此不能在 O(1) 的时间内完成插入和删除操作。哈希表可以在 O(1) 的时间内完成插入和删除操作，但是由于无法根据下标定位到特定元素，因此不能在 O(1) 的时间内完成获取随机元素操作。为了满足插入、删除和获取随机元素操作的时间复杂度都是 O(1)，需要将变长数组和哈希表结合，变长数组中存储元素，哈希表中存储每个元素在变长数组中的下标。

**插入操作时，首先判断 val 是否在哈希表中，如果已经存在则返回 false，如果不存在则插入 val，操作如下：**

在变长数组的末尾添加 val；

在添加 val 之前的变长数组长度为 val 所在下标 index，将 val 和下标 index 存入哈希表；

返回 true。

**删除操作时，首先判断 val 是否在哈希表中，如果不存在则返回 false，如果存在则删除 val，操作如下：**

从哈希表中获得 val 的下标 index；

将变长数组的最后一个元素 last 移动到下标 index 处，在哈希表中将 last 的下标更新为 index；

在变长数组中删除最后一个元素，在哈希表中删除 val；

返回 true。

==作者：力扣官方题解==

### 代码实现

~~~java
public class RandomizedSet {
    Map<Integer, Integer> indices;
    List<Integer> list;
    Random random;


    public RandomizedSet() {
        indices = new HashMap<>();
        list = new ArrayList<>();
        random = new Random();
    }

    public boolean insert(int val) {
        if (indices.containsKey(val)) {
            return false;
        } else {
            int curIndex = indices.size();
            list.add(val);
            indices.put(val, curIndex);
            return true;
        }
    }

    public boolean remove(int val) {
        if (!indices.containsKey(val)) {
            return false;
        } else {
            int last = indices.size() - 1;
            int index = indices.get(val);
            indices.remove(val);
            int lastValue = list.get(last);
            list.set(index, lastValue);
            list.remove(last);
            return true;
        }
    }

    public int getRandom() {
        int index = random.nextInt(indices.size());
        return list.get(index);

    }
}
~~~

## 58.最后一个单词的长度

你一个字符串 `s`，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 **最后一个** 单词的长度。

**单词** 是指仅由字母组成、不包含任何空格字符的最大子字符串。

**示例 1：**

```
输入：s = "Hello World"
输出：5
解释：最后一个单词是“World”，长度为 5。
```

### 思路

从后向前遍历，从第一个不是空格的位置开始计数，这里是最后一个单词的末尾。

### 代码实现

~~~java
public int lengthOfLastWord(String s) {
    int lastWordEnd = 0;
    for (int i = s.length() - 1; i >= 0; i--) {
        if (s.charAt(i) != ' ') {
            lastWordEnd = i;
            break;
        }
    }
    int lastLen = 0;
    for (int i = lastWordEnd; i >= 0; i--) {
        if (s.charAt(i) != ' ') {
            lastLen++;
        } else {
            break;
        }
    }
    return lastLen;
}
~~~

或者直接用函数，效率变低

~~~java
public int lengthOfLastWord(String s) {
    String[] split = s.split(" ");
    int length = split.length;
    return split[length - 1].length();
}
~~~

