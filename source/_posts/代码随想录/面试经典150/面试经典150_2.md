---
title: 面试经典150_2
categories:
- code_Musing
tags:
- leetcode
- interview_classic
---
<meta name="referrer" content="no-referrer"/>

# 内容

**本节包括：**

- 常见经典面试题150

<!--more-->

## 14.最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 `""`。

**示例 1：**

```
输入：strs = ["flower","flow","flight"]
输出："fl"
```

**示例 2：**

```
输入：strs = ["dog","racecar","car"]
输出：""
解释：输入不存在公共前缀。
```

## 125.验证回文串

如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 **回文串** 。

字母和数字都属于字母数字字符。

给你一个字符串 `s`，如果它是 **回文串** ，返回 `true` ；否则，返回 `false` 。

### 思路

只加入数字和字母，并将字母小写，然后验证回文

### 代码实现

~~~java
public boolean isPalindrome(String s) {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < s.length(); i++) {
        char tmp = s.charAt(i);
        if (tmp >= 'A' && tmp <= 'Z') {
            tmp = Character.toLowerCase(tmp);
            sb.append(tmp);
        } else if (tmp >= 'a' && tmp <= 'z') {
            sb.append(tmp);
        } else if (tmp >= '0' && tmp <= '9') {
            sb.append(tmp);
        } else continue;
    }
    int l = 0, r = sb.length() - 1;
    while (l < r) {
        if (sb.charAt(l) != sb.charAt(r))
            return false;
        l++;
        r--;
    }
    return true;
}
~~~

## 6.Z字形变换

将一个给定字符串 `s` 根据给定的行数 `numRows` ，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 `"PAYPALISHIRING"` 行数为 `3` 时，排列如下：

```
P   A   H   N
A P L S I I G
Y   I   R
```

之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：`"PAHNAPLSIIGYIR"`。

请你实现这个将字符串进行指定行数变换的函数：

```
string convert(string s, int numRows);
```

**示例 1：**

```
输入：s = "PAYPALISHIRING", numRows = 3
输出："PAHNAPLSIIGYIR"
```

**示例 2：**

```
输入：s = "PAYPALISHIRING", numRows = 4
输出："PINALSIGYAHRPI"
解释：
P     I    N
A   L S  I G
Y A   H R
P     I
```

### 思路

按照规律进行排布，比较繁琐

### 代码实现

~~~java
public String convert(String s, int numRows) {
    if (numRows == 1) return s;
    int cycles = 2 * numRows - 2;
    int cols = (s.length() + cycles - 1) / cycles * (numRows - 1);
    char[][] zArrays = new char[numRows][cols];
    insertZStr(zArrays, s, cycles);
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < numRows; i++) {
        for (int j = 0; j < cols; j++) {
            if (zArrays[i][j] != '\u0000') {
                sb.append(zArrays[i][j]);
            }
        }
    }
    return sb.toString();
}

public void insertZStr(char[][] zArrays, String s, int cycles) {
    int numRows = zArrays.length;
    int pos = 0;
    while (pos < s.length()) {
        int i = 0;
        int j = 0;
        int modPos = pos % cycles;
        if (modPos < numRows) {
            i = modPos;
            j = (pos / cycles) * (numRows - 1);
        } else {
            i = 2 * numRows - modPos - 2;
            j = (pos / cycles) * (numRows - 1) + modPos - numRows + 1;
        }
        zArrays[i][j] = s.charAt(pos);
        pos++;
    }
}
~~~

### 思路

设numRows行字符串分别为*s*1 , *s*2 , … , *sn*,则容易发现：按顺序遍历字符串s时，每个字符c在N字形中对应的行索引先从s1增大至sn，再从sn减小至s1…如此反复。

### 代码实现

~~~java
public String convert(String s, int numRows) {
    if(numRows < 2) return s;
    List<StringBuilder> rows = new ArrayList<StringBuilder>();
    for(int i = 0; i < numRows; i++) rows.add(new StringBuilder());
    int i = 0, flag = -1;
    for(char c : s.toCharArray()) {
        rows.get(i).append(c);
        if(i == 0 || i == numRows -1) flag = - flag;
        i += flag;
    }
    StringBuilder res = new StringBuilder();
    for(StringBuilder row : rows) res.append(row);
    return res.toString();
}
~~~

## 167.两数之和2-输入有序数组

给你一个下标从 **1** 开始的整数数组 `numbers` ，该数组已按 **非递减顺序排列** ，请你从数组中找出满足相加之和等于目标数 `target` 的两个数。如果设这两个数分别是 `numbers[index1]` 和 `numbers[index2]` ，则 `1 <= index1 < index2 <= numbers.length` 。

以长度为 2 的整数数组 `[index1, index2]` 的形式返回这两个整数的下标 `index1` 和 `index2`。

你可以假设每个输入 **只对应唯一的答案** ，而且你 **不可以** 重复使用相同的元素。

你所设计的解决方案必须只使用常量级的额外空间。

 

**示例 1：**

```
输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。
```

**示例 2：**

```
输入：numbers = [2,3,4], target = 6
输出：[1,3]
解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。
```

### 思路

遍历，以index1为基准，查找另一个数，找到后立即停止，效率较低

空间复杂度O（1）

### 代码实现

~~~java
 public int[] twoSum(int[] numbers, int target) {
        int[] ans = new int[2];
        boolean stop = false;
        for (int i = 0; i < numbers.length; i++) {
            if (stop) break;
            int tmp = numbers[i];
            int anotherIndex = getAnotherIndex(numbers, i + 1, target - numbers[i]);
            if (anotherIndex == -1) continue;
            else {
                ans[0] = i + 1;
                ans[1] = anotherIndex + 1;
                stop = true;
            }
        }
        return ans;

    }

    public int getAnotherIndex(int[] numbers, int start, int target) {
        for (int i = start; i < numbers.length; i++) {
            if (numbers[i] == target) return i;
            if (numbers[i] > target) break;
        }
        return -1;
    }
~~~

### 思路2

有序数组可以用二分搜索

也可应用双指针

### 代码实现

~~~java
public int[] twoSum(int[] numbers, int target) {
    int l = 0, r = numbers.length - 1;
    while (l < r) {
        if (numbers[l] + numbers[r] == target) {
            return new int[]{l + 1, r + 1};
        } else if (numbers[l] + numbers[r] < target) {
            l++;
        } else {
            r--;
        }
    }
    return new int[]{-1, -1};
}
~~~

## 205.同构字符串

给定两个字符串 `s` 和 `t` ，判断它们是否是同构的。

如果 `s` 中的字符可以按某种映射关系替换得到 `t` ，那么这两个字符串是同构的。

每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

**示例 1:**

```
输入：s = "egg", t = "add"
输出：true
```

**示例 2：**

```
输入：s = "foo", t = "bar"
输出：false
```

### 思路

用Map构造映射表，注意同构的性质，正反都要检测

### 代码实现

~~~java
public boolean isIsomorphic(String s, String t) {
    boolean res1 = oneWayMapping(s, t);
    boolean res2 = oneWayMapping(t, s);
    return res1 && res2;
}

public boolean oneWayMapping(String s, String t) {
    Map<Character, Character> map = new HashMap<>();
    if (s.length() != t.length()) return false;
    for (int i = 0; i < s.length(); i++) {
        if (!map.containsKey(s.charAt(i))) {
            map.put(s.charAt(i), t.charAt(i));
        } else {
            if (map.get(s.charAt(i)) != t.charAt(i)) return false;
        }
    }
    return true;
}
~~~

## 36.有效的数独

请你判断一个 `9 x 9` 的数独是否有效。只需要 **根据以下规则** ，验证已经填入的数字是否有效即可。

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）

 

**注意：**

- 一个有效的数独（部分已被填充）不一定是可解的。
- 只需要根据以上规则，验证已经填入的数字是否有效即可。
- 空白格用 `'.'` 表示。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png)

```
输入：board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：true
```

### 思路

分行，分列，分块进行讨论就行，要注意字符和数字间进行转换

### 代码实现

~~~java
private int size = 9;

public boolean isValidSudoku(char[][] board) {
    return rowAndColIsValid(board) && blockIsValid(board);
}

public boolean rowAndColIsValid(char[][] board) {
    for (int i = 0; i < size; i++) {
        int[] used = new int[size + 1];
        for (int j = 0; j < size; j++) {
            if (board[i][j] == '.') continue;
            else if (used[board[i][j] - '0'] == 1) return false;
            else used[board[i][j] - '0'] = 1;
        }
    }
    for (int j = 0; j < size; j++) {
        int[] used = new int[size + 1];
        for (int i = 0; i < size; i++) {
            if (board[i][j] == '.') continue;
            else if (used[board[i][j] - '0'] == 1) return false;
            else used[board[i][j] - '0'] = 1;
        }
    }
    return true;
}

public boolean blockIsValid(char[][] board) {
    for (int k = 0; k < size; k++) {
        int startI = k / 3;
        int startJ = k - startI * 3;
        int[] used = new int[size + 1];
        for (int i = startI * 3; i < (startI * 3 + 3); i++) {
            for (int j = startJ * 3; j < (startJ * 3 + 3); j++) {
                if (board[i][j] == '.') continue;
                else if (used[board[i][j] - '0'] == 1) return false;
                else used[board[i][j] - '0'] = 1;
            }
        }
    }
    return true;
}
~~~

## 290.单词规律

给定一种规律 `pattern` 和一个字符串 `s` ，判断 `s` 是否遵循相同的规律。

这里的 **遵循** 指完全匹配，例如， `pattern` 里的每个字母和字符串 `s` 中的每个非空单词之间存在着双向连接的对应规律。

**示例1:**

```
输入: pattern = "abba", s = "dog cat cat dog"
输出: true
```

### 思路

- 用两个hash表双向映射关系，判断正反关系是否正确，和同构那道题类似
- 检查单词数和pattern长度是否一致

### 代码实现

~~~java
public boolean wordPattern(String pattern, String s) {
    char[] charArray = pattern.toCharArray();
    Map<Character, String> map1 = new HashMap<>();
    Map<String, Character> map2 = new HashMap<>();
    String[] words = s.split(" ");
    if (words.length != charArray.length) return false;
    for (int i = 0; i < charArray.length; i++) {
        if (map1.containsKey(charArray[i])) {
            if (!words[i].equals(map1.get(charArray[i]))) return false;
        } else {
            map1.put(charArray[i], words[i]);
        }
        if (map2.containsKey(words[i])) {
            if (charArray[i] != map2.get(words[i])) return false;
        } else {
            map2.put(words[i], charArray[i]);
        }
    }
    return true;
}
~~~

### 思路2

```java
判断第一次出现的位置是否对应-->不对应就返回false
```

### 代码实现

~~~java
public boolean wordPattern(String pattern, String s) {
    // 将字符串进行按照空格切割，并转为list集合存放
    List<String> ls = Arrays.asList(s.split(" "));
    int n = pattern.length();
    if (n != ls.size()) return false;// 长度不同，肯定就不会为true
    for (int i = 0; i < n; i++) {
        // 判断第一次出现的位置是否对应-->不对应就返回false
        if (pattern.indexOf(pattern.charAt(i)) != ls.indexOf(ls.get(i)))
            return false;
    }
    return true;
}
~~~

