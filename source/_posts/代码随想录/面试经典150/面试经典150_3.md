---
title: 面试经典150_3
categories:
- code_Musing
tags:
- leetcode
- interview_classic
---
<meta name="referrer" content="no-referrer"/>

# 内容

**本节包括：**

- 常见经典面试题150

<!--more-->

## 289.生命游戏

根据 [百度百科](https://baike.baidu.com/item/生命游戏/2926434?fr=aladdin) ， **生命游戏** ，简称为 **生命** ，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。

给定一个包含 `m × n` 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态： `1` 即为 **活细胞** （live），或 `0` 即为 **死细胞** （dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：

1. 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；
2. 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；
3. 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；
4. 如果死细胞周围正好有三个活细胞，则该位置死细胞复活；

下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。给你 `m x n` 网格面板 `board` 的当前状态，返回下一个状态。

### 思路

用一个和board相同大小的数组记录下一个状态，然后再深拷贝回来

要注意越界条件

### 代码实现

~~~java
private int[][] directions = {{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}};

public void gameOfLife(int[][] board) {
    int[][] copyBoard = new int[board.length][board[0].length];
    deepCopy(copyBoard, board);
    for (int i = 0; i < copyBoard.length; i++) {
        for (int j = 0; j < copyBoard[0].length; j++) {
            int counts = 0;
            for (int k = 0; k < 8; k++) {
                int idx = i + directions[k][0];
                int idy = j + directions[k][1];
                if (idx < 0 || idx >= board.length || idy < 0 || idy >= board[0].length) {
                    continue;
                }
                if (board[idx][idy] == 1) counts++;
            }
            if (board[i][j] == 1) {
                if (counts < 2) {
                    copyBoard[i][j] = 0;
                } else if (counts > 3) {
                    copyBoard[i][j] = 0;
                } else {
                    continue;
                }
            }
            if (board[i][j] == 0 && counts == 3) {
                copyBoard[i][j] = 1;
            }
        }
    }
    deepCopy(board, copyBoard);

}

public void deepCopy(int[][] board, int[][] oldBoard) {
    for (int i = 0; i < board.length; i++) {
        for (int j = 0; j < board[0].length; j++) {
            board[i][j] = oldBoard[i][j];
        }
    }
}
~~~

### 思路2

使用额外的状态：

规则 1：如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡。这时候，将细胞值改为 -1，代表这个细胞过去是活的现在死了；

规则 2：如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活。这时候不改变细胞的值，仍为 1；

规则 3：如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡。这时候，将细胞的值改为 -1，代表这个细胞过去是活的现在死了。可以看到，因为规则 1 和规则 3 下细胞的起始终止状态是一致的，因此它们的复合状态也一致；

规则 4：如果死细胞周围正好有三个活细胞，则该位置死细胞复活。这时候，将细胞的值改为 2，代表这个细胞过去是死的现在活了。

- 时间复杂度：*O*(*mn*)，其中 *m*，*n* 分别为 `board` 的行数和列数。
- 空间复杂度：*O*(1)，除原数组外只需要常数的空间存放若干变量。

## 219.存在重复元素2

给你一个整数数组 `nums` 和一个整数 `k` ，判断数组中是否存在两个 **不同的索引** `i` 和 `j` ，满足 `nums[i] == nums[j]` 且 `abs(i - j) <= k` 。如果存在，返回 `true` ；否则，返回 `false` 。

**示例 1：**

```
输入：nums = [1,2,3,1], k = 3
输出：true
```

### 思路

用hash表存储元素出现的最新位置， 实时更新，判断是否有符合`abs(i - j) <= k`的情况

### 代码实现

~~~java
public boolean containsNearbyDuplicate(int[] nums, int k) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        if (map.containsKey(nums[i])) {
            if (i - map.get(nums[i]) <= k) return true;
        }
        map.put(nums[i], i);
    }
    return false;
}
~~~

## 228.汇总区间

给定一个  **无重复元素** 的 **有序** 整数数组 `nums` 。

返回 ***恰好覆盖数组中所有数字** 的 **最小有序** 区间范围列表* 。也就是说，`nums` 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 `nums` 的数字 `x` 。

列表中的每个区间范围 `[a,b]` 应该按如下格式输出：

- `"a->b"` ，如果 `a != b`
- `"a"` ，如果 `a == b`

**示例 1：**

```
输入：nums = [0,1,2,4,5,7]
输出：["0->2","4->5","7"]
解释：区间范围是：
[0,2] --> "0->2"
[4,5] --> "4->5"
[7,7] --> "7"
```

### 思路

根据`nums[i] - 1 != nums[i - 1]`分情况讨论，但是要注意最后一处位置的处理

### 代码实现

~~~java
public List<String> summaryRanges(int[] nums) {
    List<String> res = new ArrayList<>();
    if (nums.length == 0) return res;
    int l = nums[0];
    int r = nums[0];
    for (int i = 1; i < nums.length; i++) {
        if (nums[i] - 1 != nums[i - 1]) {
            r = nums[i - 1];
            if (l == r) {
                res.add("" + l);
            } else {
                res.add(l + "->" + r);
            }
            l = nums[i];
        }
    }
    if (l == nums[nums.length - 1]) {
        res.add("" + l);
    } else {
        res.add(l + "->" + nums[nums.length - 1]);
    }

    return res;
}
~~~

## 57.插入区间

给你一个 **无重叠的** *，*按照区间起始端点排序的区间列表 `intervals`，其中 `intervals[i] = [starti, endi]` 表示第 `i` 个区间的开始和结束，并且 `intervals` 按照 `starti` 升序排列。同样给定一个区间 `newInterval = [start, end]` 表示另一个区间的开始和结束。

在 `intervals` 中插入区间 `newInterval`，使得 `intervals` 依然按照 `starti` 升序排列，且区间之间不重叠（如果有必要的话，可以合并区间）。

返回插入之后的 `intervals`。

**注意** 你不需要原地修改 `intervals`。你可以创建一个新数组然后返回它。

 

**示例 1：**

```
输入：intervals = [[1,3],[6,9]], newInterval = [2,5]
输出：[[1,5],[6,9]]
```

### 思路

将两个区间合并在一起，先排序，让所有的相邻区间尽可能的重叠在一起，按左边界，或者右边界排序都可以，处理逻辑稍有不同。

`intervals[i][0] > r`，表明当前区间不能和前面的区间合并

合并区间后左边界和右边界，作为一个新的区间，加入到result数组里就可以了

### 代码实现

~~~java
public int[][] insert(int[][] intervals, int[] newInterval) {
    int[][] curIntervals = new int[intervals.length + 1][2];
    List<int[]> res = new ArrayList<>();

    System.arraycopy(intervals, 0, curIntervals, 0, intervals.length);
    curIntervals[curIntervals.length - 1][0] = newInterval[0];
    curIntervals[curIntervals.length - 1][1] = newInterval[1];
    Arrays.sort(curIntervals, (a, b) -> {
        if (a[0] == b[0]) return a[1] - b[1];
        else return a[0] - b[0];
    });
    int l = curIntervals[0][0];
    int r = curIntervals[0][1];
    for (int i = 1; i < curIntervals.length; i++) {
        if (curIntervals[i][0] > r) {
            res.add(new int[]{l, r});
            l = curIntervals[i][0];
            r = curIntervals[i][1];
        } else {
            r = Math.max(r, curIntervals[i][1]);
        }
    }
    res.add(new int[]{l, r});
    int[][] ans = new int[res.size()][2];
    for (int i = 0; i < res.size(); i++) {
        ans[i][0] = res.get(i)[0];
        ans[i][1] = res.get(i)[1];
    }
    return ans;
}
~~~

## 92.反转链表川

给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg)

```
输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
```

### 思路

队列存储2个不变的链表部分，栈存储反转的部分，最后位置的指针指向空

### 代码实现

~~~java
public class ReverseBetween {
public ListNode reverseBetween(ListNode head, int left, int right) {
    Deque<ListNode> stack = new LinkedList<>();
    Deque<ListNode> queue1 = new LinkedList<>();
    Deque<ListNode> queue2 = new LinkedList<>();
    ListNode cur = head;
    for (int i = 1; cur != null; i++) {
        if (i < left) {
            queue1.offer(cur);
        } else if (i >= left && i <= right) {
            stack.push(cur);
        } else {
            queue2.offer(cur);
        }
        cur = cur.next;
    }
    ListNode p = new ListNode();
    ListNode res = p;
    while (!queue1.isEmpty()) {
        p.next = queue1.poll();
        p = p.next;
    }
    while (!stack.isEmpty()) {
        p.next = stack.pop();
        p = p.next;
    }
    while (!queue2.isEmpty()) {
        p.next = queue2.poll();
        p = p.next;
    }
    p.next = null;
    return res.next;
}
~~~

## 71.简化路径

给你一个字符串 `path` ，表示指向某一文件或目录的 Unix 风格 **绝对路径** （以 `'/'` 开头），请你将其转化为 **更加简洁的规范路径**。

在 Unix 风格的文件系统中规则如下：

- 一个点 `'.'` 表示当前目录本身。
- 此外，两个点 `'..'` 表示将目录切换到上一级（指向父目录）。
- 任意多个连续的斜杠（即，`'//'` 或 `'///'`）都被视为单个斜杠 `'/'`。
- 任何其他格式的点（例如，`'...'` 或 `'....'`）均被视为有效的文件/目录名称。

返回的 **简化路径** 必须遵循下述格式：

- 始终以斜杠 `'/'` 开头。
- 两个目录名之间必须只有一个斜杠 `'/'` 。
- 最后一个目录名（如果存在）**不能** 以 `'/'` 结尾。
- 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 `'.'` 或 `'..'`）。

返回简化后得到的 **规范路径** 。

 

**示例 1：**

**输入：**path = "/home/"

**输出：**"/home"

**解释：**

应删除尾随斜杠。

### 思路

将字符串用`/`分隔成字符串数组，分情况讨论，最后将正常用`/`+文件名进行重组

代码可以简化

### 代码实现

~~~java
public String simplifyPath(String path) {
    String[] split = path.split("/");
    for (int i = 0; i < split.length; i++) {
        if (split[i].isEmpty()) {
            continue;
        } else if (split[i].equals(".")) {
            split[i] = "";
        } else if (split[i].equals("..")) {
            split[i] = "";
            int k = i - 1;
            while (k >= 0 && split[k].equals("")) {
                k--;
            }
            if (k >= 0) split[k] = "";
        } else if (split[i].matches("\\.{3,}")) {
            continue;
        } else {//正常字符串
            continue;
        }
    }
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < split.length; i++) {
        if (!split[i].isEmpty()) {
            sb.append("/");
            sb.append(split[i]);
        }
    }
    if (sb.toString().isEmpty()) return "/";
    return sb.toString();
}
~~~

### 简化代码

~~~java
for (int i = 0; i < split.length; i++) {
        if (split[i].equals(".")) {
            split[i] = "";
        } else if (split[i].equals("..")) {
            split[i] = "";
            int k = i - 1;
            while (k >= 0 && split[k].equals("")) {
                k--;
            }
            if (k >= 0) split[k] = "";
        } else {
            continue;
        }
    }
~~~

7ms变为3ms

## 82.删除排序链表中的重复元素2

给定一个已排序的链表的头 `head` ， *删除原始链表中所有重复数字的节点，只留下不同的数字* 。返回 *已排序的链表* 。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg)

```
输入：head = [1,2,3,3,4,4,5]
输出：[1,2,5]
```

### 思路

遍历删除两个相等的点就行，一次一个删除

### 代码实现

~~~java
public ListNode deleteDuplicates(ListNode head) {
    if (head == null) {
        return head;
    }

    ListNode dummy = new ListNode(0, head);

    ListNode cur = dummy;
    while (cur.next != null && cur.next.next != null) {
        if (cur.next.val == cur.next.next.val) {
            int x = cur.next.val;
            while (cur.next != null && cur.next.val == x) {
                cur.next = cur.next.next;
            }
        } else {
            cur = cur.next;
        }
    }

    return dummy.next;
}
~~~

## 86.分隔链表

给你一个链表的头节点 `head` 和一个特定值 `x` ，请你对链表进行分隔，使得所有 **小于** `x` 的节点都出现在 **大于或等于** `x` 的节点之前。

你应当 **保留** 两个分区中每个节点的初始相对位置。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/04/partition.jpg)

```
输入：head = [1,4,3,2,5,2], x = 3
输出：[1,2,2,4,3,5]
```

**示例 2：**

```
输入：head = [2,1], x = 2
输出：[1,2]
```

### 思路

我们只需维护两个链表 small 和 large 即可，small 链表按顺序存储所有小于 x 的节点，large 链表按顺序存储所有大于等于 x 的节点。遍历完原链表后，我们只要将 small 链表尾节点指向 large 链表的头节点即能完成对链表的分隔。

==作者：力扣官方题解==

### 代码实现

~~~java
public ListNode partition(ListNode head, int x) {
    ListNode smalLHead = new ListNode();
    ListNode small = smalLHead;
    ListNode largeHead = new ListNode();
    ListNode large = largeHead;
    while (head != null) {
        if (head.val < x) {
            small.next = head;
            small = small.next;
        } else {
            large.next = head;
            large = large.next;
        }
        head = head.next;
    }
    large.next = null;
    small.next = largeHead.next;
    return smalLHead.next;
}
~~~

## 100.相同的树

给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg)

```
输入：p = [1,2,3], q = [1,2,3]
输出：true
```

### 思路

采用先序遍历递归求解，保证相同的结构和值

### 代码实现

~~~java
public boolean isSameTree(TreeNode p, TreeNode q) {
    return preOrder(p, q);
}

public boolean preOrder(TreeNode p, TreeNode q) {
    if (p == null && q == null) {
        return true;
    } else if (p != null && q != null) {
        if (p.val == q.val) {
            return preOrder(p.left, q.left) && preOrder(p.right, q.right);
        } else return false;
    } else {
        return false;
    }
}
~~~

