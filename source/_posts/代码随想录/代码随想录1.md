---
title: 代码随想录1
categories:
  - 代码随想录
tags:
  - coding
  - java
---
<meta name="referrer" content="no-referrer"/>

## 内容

**本节包含：**

- **数组**
- **链表**
- **哈希表**
- **字符串**
- **双指针**
- **栈和队列**
- **二叉树（部分）**

<!--more-->

## 二分查找

~~~java
// 避免当 target 小于nums[0] nums[nums.length - 1]时多次循环运算
if (target < nums[0] || target > nums[right]) {
    return -1;
}
~~~

## 移除元素

### 错误示例

~~~java
public static int removeElement(int[] nums, int val) {
        int displacement = 0;
        for (int i = 0; i+displacement < nums.length; i++) {
            nums[i] = nums[i + displacement];
            if (nums[i] == val) {
                ++displacement;
                if(i+displacement<nums.length){
                    //未考虑nums[i + displacement]=val
                    nums[i] = nums[i + displacement];
                }
                else break;

            }

        }
        for (int i = 0; i < nums.length; i++) {
            System.out.println(nums[i]);
        }
        return nums.length - displacement;
    }
}
~~~

### 使用while循环

~~~java
while(nums[i] == val) {
                ++displacement;
                if(i+displacement<nums.length){
                    nums[i] = nums[i + displacement];
                }
                else break;

            }
~~~

### 使用快慢指针

~~~java
public static int removeElementFastLowPoint(int[] nums, int val) {
        int slowIndex = 0;
        int fastIndex = 0;
        for (fastIndex = 0; fastIndex < nums.length; fastIndex++) {
            if (nums[fastIndex] != val) {
                nums[slowIndex] = nums[fastIndex];
                slowIndex++;
            }
        }
        return slowIndex;
    }
~~~

## 有序数组的平方

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

### 法一：中间向两边

找到平方值最小的数的index，向左右两边遍历比较

### 法二：两边向中间遍历

比较左右两边的平方值，res[]从最后开始填充

~~~java
public static int[] sortedSquaresTwo(int[] nums){
        int l = 0;
        int r= nums.length-1;
        int k  = nums.length-1;//新数组从最后开始填充
        int []res = new int[nums.length];
        while (l<=r){
            if((nums[l]*nums[l])<=nums[r]*nums[r]){
                res[k] = nums[r]*nums[r];
                k--;
                r--;
            }
            else {
                res[k] = nums[l]*nums[l];
                k--;
                l++;
            }
        }
        return res;
    }
~~~

## 长度最小的子数组

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其总和大于等于 `target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 

### 解题思路

滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。

窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。

窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）--->i++。

窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引---->j++。

~~~java
public static int minSubArrayLen(int target, int[] nums) {
        int i = 0;// 滑动窗口起始位置
        int res = Integer.MAX_VALUE;
        int sum = 0;// 滑动窗口数值之和
        int subStrLen;// 滑动窗口的长度
        for (int j = 0; j < nums.length; j++) {
            sum += nums[j];
            // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件
            while (sum >= target) {
                subStrLen = j - i + 1;
                res = subStrLen < res ? subStrLen : res;
                sum -= nums[i++];
            }
        }
        if (res == Integer.MAX_VALUE)
            res = 0;
        return res;
    }
~~~

## 螺旋矩阵

给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg)

```
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
```

### 解题思路

**循环不变量原则**

模拟顺时针画矩阵的过程:

- 填充上行从左到右
- 填充右列从上到下
- 填充下行从右到左
- 填充左列从下到上

由外向内一圈一圈这么画下去。

这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开右闭的原则，这样这一圈才能按照统一的规则画下来。

按照左闭右开的原则代码如下：

~~~java
public static int[][] generateMatrix(int n) {
        int start = 0;
        int value = 1;
        int loop = 0;//转的圈数
        int i, j;
        int[][] res = new int[n][n];
        while (loop++ < n / 2) {
            //上：从左向右填充
            for (j = start; j < n - loop; j++) {
                res[start][j] = value++;
            }
            //右：从上往下填充
            for (i = start; i < n - loop; i++) {
                res[i][j] = value++;
            }
            //下：从右往左填充
            for (; j > loop - 1; j--) {
                res[i][j] = value++;
            }
            for (; i > loop - 1; i--) {
                res[i][j] = value++;
            }
            start++;
        }
        if (n % 2 == 1)
            res[start][start] = value;
        return res;
    }
~~~

## 移除链表元素

给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。

~~~java
public ListNode removeElements(ListNode head, int val) {
//判断头节点是否是val，一定要先判断空，不然后报错
        while (head != null && head.val == val) {
            head = head.next;
        }
        ListNode p = head;
        while (p != null) {
            while (p.next != null && p.next.val == val) {
                p.next = p.next.next;
            }
            p = p.next;
        }
        return head;

    }
~~~

## 删除链表的倒数第N个节点

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

### 解题思路

两个指针，同时还要单独考虑头节点删除，其余情况下直接返回原头节点

~~~java
 public ListNode removeNthFromEnd(ListNode head, int n) {
        //删除的前指针和最终将会指向最后一个节点的指针
        ListNode pre = new ListNode(0);
        ListNode tail = head;
        pre.next = head;
        int count = n - 1;
        //pre和tail拉开间隔n
        while (tail!=null && count > 0) {
            tail = tail.next;
            count--;
        }
        //指针一直相对距离不变，tali变为尾节点
        while (tail.next != null){
            tail = tail.next;
            pre = pre.next;
        }
        //删除头节点
        if(pre.next==head)
        {
            head =head.next;
        }
        //删除del节点
        pre.next = pre.next.next;

        return head;
~~~

### 代码随想录解题思路

定义了一个虚拟头节点`dummyNode`，返回的头节点是`dummyNode.next`

## 环形链表II

题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

### 解题思路

假设从头结点到环形入口节点 的节点数为x。 环形入口节点到 fast指针与slow指针相遇节点 节点数为y。 从相遇节点 再到环形入口节点节点数为 z。 如图所示：

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20220925103433.png)

那么相遇时： slow指针走过的节点数为: `x + y`， fast指针走过的节点数：`x + y + n (y + z)`，n为fast指针在环内走了n圈才遇到slow指针， （y+z）为 一圈内节点的个数A。

因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 = slow指针走过的节点数 * 2：

```
(x + y) * 2 = x + y + n (y + z)
```

两边消掉一个（x+y）: `x + y = n (y + z)`

因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。

所以要求x ，将x单独放在左面：`x = n (y + z) - y` ,

再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：`x = (n - 1) (y + z) + z` 注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。

这个公式说明什么呢？

先拿n为1的情况来举例，意味着fast指针在环形里转了一圈之后，就遇到了 slow指针了。

当 n为1的时候，公式就化解为 `x = z`，

这就意味着，**从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点**。

也就是在相遇节点处，定义一个指针index1，在头结点处定一个指针index2。

让index1和index2同时移动，每次移动一个节点， 那么他们相遇的地方就是 环形入口的节点。

那么 n如果大于1是什么情况呢，就是fast指针在环形转n圈之后才遇到 slow指针。

其实这种情况和n为1的时候 效果是一样的，一样可以通过这个方法找到 环形的入口节点，只不过，index1 指针在环里 多转了(n-1)圈，然后再遇到index2，相遇点依然是环形的入口节点。

### 自己的方法

~~~java
public static ListNode detectCycle(ListNode head) {
        if (head == null || head.next == null || head.next.next == null)
            return null;
        ListNode fast = head.next.next;
        ListNode low = head.next;
        while (fast.next != null && fast.next.next != null && fast != low) {
            fast = fast.next.next;
            low = low.next;
        }
        if (fast.next == null || fast.next.next == null) {
            return null;
        }

        low = head;

        while (fast != low) {
            fast = fast.next;
            low = low.next;
        }

        return fast;
    }
~~~

判断太多，内存占用过多

### 法二

~~~java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) {// 有环
                ListNode index1 = fast;
                ListNode index2 = head;
                // 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口
                while (index1 != index2) {
                    index1 = index1.next;
                    index2 = index2.next;
                }
                return index1;
            }
        }
        return null;
    }
}
~~~

## 哈希表

### 定义

哈希表是根据关键码的值而直接进行访问的数据结构。

## 三种哈希结构

- 数组
- set （集合）
- map(映射)

> std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。

| 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(logn)  | O(logn)  |
| std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。



在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。

##  两个数组的交集

**而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。**

此时就要使用另一种结构体了，set 

~~~java
 public int[] intersection(int[] nums1, int[] nums2) {
        if (nums1 == null || nums1.length == 0 || nums2 == null || nums2.length == 0) {
            return new int[0];
        }
        Set<Integer> set1 = new HashSet<>();
        Set<Integer> res = new HashSet<>();

        for (int i : nums1) {
            set1.add(i);
        }

        for (int i : nums2) {
            if (set1.contains(i))
            {
                res.add(i);
            }
        }

       return res.stream().mapToInt(x -> x).toArray();
~~~

## 快乐数

编写一个算法来判断一个数 `n` 是不是快乐数。

**「快乐数」** 定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果这个过程 **结果为** 1，那么这个数就是快乐数。

如果 `n` 是 *快乐数* 就返回 `true` ；不是，则返回 `false` 。

### 解题思路

这道题目使用哈希法，来判断这个sum是否重复出现，如果重复了就是return false， 否则一直找到sum为1为止。

## 四数之和

给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。

### 解题思路

1. 首先定义 一个Map，key放a和b两数之和，value 放a和b两数之和出现的次数。
2. 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。
3. 定义int变量count，用来统计 a+b+c+d = 0 出现的次数。
4. 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。
5. 最后返回统计值 count 就可以了

~~~java
 public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        int res = 0;
        int sum;
        Map<Integer, Integer> map = new HashMap<>();
        for (int i : nums1) {
            for (int j : nums2) {
                sum = i + j;
                //如果map中存在sum这个键，则返回map中对应的键对应的值，如果不存在，则返回0
                map.put(sum,map.getOrDefault(sum,0)+1);
            }
        }
        for (int i : nums3) {
            for (int j : nums4) {
                sum =0- i - j;
                res = res+ map.getOrDefault(sum,0);
            }
        }
        return res;
    }
~~~

## 赎金信

给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。

如果可以，返回 `true` ；否则返回 `false` 。

`magazine` 中的每个字符只能在 `ransomNote` 中使用一次。

**提示：**

- `1 <= ransomNote.length, magazine.length <= 105`
- `ransomNote` 和 `magazine` 由小写英文字母组成

### 解题思路

因为题目说只有小写字母，那可以采用空间换取时间的哈希策略，用一个长度为26的数组来记录magazine里字母出现的次数。然后依次读取ransomNote的字母次数。

~~~java
public boolean canConstruct(String ransomNote, String magazine) {
        if (ransomNote.length() > magazine.length()) {
            return false;
        }
        int[] records = new int[26];
        for (int i = 0; i < magazine.length(); i++) {
            records[magazine.charAt(i) - 'a']++;
        }
        for (int i = 0; i < ransomNote.length(); i++) {
            records[ransomNote.charAt(i) - 'a']--;
        }
        for (int record : records) {
            if(record<0)
                return false;
        }
        return true;
    }
~~~

字符串转化为字符数组

~~~java
 for(char c : magazine.toCharArray()){
            record[c - 'a'] += 1;
        }
~~~

## 三数之和

首先将数组排序，然后有一层for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。

依然还是在数组中找到 abc 使得a + b +c =0，我们这里相当于 a = nums[i]，b = nums[left]，c = nums[right]。

- 如果nums[i] + nums[left] + nums[right] > 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。
- 如果 nums[i] + nums[left] + nums[right] < 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。

![15.三数之和](https://code-thinking.cdn.bcebos.com/gifs/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif)

### 难点一：a的去重

~~~java
//去除num[i]重复的三元组
if (i > 0 && nums[i] == nums[i - 1]) {
    continue;
}
~~~

错误示例如下：

~~~java
if (nums[i] == nums[i + 1]) { // 去重操作
    continue;
}
//三元组中出现重复元素的情况直接pass掉了，如{-1，-1，2}
~~~

### 难点二：bc去重

~~~java
while (left < right && nums[right] == nums[right-1]) right--;
while (left < right && nums[left] == nums[left+1]) left++;
right--;
left++;
~~~

### 总的代码

~~~java
public static List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        //排序
        Arrays.sort(nums);

        for (int i = 0; i < nums.length; i++) {
            if (nums[i] > 0) {
                return res;
            }
            //去除num[i]重复的三元组
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            //采用双指针，left=i+1，right从末尾开始排
            int left = i + 1;
            int right = nums.length - 1;
            int temp;
            while (left < right) {
                temp = nums[i] + nums[left] + nums[right];
                if (temp > 0) {
                    right--;
                } else if (temp < 0) {
                    left++;
                } else {
                    //将三元组加入res，并尝试找剩下的符合的三元组
                    res.add(Arrays.asList(nums[i], nums[left], nums[right]));
                    while (left < right && nums[right] == nums[right-1]) right--;
                    while (left < right && nums[left] == nums[left+1]) left++;
                    right--;
                    left++;
                }

            }
        }
        return res;


    }
~~~

## 字符反转

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。

不要给另外的数组分配额外的空间，你必须**[原地](https://baike.baidu.com/item/原地算法)修改输入数组**、使用 O(1) 的额外空间解决这一问题。

### 自己

~~~java
public void reverseString(char[] s) {
        int r = s.length - 1;
        char tmp;
        for (int i = 0; i < s.length / 2; i++) {
            tmp = s[i];
            s[i] = s[r - i];
            s[r - i] = tmp;
        }
    }
~~~

### 法二

~~~java
 while (l < r) {
            s[l] ^= s[r];  //构造 a ^ b 的结果，并放在 a 中
            s[r] ^= s[l];  //将 a ^ b 这一结果再 ^ b ，存入b中，此时 b = a, a = a ^ b
            s[l] ^= s[r];  //a ^ b 的结果再 ^ a ，存入 a 中，此时 b = a, a = b 完成交换
            l++;
            r--;
        }
~~~

## 翻转字符串里的单词

给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。

**单词** 是由非空格字符组成的字符串。`s` 中使用至少一个空格将字符串中的 **单词** 分隔开。

返回 **单词** 顺序颠倒且 **单词** 之间用单个空格连接的结果字符串。

**注意：**输入字符串 `s`中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

### 思路一

- 移除多余空格
- 将整个字符串反转
- 将每个单词反转

### 解法二：

创建新字符数组填充。时间复杂度O(n)

从后往前找到单词，需要两个指针，新的数组将单词从0开始装入

~~~java
public String reverseWords(String s) {
        char[] originArray = s.toCharArray();
        char[] newArray = new char[originArray.length + 1];
        int pos = 0;//newArray position
        //从orinArray最右边开始从左遍历，将单词一个一个读入到newArray
        int i = originArray.length - 1;
        int left, right;
        int j;
        while (i >= 0) {
            //去除右边空格
            while (i >= 0 && originArray[i] == ' ') i--;
            right = i;
            while (i >= 0 && originArray[i] != ' ') i--;
            left = i + 1;
            for (j = left; j <= right; j++) {
                newArray[pos++] = originArray[j];
                //很关键，这里每次都给一个但单词加一个空格，
                //若String最前面是空格，for循环条件left=0，right=-1
                if (j == right)
                    newArray[pos++] = ' ';
            }

        }
//        现在pos由于最后++是包含最后一个空格加1的位置处，pos-2+1=pos-1才是字符串的长度
        return new String(newArray, 0, pos-1);
    }
~~~

## 前缀表

KMP（Knuth-Morris-Pratt）算法是一种用于在**文本中查找子串**的字符串匹配算法。该算法的核心思想是利用已经匹配过的部分信息来避免不必要的字符比较，从而提高匹配效率。KMP算法的一个关键部分是构建和使用"前缀表"（prefix table）或称为"部分匹配表"（partial match table）。

前缀是指不包含最后一个字符的**所有**以第一个字符开头的连续子串；后缀是指不包含第一个字符的**所有**以最后一个字符结尾的连续子串

![KMP8](C:\data\mysoftware\Typora\typoraPicture\KMP8-1700019395365-3-1700019524869-5.png)

**初始化：j指向前缀末尾位置，i指向后缀末尾位置。**

~~~java
private void getNext(int[] next, String s) {
        int j = 0;
        next[0] = 0;
        for (int i = 1; i < s.length(); i++) {
            while (j > 0 && s.charAt(j) != s.charAt(i)) 
                j = next[j - 1];
            if (s.charAt(j) == s.charAt(i)) 
                j++;
            next[i] = j; 
        }
    }
~~~

~~~java
public int strStr(String haystack, String needle) {
        int[] next = new int[needle.length()];
        getNext(next, needle);
        int j = 0;//匹配的长度
        for (int i = 0; i < haystack.length(); i++) {
            while (j > 0 && haystack.charAt(i) != needle.charAt(j)) j = next[j - 1];
            if (haystack.charAt(i) == needle.charAt(j)) j++;
            if (j == needle.length()) return i - needle.length() + 1;
        }
        return -1;
    }
~~~

## 用栈实现队列

1. java中栈的初始化

~~~java
Stack<Integer>  stackOut = new Stack<>()；
~~~

2. `push，pop，peek，isEmpty`函数

3. 封装栈之间的转移函数

~~~java
 private void inToOut() {
        if (stackOut.empty()) {
            while (!stackIn.empty()) {
                stackOut.push(stackIn.pop());
            }
        }
    }
~~~

## 用队列实现栈

1. **队列是先进先出，两个队列之间直接转移数据，数据的排序不变**

2. 一个队列的方法是每次将队尾元素平移到队首
   ~~~java
    private void moveSize_1() {
           for (int i = 0; i < queue.size() - 1; i++) {
               queue.offer(queue.poll());
           }
       }
   ~~~

3. peek方法需要注意，调用`moveSize_1`后，留存第一个结果后需要再次移动一次复原队列

   ~~~java
   public int top() {
           moveSize_1();
           int top = queue.peek();
           queue.offer(queue.poll());
           return top;
       }
   ~~~

   4. 队列初始化

      ~~~java
      Queue<Integer> queue = new LinkedList<>();
      ~~~

      `offer(element)`: 该方法用于将指定的元素插入到队列的末尾（类似于`add`方法），如果队列已满则返回`false`，否则返回`true`。

      `add(element)`: 将元素添加到链表的末尾。

      `size()`: 获取链表中元素的数量。

      `clear()`: 清空链表中的所有元素。

      `toArray()`: 将链表转换为数组。

      `peek()`: 该方法返回队列的头部（第一个元素），但不移除该元素。如果队列为空，则返回`null`。

      `poll`是一个用于队列操作的方法，它用于检索并删除队列的头部（第一个元素）。如果队列为空，则`poll`方法返回`null`。

      使用迭代器（`Iterator`）进行遍历。

~~~java
Iterator<String> iterator = linkedList.iterator();
while (iterator.hasNext()) {
    String element = iterator.next();
    System.out.println(element);
}
~~~

## 有效的括号

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

### 思路

往栈中只压入压入左括号，匹配到右括号时必须与栈顶元素相同，否则`return false`，最后查看栈是否为空。

~~~java
public boolean isValid(String s) {
        stack = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            c = transParentheis(s.charAt(i));
            //左括号压入栈
            if (c != s.charAt(i))
                stack.push(c);
                //匹配到右括号，弹出栈
            else if (!stack.isEmpty() && stack.peek() == c)
                stack.pop();
            else return false;
        }
        return stack.isEmpty();
    }
public Character transParentheis(Character s) {
        return switch (s) {
            case '[' -> ']';
            case '{' -> '}';
            case '(' -> ')';
            default -> s;
        };
    }
~~~

## 1047.删除字符串中的所有相邻重复项

给出由小写字母组成的字符串 `S`，**重复项删除操作**会选择两个相邻且相同的字母，并删除它们。

在 S 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

## 思路

1. 用栈，判断栈顶和新加入的元素是否相同，但是多了一步将栈转化为字符串
2. 直接用字符串
3. 用双指针

~~~java
class Solution {
    public String removeDuplicates(String s) {
        char[] ch = s.toCharArray();
        int fast = 0;
        int slow = 0;
        while(fast < s.length()){
            // 直接用fast指针覆盖slow指针的值
            ch[slow] = ch[fast];
            // 遇到前后相同值的，就跳过，即slow指针后退一步，下次循环就可以直接被覆盖掉了
            if(slow > 0 && ch[slow] == ch[slow - 1]){
                slow--;
            }else{
                slow++;
            }
            fast++;
        }
        return new String(ch,0,slow);
    }
}
~~~

## 逆波兰表达式求值

逆波兰表达式：是一种后缀表达式，所谓后缀就是指运算符写在后面。

平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。

该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。

逆波兰表达式主要有以下两个优点：

- 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。
- 适合用栈操作运算：遇到数字则入栈；遇到运算符则取出栈顶两个数字进行计算，并将结果压入栈中。

**其实逆波兰表达式相当于是二叉树中的后序遍历**

### 思路

![150.逆波兰表达式求值](https://code-thinking.cdn.bcebos.com/gifs/150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.gif)

~~~java
public Deque<Integer> stack;

    public int evalRPN(String[] tokens) {
        stack = new LinkedList<>();
        for (String token : tokens) {
            stackOperation(token);
        }
        return stack.pop();
    }

    public void stackOperation(String c) {
        switch (c) {
            case "+" -> stack.push(stack.pop() + stack.pop());
            case "-" -> stack.push(-stack.pop() + stack.pop());
            case "*" -> stack.push(stack.pop() * stack.pop());
            case "/" -> {
                int num1 = stack.pop();
                int num2 = stack.pop();
                stack.push(num2 / num1);
            }
            default -> stack.push(Integer.valueOf(c));
        }
    }
~~~

## Deque详解

[参考博客](https://blog.csdn.net/devnn/article/details/82716447)

Deque有三种用途：

1. 普通队列(一端进另一端出:
   `Queue queue = new LinkedList()`或`Deque deque = new LinkedList()`
2. 双端队列(两端都可进出)
   `Deque deque = new LinkedList()`
3. 堆栈
   `Deque deque = new LinkedList()`

Deque接口扩展(继承)了 `Queue` 接口。在将双端队列用作队列时，将得到 FIFO（先进先出）行为。将元素添加到双端队列的末尾，从双端队列的开头移除元素。从 Queue 接口继承的方法完全等效于 Deque 方法，如下表所示：

| **Queue方法** | **等效Deque方法** |
| :-----------: | :---------------: |
|    add(e)     |    addLast(e)     |
|   offer(e)    |   offerLast(e)    |
|   remove()    |   removeFirst()   |
|    poll()     |    pollFirst()    |
|   element()   |    getFirst()     |
|    peek()     |    peekFirst()    |

双端队列也可用作 LIFO（后进先出）堆栈。应优先使用此接口而不是遗留 `Stack` 类。在将双端队列用作堆栈时，元素被推入双端队列的开头并从双端队列开头弹出。堆栈方法完全等效于 Deque 方法，如下表所示：

| **堆栈方法** | **等效Deque方法** |
| ------------ | ----------------- |
| push(e)      | addFirst(e)       |
| pop()        | removeFirst()     |
| peek()       | peekFirst()       |

## 239.滑动窗口最大值

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 *滑动窗口中的最大值* 。

### 思路

1. 我们需要一个队列，这个队列呢，放进去窗口里的元素，然后随着窗口的移动，队列也一进一出，每次移动之后，队列告诉我们里面的最大值是什么。
2. 队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素**数值是由大到小**的。

~~~java
//pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作
public void poll(int val) {
        if (!queue.isEmpty() && val == queue.getFirst())
            queue.pollFirst();
    }
//push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止
public void push(int val) {
        while (!queue.isEmpty() && queue.peekLast() < val) {
            queue.pollLast();
        }
        queue.addLast(val);
    }
~~~

## 前K个高频元素

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

### 思路

用小根堆求解前k个最大值

采用优先队列实现小根堆

~~~java
PriorityQueue<int[]> minHeap = new PriorityQueue<>(Comparator.comparingInt(pair -> pair[1]));
//or
PriorityQueue<int[]> minHeap = new PriorityQueue<>(Comparator.comparingInt((pair1,pair2)->pair1[1]-pair2[1]));
~~~

若想初始化大根堆，则

~~~java
PriorityQueue<int[]> minHeap = new PriorityQueue<>((pair1,pair2)->pair2[1]-pair1[1]);
~~~

`int[]`第一个值存`nums[i]`即key，第二个值存次数，即`value`

~~~java
for (Map.Entry<Integer, Integer> entry : map.entrySet())
~~~

迭代取map中的`<key,value>`

**PriorityQueue常用函数**

- `add(E e)` 或 `offer(E e)`：向队列中添加元素。
- `poll()`：检索并删除队列中的最小元素。
- `peek()`：检索但不删除队列中的最小元素。
- `remove(Object o)`：从队列中删除指定的元素。
- `size()`：返回队列中的元素个数。

## 二叉树理论

### 满二叉树

<img src="https://gitee.com/hollis7/pictures/raw/master/2023/12/18/99820_20200806185805576.png" alt="20200806185805576" style="zoom:50%;" />

这棵二叉树为满二叉树，也可以说深度为k，有2^k-1个节点的二叉树。

### 完全二叉树

<img src="https://gitee.com/hollis7/pictures/raw/master/2023/12/18/19370_20200920221638903.png" alt="20200920221638903" style="zoom:50%;" />

### 平衡二叉搜索树

平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

![20200806190511967](https://gitee.com/hollis7/pictures/raw/master/2023/12/21/45815_20200806190511967.png)

### 二叉树的存储方式

**二叉树可以链式存储，也可以顺序存储。**

那么链式存储方式就用指针， 顺序存储的方式就是用数组。

用数组来存储二叉树如何遍历的呢？

**如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。**

<img src="https://gitee.com/hollis7/pictures/raw/master/2023/12/21/13082_20200920200429452.png" alt="20200920200429452" style="zoom:50%;" />

## 前序遍历（递归）

节点为空，返回

~~~java
public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        preorder(root, res);
        return res;
    }

    public void preorder(TreeNode treeNode, List<Integer> res) {
        if (treeNode == null) return;
        res.add(treeNode.val);
        preorder(treeNode.left, res);
        preorder(treeNode.right, res);
    }
~~~

## 二叉树的统一迭代法

~~~java
    /**
     * 前序遍历（迭代法），栈进入顺序：右左前null
     *
     * @param root
     * @return res
     */
public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new LinkedList<>();
        Stack<TreeNode> st = new Stack<>();
        if (root != null) st.push(root);
        while (!st.empty()) {
            TreeNode node = st.peek();
            if (node != null) {
                st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
                if (node.right!=null) st.push(node.right);  // 添加右节点（空节点不入栈）
                if (node.left!=null) st.push(node.left);    // 添加左节点（空节点不入栈）
                st.push(node);                          // 添加中节点
                st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。
                
            } else { // 只有遇到空节点的时候，才将下一个节点放进结果集
                st.pop();           // 将空节点弹出
                node = st.peek();    // 重新取出栈中元素
                st.pop();
                result.add(node.val); // 加入到结果集
            }
        }
        return result;
    }
~~~

## 层序遍历

### BFS-迭代方式

~~~java
public void checkFun02(TreeNode node) {
    if (node == null) return;  // 如果节点为空，则直接返回
    Queue<TreeNode> queue = new LinkedList<>();  // 创建一个队列，用于层序遍历树
    queue.offer(node);  // 将根节点加入队列
    while (!queue.isEmpty()) {  // 队列不为空时循环
        List<Integer> levelList = new ArrayList<>();  // 创建一个列表，用于存储当前层的节点值
        int len = queue.size();  // 获取当前层的节点数量
        while (len > 0) {  // 当前层的节点遍历
            TreeNode tmpNode = queue.poll();  // 从队列中取出一个节点
            levelList.add(tmpNode.val);  // 将节点的值添加到当前层的列表中
            if (tmpNode.left != null) queue.offer(tmpNode.left);  // 如果有左子节点，则将左子节点加入队列
            if (tmpNode.right != null) queue.offer(tmpNode.right);  // 如果有右子节点，则将右子节点加入队列
            len--;  // 节点数量减一
        }
        res.add(levelList);  // 将当前层的节点值列表添加到结果中
    }
}
~~~

### DFS-递归方式

~~~java
 public void checkFunc01(TreeNode node, Integer deep) {
        if (node == null) return;
        deep++;
        if (res.size() < deep) {//为二叉树每一层分配空间存储
            List<Integer> levelList = new ArrayList<>();
            res.add(levelList);
        }
        //对应层存储元素
        res.get(deep - 1).add(node.val);

        checkFunc01(node.left, deep);
        checkFunc01(node.right, deep);
    }
~~~

## 层序遍历2

给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

### 法1

~~~python
//法一，用Collections.reverse方法反转
Collections.reverse(res);
~~~

### 法2

在`BFS-迭代方式`的函数基础上，将res的每层数据插入的顺序变为头插入

~~~java
public void checkFun02Dual(TreeNode node) {
        if (node == null) return;  // 如果节点为空，则直接返回
        Queue<TreeNode> queue = new LinkedList<>();  // 创建一个队列，用于层序遍历树
        queue.offer(node);  // 将根节点加入队列
        while (!queue.isEmpty()) {  // 队列不为空时循环
            List<Integer> levelList = new ArrayList<>();  // 创建一个列表，用于存储当前层的节点值
            int len = queue.size();  // 获取当前层的节点数量
            while (len > 0) {  // 当前层的节点遍历
                TreeNode tmpNode = queue.poll();  // 从队列中取出一个节点
                levelList.add(tmpNode.val);  // 将节点的值添加到当前层的列表中
                if (tmpNode.left != null) queue.offer(tmpNode.left);  // 如果有左子节点，则将左子节点加入队列
                if (tmpNode.right != null) queue.offer(tmpNode.right);  // 如果有右子节点，则将右子节点加入队列
                len--;  // 节点数量减一
            }
            //每层倒叙插入
            res.add(0, levelList);  // 将当前层的节点值列表添加到结果中
        }
    }
~~~

## N叉树的层序遍历

### 法一

采用递归方法

~~~java
public class levelOrderN {
    public List<List<Integer>> resList = new ArrayList<List<Integer>>();

    public List<List<Integer>> levelOrder(Node root) {
        recursiveNTree(root, 0);
        return resList;
    }

    public void recursiveNTree(Node node, Integer deep) {
        if (node == null) {
            return;
        }
        deep++;
        if (resList.size() < deep) {
            List<Integer> curLevel = new ArrayList<>();
            resList.add(curLevel);
        }
        //加入当前的节点
        resList.get(deep - 1).add(node.val);

        //遍历子节点
        for (Node child : node.children) {
            recursiveNTree(child, deep);
        }
    }
}

~~~

## 104. 二叉树的最大深度

推荐方法，递归法

~~~java
 public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
~~~

左子树和右子树的最大深度 *l* 和 *r*，那么该二叉树的最大深度即为
$$
m a x ( l , r ) + 1
$$
