---
title: 代码随想录-二叉树3
categories:
- code_Musing
tags:
- binaryTree
- traversal 
---
<meta name="referrer" content="no-referrer"/>

# 内容

**本节包括：**

- 二叉树（部分）

<!--more-->

## 108.将有序数组转换为二叉搜索树

给你一个整数数组 `nums` ，其中元素已经按 升序 排列，请你将其转换为一棵平衡二叉搜索树。

### 思路

**本质就是寻找分割点，分割点作为当前节点，然后递归左区间和右区间**。

分割点就是数组中间位置的节点。

采用[left,right]左闭右闭

### 越界注意

首先取数组中间元素的位置，不难写出`int mid = (left + right) / 2;`，这么写其实有一个问题，就是数值越界，例如left和right都是最大int，这么操作就越界了，

所以可以这么写：`int mid = left + ((right - left) / 2);`

### 代码实现

~~~java
public class SortedArrayToBST {
    public TreeNode sortedArrayToBST(int[] nums) {
        return buildBST(nums, 0, nums.length - 1);

    }

    public TreeNode buildBST(int[] nums, int left, int right) {
        if (right < left) return null;
        int mid = left + (right - left) / 2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = buildBST(nums, left, mid - 1);
        root.right = buildBST(nums, mid + 1, right);
        return root;
    }
}
~~~

## 538.把二叉搜索树转换为累加树

给出二叉搜索树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201023160751832.png" alt="538.把二叉搜索树转换为累加树" style="zoom:50%;" />

### 思路

采用中序遍历思想，不过是右中左的方式，累加结果，赋予当前**中节点**

### 代码实现

~~~java
public class ConvertBSTtoGST {
    int sum;

    public TreeNode convertBST(TreeNode root) {
        sum = 0;
        convertInOrder(root);
        return root;
    }

    // 按右中左顺序遍历，累加即可
    public void convertInOrder(TreeNode root) {
        if (root == null) return;
        convertInOrder(root.right);
        sum += root.val;
        root.val = sum;
        convertInOrder(root.left);
    }
}
~~~

