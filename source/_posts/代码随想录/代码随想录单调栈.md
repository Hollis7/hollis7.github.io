---
title: 代码随想录-单调栈
categories:
- code_Musing
tags: 
- monotonic_stack
---
<meta name="referrer" content="no-referrer"/>

## 内容

**本节包括：**

- 单调栈

<!--more-->

## 概念

**通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了**。时间复杂度为O(n)。

**单调栈的本质是空间换时间**，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是整个数组只需要遍历一次。

## 739. 每日温度

给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

### 思路

- 情况一：当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况
- 情况二：当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况
- 情况三：当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况

### 代码实现

~~~java
 public int[] dailyTemperatures(int[] temperatures) {
    int days = temperatures.length;//天气天数
    int[] ans = new int[days];
    Deque<Integer> stack = new LinkedList<>();//单调栈
    stack.push(0);
    for (int i = 1; i < days; i++) {
        //当前遍历的元素T[i]小于等于栈顶元素T[st.top()]的情况
        if (temperatures[i] <= temperatures[stack.peek()]) {
            stack.push(i);
        } else {
            while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {
                ans[stack.peek()] = i - stack.peek();
                stack.remove();
            }
            stack.push(i);
        }
    }
    return ans;
}
~~~

## 496.下一个更大元素 I

`nums1` 中数字 `x` 的 **下一个更大元素** 是指 `x` 在 `nums2` 中对应位置 **右侧** 的 **第一个** 比 `x` 大的元素。

给你两个 **没有重复元素** 的数组 `nums1` 和 `nums2` ，下标从 **0** 开始计数，其中`nums1` 是 `nums2` 的子集。

对于每个 `0 <= i < nums1.length` ，找出满足 `nums1[i] == nums2[j]` 的下标 `j` ，并且在 `nums2` 确定 `nums2[j]` 的 **下一个更大元素** 。如果不存在下一个更大元素，那么本次查询的答案是 `-1` 。

返回一个长度为 `nums1.length` 的数组 `ans` 作为答案，满足 `ans[i]` 是如上所述的 **下一个更大元素** 。

### 思路

**注意题目中说是两个没有重复元素 的数组 nums1 和 nums2**。

没有重复元素，我们就可以用map来做映射了。根据数值快速找到下标，还可以判断nums2[i]是否在nums1中出现过。

~~~java
for (int i = 0; i < nums1.length; i++) {
    map.put(nums1[i], i);
}
~~~

### 代码实现

~~~java
public int[] nextGreaterElement(int[] nums1, int[] nums2) {
    int[] res = new int[nums1.length];
    Map<Integer, Integer> map = new HashMap<>();
    Deque<Integer> stack = new LinkedList<>();//单调栈
    for (int i = 0; i < nums1.length; i++) {
        map.put(nums1[i], i);
    }
    Arrays.fill(res, -1);
    stack.push(0);
    for (int i = 1; i < nums2.length; i++) {
        if (nums2[i] < nums2[stack.peek()]) {
            stack.push(i);
        } else {
            while (!stack.isEmpty() && nums2[i] > nums2[stack.peek()]) {
                if (map.containsKey(nums2[stack.peek()])) {
                    res[map.get(nums2[stack.peek()])] = nums2[i];
                }
                stack.remove();
            }
            stack.push(i);
        }
    }
    return res;
}
~~~

##  503.下一个更大元素II

给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。

### 思路

“拼接”一个数组到后面模拟循环数组，用取模`%`模拟，而不是扩充`nums`

### 代码实现

~~~java
 public int[] nextGreaterElements(int[] nums) {
    Deque<Integer> stack = new LinkedList<>();
    int size = nums.length;
    int[] res = new int[size];
    Arrays.fill(res, -1);
    stack.push(0);
    for (int i = 1; i < size * 2; i++) {
        if (nums[i % size] <= nums[stack.peek() % size]) {
            stack.push(i);
        } else {
            while (!stack.isEmpty() && nums[i % size] > nums[stack.peek() % size]) {
                res[stack.peek() % size] = nums[i % size];
                stack.pop();
            }
            stack.push(i);
        }
    }
    return res;
}
~~~

## 42. 接雨水

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

<img src="https://code-thinking-1253855093.cos.ap-guangzhou.myqcloud.com/pics/20210713205038.png" alt="img" style="zoom:150%;" />

- 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
- 输出：6
- 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。

### 思路

#### 暴力双指针法

每一列雨水的高度，取决于，该列**左侧最高的柱子**和**右侧最高的柱子**中最矮的那个柱子的高度。

并且**要注意第一个柱子和最后一个柱子不接雨水**

####  双指针优化

我们把每一个位置的左边最高高度记录在一个数组上（maxLeft），右边最高高度记录在一个数组上（maxRight），这样就避免了重复计算。

#### 单调栈解法

- 如果当前遍历的元素（柱子）高度小于栈顶元素的高度，就把这个元素加入栈中，因为栈里本来就要保持从小到大的顺序（从栈头到栈底）。

- 如果当前遍历的元素（柱子）高度等于栈顶元素的高度，要跟更新栈顶元素，因为遇到相相同高度的柱子，需要使用最右边的柱子来计算宽度。

- 如果当前遍历的元素（柱子）高度大于栈顶元素的高度，此时就出现凹槽了；

  > 取栈顶元素，将栈顶元素弹出，这个就是凹槽的底部，也就是中间位置，下标记为mid，对应的高度为height[mid]
  >
  > 此时大家应该可以发现其实就是**栈顶和栈顶的下一个元素以及要入栈的元素，三个元素来接水！**
  >
  > 那么雨水高度是 min(凹槽左边高度, 凹槽右边高度) - 凹槽底部高度，代码为：`int h = min(height[st.top()], height[i]) - height[mid];`
  >
  > 雨水的宽度是 凹槽右边的下标 - 凹槽左边的下标 - 1（因为只求中间宽度），代码为：`int w = i - st.top() - 1 ;`

  此时的栈顶元素st.top()，就是凹槽的左边位置，下标为st.top()，对应的高度为height[st.top()]（就是图中的高度2）。

  <img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210223092629946.png" alt="42.接雨水2" style="zoom:50%;" />

### 代码实现

#### 双指针优化

~~~java
public int twoPointTrap(int[] height) {
    int size = height.length;
    int[] maxLeft = new int[size];//左边最高高度
    int[] maxRight = new int[size];//右边最高高度
    //初始化
    maxLeft[0] = height[0];
    maxRight[size - 1] = height[size - 1];
    for (int l = 1; l < size; l++) {
        maxLeft[l] = Math.max(height[l - 1], maxLeft[l - 1]);
    }
    for (int r = size - 2; r >= 0; r--) {
        maxRight[r] = Math.max(height[r + 1], maxRight[r + 1]);
    }

    int sum = 0;
    int col = 0;
    for (int i = 1; i <= size - 2; i++) {
        col = Math.min(maxLeft[i], maxRight[i]) - height[i];
        if (col > 0) sum += col;
    }
    return sum;
}
~~~

#### 单调栈

~~~java
public int monotonicStackTrap(int[] height) {
    int size = height.length;
    Deque<Integer> stack = new LinkedList<>();
    stack.push(0);
    int water = 0;
    for (int i = 1; i < size; i++) {
        if (height[i] < height[stack.peek()]) {
            stack.push(i);
        } else if (height[i] == height[stack.peek()]) {
            stack.pop();
            stack.push(i);
        } else {
            while (!stack.isEmpty() && height[i] > height[stack.peek()]) {
                int mid = height[stack.pop()];
                if (!stack.isEmpty()) {
                    int tmpHeight = Math.min(height[i], height[stack.peek()]) - mid;
                    int width = i - stack.peek() - 1;
                    water += width * tmpHeight;
                }
            }
            stack.push(i);
        }
    }
    return water;
}
~~~

## 84.柱状图中最大的矩形

给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

### 思路

只有栈里从大到小的顺序，才能保证栈顶元素找到左右两边第一个小于栈顶元素的柱子。

所以本题单调栈的顺序正好与接雨水反过来。

大家应该可以发现其实就是**栈顶和栈顶的下一个元素以及要入栈的三个元素组成了我们要求最大面积的高度和宽度**

主要就是分析清楚如下三种情况：

- 情况一：当前遍历的元素heights[i]大于栈顶元素heights[st.top()]的情况
- 情况二：当前遍历的元素heights[i]等于栈顶元素heights[st.top()]的情况
- 情况三：当前遍历的元素heights[i]小于栈顶元素heights[st.top()]的情况

### 代码实现

~~~java
public int largestRectangleArea(int[] heights) {
    Deque<Integer> stack = new LinkedList<>();//单调栈，下一个比当前高度小的柱子位置
    int[] extendHeights = new int[heights.length + 2];//左右两边扩充0
    System.arraycopy(heights, 0, extendHeights, 1, heights.length);
    heights = extendHeights;
    stack.push(0);
    int h = 0, w = 0, area = 0;
    for (int i = 1; i < heights.length; i++) {
        if (heights[i] > heights[stack.peek()]) {
            stack.push(i);
        } else if (heights[stack.peek()] == heights[i]) {
            stack.pop();
            stack.push(i);
        } else {
            while (!stack.isEmpty() && heights[i] < heights[stack.peek()]) {
                h = heights[stack.pop()];//这里弹出了
                w = i - stack.peek() - 1;
                area = Math.max(area, w * h);
            }
            stack.push(i);
        }
    }
    return area;
}
~~~

