---
title: 代码随想录-回溯算法
categories:
- code_Musing
tags:
- backtracking
---
<meta name="referrer" content="no-referrer"/>

# 内容

**本节包括：**

- 回溯概念
- 组合
- 分割回文
- 排列
- N皇后

<!--more-->

**回溯法也可以叫做回溯搜索法，它是一种搜索的方式。**

回溯是递归的副产品，只要有递归就会有回溯。

**因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案**，如果想让回溯法高效一些，可以加一些**剪枝**的操作，但也改不了回溯法就是穷举的本质。

## 回溯法解决的问题

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等

## 回溯法模板

回溯算法中函数返回值一般为void。

- 回溯函数伪代码如下：

```java
void backtracking(参数)
```

- 回溯函数终止条件

~~~java
if (终止条件) {
    存放结果;
    return;
}
~~~

- 回溯搜索的遍历过程

在上面我们提到了，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210130173631174.png" alt="回溯算法理论基础" style="zoom:45%;" />

可以从图中看出**for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历**，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。

分析完过程，回溯算法模板框架如下：

~~~java
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
~~~

## 77.组合

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

### 思路

那么我把组合问题抽象为如下树形结构：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195223940.png" alt="77.组合" style="zoom:50%;" />

函数里一定有两个参数，既然是集合n里面取k个数，那么n和k是两个int型的参数。

然后还需要一个参数，为int型变量`startIndex`，这个参数用来记录本层递归的中，集合从哪里开始遍历（集合就是[1,...,n] ）。

for循环每次从`startIndex`开始遍历，然后用path保存取到的节点i。

~~~java
for (int i = startIndex; i <= n; i++) { // 控制树的横向遍历
    path.push_back(i); // 处理节点
    backtracking(n, k, i + 1); // 递归：控制树的纵向遍历，注意下一层搜索要从i+1开始
    path.pop_back(); // 回溯，撤销处理的节点
}
~~~

###  剪枝优化

1. 已经选择的元素个数：path.size();
2. 还需要的元素个数为: k - path.size();
3. 在集合n中至多要从该起始位置 : `n - (k - path.size()) + 1`，开始遍历

~~~java
public class CombineK {
    public LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> res = new ArrayList<>();

    public List<List<Integer>> combine(int n, int k) {
        backtracking(n, k, 1);
        return res;
    }

    public void backtracking(int n, int k, int startIdx) {
        if (path.size() == k) {
            res.add(new ArrayList<>(path));
            return;
        }
        for (int i = startIdx; i <= n - (k - path.size()) + 1; i++) {
            path.add(i);
            backtracking(n, k, i + 1);
            path.removeLast();
        }
    }
}

~~~

## 216.组合总和3

找出所有相加之和为 `n` 的 `k` 个数的组合，且满足下列条件：

- 只使用数字1到9
- 每个数字 **最多使用一次** 

返回所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。

### 思路

1. k其实就已经限制树的深度
2. 所以如果path.size() 和 k相等了，就终止。如果此时path里收集到的元素和（sum） 和targetSum（就是题目描述的n）相同了，就用result收集当前的结果。
3. 已选元素总和如果已经大于n（图中数值为4）了，那么往后遍历就没有意义了，直接剪掉。
4. for循环的范围也可以剪枝，i <= 9 - (k - path.size()) + 1就可以了。

### 代码实现

~~~java
public class CombinationSum3 {
    LinkedList<Integer> path = new LinkedList<>();
    List<List<Integer>> res = new ArrayList<>();

    public List<List<Integer>> combinationSum3(int k, int n) {
        backtracking(n, k, 0, 1);
        return res;
    }

    public void backtracking(int target, int k, int sum, int startIdx) {
        if (path.size() == k) {
            if (target == sum) {
                res.add(new ArrayList<>(path));
            }
            return;
        }
        for (int i = startIdx; i <= 9 - (k - path.size()) + 1; i++) {
            sum += i;
            path.add(i);
            //不符合，直接剪枝
            if (sum > target) {
                sum -= i;
                path.removeLast();
                return;
            }
            backtracking(target, k, sum, i + 1);
            sum -= i;
            path.removeLast();
        }
    }
}
~~~

## 17.电话号码的字母组合

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png)

**示例 1：**

```
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

### 思路

1. 数字和字母如何映射：可以使用map或者定义一个二维数组

~~~java
 String[] numMaps = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
~~~

2. 终止条件：如果num 等于字符串长度digits.length()
3. **字符类型的数字转化为int类型的数字可以通过`c-'0'`实现**

3. 遍历当前数字映射的所有字符，并回溯

### 代码实现

~~~java
public class LetterCombinations {
    public List<String> res = new ArrayList<>();
    StringBuilder temp = new StringBuilder();

    public List<String> letterCombinations(String digits) {
        String[] numMaps = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
        if (digits.isEmpty()) {
            return res;
        }
        backTracking(digits, numMaps, 0);
        return res;


    }

    public void backTracking(String digits, String[] numMaps, int num) {
        if (num == digits.length()) {
            res.add(temp.toString());
            return;
        }
        //当前数字代表的字母组合
        String str = numMaps[digits.charAt(num) - '0'];
        for (int i = 0; i < str.length(); i++) {
            temp.append(str.charAt(i));
            backTracking(digits, numMaps, num + 1);
            temp.deleteCharAt(temp.length() - 1);
        }
    }
}
~~~

## 39. 组合总和

给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

说明：

- 所有数字（包括 target）都是正整数。
- 解集不能包含重复的组合。

示例 1：

- 输入：candidates = [2,3,6,7], target = 7,
- 所求解集为： [ [7], [2,2,3] ]

### 思路

target>sum和target==sum截止

采用回溯法

如果至少一个数字的被选数量不同，则两种组合是不同的，需要按照一定顺序向下遍历，因此需要从i开始作为start

~~~java
 bachtracking(candidates, target, sum, i);
~~~

### 代码实现

~~~java
public class CombinationSum {
    LinkedList<Integer> path = new LinkedList<>();
    List<List<Integer>> res = new ArrayList<>();

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        backtracking(candidates, target, 0, 0);
        return res;
    }

    public void backtracking(int[] candidates, int target, int sum, int startIdx) {
        if (target == sum) {
            res.add(new ArrayList<>(path));
            return;
        } else if (target < sum) {
            return;
        } else {
            for (int i = startIdx; i < candidates.length; i++) {
                sum += candidates[i];
                path.add(candidates[i]);
                backtracking(candidates, target, sum, i);
                sum -= candidates[i];
                path.removeLast();
            }
        }
    }
}
~~~

## 40.组合总和II

给定一个候选人编号的集合 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。

`candidates` 中的每个数字在每个组合中只能使用 **一次** 。

**注意：**解集不能包含重复的组合。 

**示例 1:**

```
输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
```

### 思路

所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000918.png" alt="40.组合总和II" style="zoom: 40%;" />

### 代码实现1

不使用used数组

~~~java
LinkedList<Integer> path;
List<List<Integer>> res;

public List<List<Integer>> combinationSum2(int[] candidates, int target) {
    path = new LinkedList<>();
    res = new ArrayList<>();
    Arrays.sort(candidates);
    backtracking(candidates, target, 0, 0);
    return res;

}

public void backtracking(int[] candidates, int target, int sum, int startIdx) {
    if (target == sum) {
        res.add(new ArrayList<>(path));
        return;
    }
    for (int i = startIdx; i < candidates.length && target >= sum + candidates[i]; i++) {
        //同一层不能选重复数字，同一分支可以选择重复数字
        if (i > startIdx && candidates[i] == candidates[i - 1]) {
            continue;
        }
        sum += candidates[i];
        path.add(candidates[i]);
        backtracking(candidates, target, sum, i + 1);
        sum -= candidates[i];
        path.removeLast();
    }

}
~~~

### 代码实现2

使用used数组

- used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
- used[i - 1] == false，说明同一树层candidates[i - 1]使用过

~~~java
LinkedList<Integer> path;
List<List<Integer>> res;
boolean[] used;

public List<List<Integer>> combinationSum2(int[] candidates, int target) {
    path = new LinkedList<>();
    res = new ArrayList<>();
    used = new boolean[candidates.length];
    Arrays.fill(used, false);
    Arrays.sort(candidates);
    backtracking(candidates, target, 0, 0);
    return res;

}

public void backtracking(int[] candidates, int target, int sum, int startIdx) {
    if (target == sum) {
        res.add(new ArrayList<>(path));
        return;
    }
    for (int i = startIdx; i < candidates.length; i++) {
        if (sum + candidates[i] > target) break;
        //同一层不能选重复数字，同一分支可以选择重复数字
        if (i > 0 && candidates[i] == candidates[i - 1] && !used[i - 1]) {
            continue;
        }
        used[i] = true;
        sum += candidates[i];
        path.add(candidates[i]);
        backtracking(candidates, target, sum, i + 1);
        used[i] = false;
        sum -= candidates[i];
        path.removeLast();
    }

}
~~~

## 131.分割回文串

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串**。返回 `s` 所有可能的分割方案。

### 思路

**判断回文**

可以使用双指针法，一个指针从前向后，一个指针从后向前，如果前后指针所指向的元素是相等的，就是回文字符串了。

**切割方法**

- 首先判断当前子串是不是回文，如果是回文，就加入在`Deque<String> queue`中，`queue`用来记录切割过的回文子串。
- 下次再`startIdx =i+1`处开始继续递归
- 结果最后回溯`queue.removeLast();`

### 代码实现

~~~java
public List<List<String>> res = new ArrayList<>();
Deque<String> queue = new LinkedList<>();

public List<List<String>> partition(String s) {
    backtracking(s, 0);
    return res;
}

public void backtracking(String s, int startIdx) {
    //如果起始位置大于s的大小，说明找到了一组分割方案
    if (startIdx >= s.length()) {
        res.add(new ArrayList<>(queue));
        return;
    }
    for (int i = startIdx; i < s.length(); i++) {
        //如果是回文子串，则记录
        if (isPalindrome(s, startIdx, i)) {
            String str = s.substring(startIdx, i + 1);
            queue.add(str);
        } else {
            continue;
        }
        //起始位置后移，保证不重复
        backtracking(s, i + 1);
        queue.removeLast();
    }
}

//判断是否是回文
public boolean isPalindrome(String s, int start, int end) {
    for (int i = start, j = end; i < j; i++, j--) {
        if (s.charAt(i) != s.charAt(j)) {
            return false;
        }
    }
    return true;
}
~~~

## 93.复原IP地址

给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。

有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 有效的 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效的 IP 地址。

### 思路

判断当前子字符串是否符合ip地址格式：0~255，没有特殊字符

回溯：

当dotCount=3时，递归结束，判断当前ip地址是否符合条件，是否加入res

对字符串的操作，加入 `.`删除 `.`分别用通过insert和deleteCharAt实现，i+1是偏移，表示在i+1处插入删除（从0开始）

~~~java
 for (int i = start; i < sb.length(); i++) {
            if (isValid(sb, start, i)) {
                sb.insert(i + 1, '.');
                backtracking(sb, i + 2, dotCount + 1);
                sb.deleteCharAt(i + 1);
            } else {
                //当前的字符串已经不满足<255等条件
                break;
            }
        }
~~~

### 代码实现

~~~java
public class RestoreIpAddresses {
    List<String> res = new ArrayList<>();

    public List<String> restoreIpAddresses(String s) {
        StringBuilder sb = new StringBuilder(s);
        backtracking(sb, 0, 0);
        return res;
    }

    public void backtracking(StringBuilder sb, int start, int dotCount) {
        if (dotCount == 3) {
            if (isValid(sb, start, sb.length() - 1)) {
                res.add(sb.toString());
            }
            return;
        }
        for (int i = start; i < sb.length(); i++) {
            if (isValid(sb, start, i)) {
                sb.insert(i + 1, '.');
                backtracking(sb, i + 2, dotCount + 1);
                sb.deleteCharAt(i + 1);
            } else {
                //当前的字符串已经不满足<255等条件
                break;
            }
        }
    }

    public boolean isValid(StringBuilder s, int start, int end) {
        if (start > end) return false;
        if (s.charAt(start) == '0' && start != end) return false;
        int num = 0;
        for (int i = start; i <= end; i++) {
            int digit = s.charAt(i) - '0';
            if (digit < 0 || digit > 9)
                return false;
            num = num * 10 + digit;
            if (num > 255) {
                return false;
            }
        }
        return true;
    }
}
~~~

##  78.子集

给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

示例: 输入: nums = [1,2,3] 输出: [ [3],  [1],  [2],  [1,2,3],  [1,3],  [2,3],  [1,2],  [] ]

### 思路

如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，**那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！**

<img src="https://code-thinking.cdn.bcebos.com/pics/78.%E5%AD%90%E9%9B%86.png" alt="78.子集" style="zoom: 40%;" />

### 代码实现

~~~java
public class Subsets {
    public LinkedList<Integer> subset = new LinkedList<>();
    public List<List<Integer>> res = new ArrayList<>();

    public List<List<Integer>> subsets(int[] nums) {
        backtracking(nums, 0);
        return res;
    }

    public void backtracking(int[] nums, int start) {
        res.add(new ArrayList<>(subset));
        for (int i = start; i < nums.length; i++) {
            subset.add(nums[i]);
            backtracking(nums, i + 1);
            subset.removeLast();
        }
    }
}

~~~

## 90.子集II

给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

示例:

- 输入: [1,2,2]
- 输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ]

### 思路

同层不能取同一个数字其他和`78.子集`一样的思路

先要排序`Arrays.sort(nums);`，第二个重复的同层不能取

一定要记得，存储res时，要`res.add(new ArrayList<>(subset));`

### 代码实习

~~~java
public class SubsetsWithDup {
    LinkedList<Integer> subset = new LinkedList<>();
    List<List<Integer>> res = new ArrayList<>();

    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        backtracking(nums, 0);
        return res;
    }

    public void backtracking(int[] nums, int start) {
        res.add(new ArrayList<>(subset));
        for (int i = start; i < nums.length; i++) {
            if (i > start && nums[i] == nums[i - 1]) {
                continue;
            }
            subset.add(nums[i]);
            backtracking(nums, i + 1);
            subset.removeLast();
        }
    }
}
~~~

## 491.递增子序列

给你一个整数数组 `nums` ，找出并返回所有该数组中不同的递增子序列，递增子序列中 **至少有两个元素** 。你可以按 **任意顺序** 返回答案。

数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。

### 思路-回溯法

定义一个used数组或者set、hashmap，用户保存每一层使用过的元素，不能**直接排序**

考虑到`-100 <= nums[i] <= 100`，于是采用数组实现used

### 代码实现

~~~java
public class FindSubsequences {
    LinkedList<Integer> path = new LinkedList<>();
    List<List<Integer>> res = new ArrayList<>();

    public List<List<Integer>> findSubsequences(int[] nums) {
        backtracking(nums, 0);
        return res;
    }

    public void backtracking(int[] nums, int start) {
        if (path.size() > 1) {
            res.add(new ArrayList<>(path));
        }
        int[] used = new int[201];
        for (int i = start; i < nums.length; i++) {
            if (used[nums[i] + 100] == 1) {
                continue;
            }
            if (path.isEmpty() || nums[i] >= path.getLast()) {
                used[nums[i] + 100] = 1;
                path.add(nums[i]);
                backtracking(nums, i + 1);
                path.removeLast();
            }
        }
    }
}
~~~

## 46.全排列

给定一个 没有重复数字的序列，返回其所有可能的全排列。

示例:

- 输入: [1,2,3]
- 输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]

### 思路

采用used数组记录已经挑选过后的元素，使用了continue，未使用加入path，继续递归知道`path.size==nums.length`.

### 代码实现

~~~java
public class Permute {
    List<List<Integer>> res = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    boolean[] used;

    public List<List<Integer>> permute(int[] nums) {
        used = new boolean[nums.length];
        backtracking(nums, used);
        return res;
    }

    public void backtracking(int[] nums, boolean[] used) {
        if (path.size() == nums.length) {
            res.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            if (used[i]) continue;
            used[i] = true;
            path.add(nums[i]);
            backtracking(nums, used);
            path.removeLast();
            used[i] = false;
        }
    }
}
~~~

## 47.全排列 II

给定一个可包含重复数字的序列 `nums` ，***按任意顺序*** 返回所有不重复的全排列。

**示例 1：**

```
输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
```

### 思路

在使用used的基础需要额外：

对数组排序，同一层不能取重复元素

~~~java
//之前已经取过相同元素，并且将used[i-1]重置为false
if (i > 0 && !used[i - 1] && nums[i] == nums[i - 1])
    continue;
~~~

### 代码实现

```java
public List<List<Integer>> permuteUnique(int[] nums) {
    used = new boolean[nums.length];
    Arrays.sort(nums);
    backtracking(nums, used);
    return res;
}

public void backtracking(int[] nums, boolean[] used) {
    if (path.size() == nums.length) {
        res.add(new ArrayList<>(path));
        return;
    }
    for (int i = 0; i < nums.length; i++) {
        //之前已经取过相同元素，并且将used[i-1]重置为false
        if (i > 0 && !used[i - 1] && nums[i] == nums[i - 1])
            continue;
        if (!used[i]) {
            used[i] = true;
            path.add(nums[i]);
            backtracking(nums, used);
            path.removeLast();
            used[i] = false;
        }

    }
}
```

## 332.重新安排行程

给你一份航线列表 `tickets` ，其中 `tickets[i] = [fromi, toi]` 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。

所有这些机票都属于一个从 `JFK`（肯尼迪国际机场）出发的先生，所以该行程必须从 `JFK` 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。

- 例如，行程 `["JFK", "LGA"]` 与 `["JFK", "LGB"]` 相比就更小，排序更靠前。

假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/14/itinerary1-graph.jpg)

```
输入：tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]
输出：["JFK","MUC","LHR","SFO","SJC"]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/03/14/itinerary2-graph.jpg)

```
输入：tickets = [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
输出：["JFK","ATL","JFK","SFO","ATL","SFO"]
解释：另一种有效的行程是 ["JFK","SFO","ATL","JFK","ATL","SFO"] ，但是它字典排序更大更靠后。
```

### 思路

避免出现死循环

开始时path要加入JFK

终止条件`path.size() == tickets.size() + 1`

### Colections.sort

本题中直接使用List自带的sort，`tickets.sort((a, b) -> a.get(1).compareTo(b.get(1)))`;sort方法比较字符串，升序排序。

### 代码实现-会超时

~~~java
public class FindItinerary {
    public List<String> res;
    public LinkedList<String> path = new LinkedList<>();

    public List<String> findItinerary(List<List<String>> tickets) {
        tickets.sort((a, b) -> a.get(1).compareTo(b.get(1)));
        path.add("JFK");
        boolean used[] = new boolean[tickets.size()];
        backtracking((ArrayList) tickets, used);
        return res;
    }

    public boolean backtracking(ArrayList<List> tickets, boolean[] used) {
        if (path.size() == tickets.size() + 1) {
            res = new LinkedList<>(path);
            return true;
        }
        for (int i = 0; i < tickets.size(); i++) {
            if (!used[i] && tickets.get(i).get(0).equals(path.getLast())) {
                path.add((String) tickets.get(i).get(1));
                used[i] = true;

                if (backtracking(tickets, used)) {
                    return true;
                }

                used[i] = false;
                path.removeLast();
            }
        }
        return false;
    }
}
~~~

### 法二-使用map函数

Hierholzer 算法用于在连通图中寻找欧拉路径，其流程如下：

- 从起点出发，进行深度优先搜索。

- 每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边。

- 如果没有可移动的路径，则将所在节点加入到栈中，并返回。


不妨倒过来思考。我们注意到只有那个入度与出度差为 111 的节点会导致死胡同。而该节点必然是最后一个遍历到的节点。我们可以改变入栈的规则，当我们遍历完一个节点所连的所有节点后，我们才将该节点入栈（即逆序入栈）。

对于当前节点而言，从它的每一个非「死胡同」分支出发进行深度优先搜索，都将会搜回到当前节点。而从它的「死胡同」分支出发进行深度优先搜索将不会搜回到当前节点。也就是说当前节点的死胡同分支将会优先于其他非「死胡同」分支入栈。

~~~java
public class FindItineraryRec {
    Map<String, PriorityQueue<String>> map = new HashMap<String, PriorityQueue<String>>();
    List<String> itinerary = new LinkedList<String>();

    public List<String> findItinerary(List<List<String>> tickets) {
        for (List<String> ticket : tickets) {
            String src = ticket.get(0), dst = ticket.get(1);
            if (!map.containsKey(src)) {
                map.put(src, new PriorityQueue<String>());
            }
            map.get(src).offer(dst);
        }
        dfs("JFK");
        Collections.reverse(itinerary);
        return itinerary;
    }

    public void dfs(String curr) {
        while (map.containsKey(curr) && map.get(curr).size() > 0) {
            String tmp = map.get(curr).poll();
            dfs(tmp);
        }
        itinerary.add(curr);
    }
}
~~~

## 51. N皇后

按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。

**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。

每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。

### 思路

如何验证当前节点是否符合条件

1. 检查列
2. 45°和135°需要要检查

```java
for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
    if (chessboard[i][j] == 'Q') {
        return false;
    }
}

//check 135 degrees
for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
    if (chessboard[i][j] == 'Q') {
        return false;
    }
}
```

将`char[][]`转化为字符窜，一定要复制

~~~java
for (char[] chars : chessboard) {
    str.add(String.copyValueOf(chars));
}
~~~

每一层遍历

### 代码实现

~~~java
public class SolveNQueens {
    List<List<String>> res = new ArrayList<>();

    public List<List<String>> solveNQueens(int n) {
        char[][] chessboard = new char[n][n];
        for (char[] chars : chessboard) {
            Arrays.fill(chars, '.');
        }
        backtracking(n, 0, chessboard);
        return res;
    }

    public void backtracking(int n, int row, char[][] chessboard) {
        if (row == n) {
            res.add(ArraysToList(chessboard));
            return;
        }
        for (int col = 0; col < n; col++) {
            if (isValid(row, col, n, chessboard)) {
                chessboard[row][col] = 'Q';
                backtracking(n, row + 1, chessboard);
                chessboard[row][col] = '.';
            }
        }
    }

    public List<String> ArraysToList(char[][] chessboard) {
        List<String> str = new ArrayList<>();
        for (char[] chars : chessboard) {
            str.add(String.copyValueOf(chars));
        }
        return str;
    }

    public boolean isValid(int row, int col, int n, char[][] chessboard) {
        //check column
        for (int i = 0; i < row; i++) {
            if (chessboard[i][col] == 'Q') {
                return false;
            }
        }
        //check 45 degrees
        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
            if (chessboard[i][j] == 'Q') {
                return false;
            }
        }

        //check 135 degrees
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if (chessboard[i][j] == 'Q') {
                return false;
            }
        }
        return true;

    }


}
~~~

## 37. 解数独

编写一个程序，通过填充空格来解决数独问题。

数独的解法需 **遵循如下规则**：

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）

数独部分空格内已填入了数字，空白格用 `'.'` 表示。

- `board.length == 9`
- `board[i].length == 9`
- `board[i][j]` 是一位数字或者 `'.'`

### 思路

1. 一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！

2. 判断棋盘是否合法有如下三个维度：

- 同行是否重复
- 同列是否重复
- 9宫格里是否重复

注意点：递归时何时返回true和false需要注意

### 代码实现

~~~java
 public void solveSudoku(char[][] board) {
        backtracking(board);
    }

    public boolean backtracking(char[][] board) {
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j] != '.') continue;
                for (char k = '1'; k <= '9'; k++) {
                    if (isValid(i, j, k, board)) {
                        board[i][j] = k;
                        if (backtracking(board)) {
                            return true;
                        }
                        board[i][j] = '.';
                    }
                }
                //1-9试完全失败
                return false;
            }
        }

        //所有的都填充完毕，9*9continue，true
        return true;
    }

    public boolean isValid(int row, int col, char val, char[][] board) {
        //check row
        for (int i = 0; i < board[0].length; i++) {
            if (board[row][i] == val) {
                return false;
            }
        }
        //check col
        for (int i = 0; i < board.length; i++) {
            if (board[i][col] == val) {
                return false;
            }
        }

        //check block
        int newRow = row - row % 3;
        int newCol = col - col % 3;
        for (int i = newRow; i < newRow + 3; i++) {
            for (int j = newCol; j < newCol + 3; j++) {
                if (board[i][j] == val) {
                    return false;
                }
            }
        }
        return true;

    }
~~~

