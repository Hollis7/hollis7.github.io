---
title: 代码随想录-图论
categories:
- code_Musing
tags:
- graph_theory
---
<meta name="referrer" content="no-referrer"/>

## 内容

**本节包括：**

- 理论基础(dfs和bfs)
- 岛屿问题
- 并查集

<!--more-->

## 理论基础

### DFS

dfs是可一个方向去搜，不到黄河不回头，直到遇到绝境了，搜不下去了，再换方向（换方向的过程就涉及到了回溯）。

~~~java
void dfs(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本节点所连接的其他节点) {
        处理节点;
        dfs(图，选择的节点); // 递归
        回溯，撤销处理结果
    }
}
~~~

### BFS

bfs是先把本节点所连接的所有节点遍历一遍，走到下一个节点的时候，再把连接节点的所有节点遍历一遍，搜索方向更像是广度，四面八方的搜索过程。

#### 适用场景

广搜的搜索方式就适合于解决**两个点之间的最短路径问题。**

因为广搜是从起点出发，以起始点为中心一圈一圈进行搜索，一旦遇到终点，记录之前走过的节点就是一条最短路。

## 200. 岛屿数量

给你一个由`1`（陆地）和`0`（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。

### 思路

#### dfs

dfs，从四个方向遍历，访问过的陆地将其沉没

#### bfs

**只要加入队列就代表 走过，就需要标记，而不是从队列拿出来的时候再去标记走过**。

### 代码实现

#### dfs

~~~java
 public int numIslands(char[][] grid) {
    int res = 0;
    for (int i = 0; i < grid.length; i++) {
        for (int j = 0; j < grid[0].length; j++) {
            if (grid[i][j] == '1') {
                res++;
                dfs(grid, i, j);
            }
        }
    }
    return res;
}

public void dfs(char[][] grid, int i, int j) {
    if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == '0') {
        return;
    }

    grid[i][j] = '0';//沉没陆地
    //逆时针遍历
    dfs(grid, i + 1, j);
    dfs(grid, i, j + 1);
    dfs(grid, i - 1, j);
    dfs(grid, i, j - 1);
}
~~~

#### bfs

~~~java
int[][] dir = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};//四个方向
boolean[][] visited;
public int numIslands2(char[][] grid) {
        int res = 0;
        visited = new boolean[grid.length][grid[0].length];//是否访问过标志
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (!visited[i][j] && grid[i][j] == '1') {
                    res++;
                    bfs(grid, i, j);
                }
            }
        }
        return res;

    }

    public void bfs(char[][] grid, int i, int j) {
        Deque<int[]> queen = new LinkedList<>();
        queen.add(new int[]{i, j});
        visited[i][j] = true;
        while (!queen.isEmpty()) {
            int[] cur = queen.poll();
            int x = cur[0];
            int y = cur[1];
            for (int k = 0; k < 4; k++) {
                int nextx = x + dir[k][0];
                int nexty = y + dir[k][1];
                if (nextx < 0 || nextx >= grid.length || nexty < 0 || nexty >= grid[0].length || grid[nextx][nexty] == '0')
                    continue;
                if (grid[nextx][nexty] == '1' && !visited[nextx][nexty]) {
                    queen.add(new int[]{nextx, nexty});
                    visited[nextx][nexty] = true;
                }
            }
        }
    }
~~~



## 797.所有可能的路径

给你一个有 `n` 个节点的 **有向无环图（DAG）**，请你找出所有从节点 `0` 到节点 `n-1` 的路径并输出（**不要求按特定顺序**）

 `graph[i]` 是一个从节点 `i` 可以访问的所有节点的列表（即从节点 `i` 到节点 `graph[i][j]`存在一条有向边）。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg)

```
输入：graph = [[1,2],[3],[3],[]]
输出：[[0,1,3],[0,2,3]]
解释：有两条路径 0 -> 1 -> 3 和 0 -> 2 -> 3
```

### 思路

通过dfs遍历和回溯

### 代码实现

~~~java
public class AllPathsSourceTarget {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        path.add(0);
        dfs(graph, 0);
        return res;
    }

    public void dfs(int[][] graph, int node) {
        if (node == graph.length - 1) {
            res.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < graph[node].length; i++) {
            path.add(graph[node][i]);
            dfs(graph, graph[node][i]);
            path.remove(path.size() - 1);//回溯
        }
    }
}
~~~

## 695. 岛屿的最大面积

给你一个大小为 `m x n` 的二进制矩阵 `grid` 。

**岛屿** 是由一些相邻的 `1` (代表土地) 构成的组合，这里的「相邻」要求两个 `1` 必须在 **水平或者竖直的四个方向上** 相邻。你可以假设 `grid` 的四个边缘都被 `0`（代表水）包围着。

岛屿的面积是岛上值为 `1` 的单元格的数目。

计算并返回 `grid` 中最大的岛屿面积。如果没有岛屿，则返回面积为 `0` 。

### 思路

类似岛屿数量，只不过每次dfs都要计算面积

### 代码实现

~~~java
public int maxAreaOfIsland(int[][] grid) {
    int maxArea = 0;
    int tmpArea = 0;
    for (int i = 0; i < grid.length; i++) {
        for (int j = 0; j < grid[0].length; j++) {
            if (grid[i][j] == 1) {
                tmpArea = dfs(grid, i, j);
                maxArea = Math.max(tmpArea, maxArea);
            }
        }
    }
    return maxArea;
}

public int dfs(int[][] grid, int i, int j) {
    int tmpArea = 0;
    if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0) {
        return 0;
    }
    grid[i][j] = 0;//沉没岛屿
    tmpArea++;
    tmpArea += dfs(grid, i + 1, j);
    tmpArea += dfs(grid, i, j + 1);
    tmpArea += dfs(grid, i - 1, j);
    tmpArea += dfs(grid, i, j - 1);
    return tmpArea;
}
~~~

## 1020. 飞地的数量

给你一个大小为 `m x n` 的二进制矩阵 `grid` ，其中 `0` 表示一个海洋单元格、`1` 表示一个陆地单元格。

一次 **移动** 是指从一个陆地单元格走到另一个相邻（**上、下、左、右**）的陆地单元格或跨过 `grid` 的边界。

返回网格中 **无法** 在任意次数的移动中离开网格边界的陆地单元格的数量。

### 思路

求每个岛屿的面积，如果岛屿能跨过边界，不计入飞地，不能跨越边界，计入飞地

~~~java
if (i == 0 || i == grid.length - 1 || j == 0 || j == grid[0].length - 1) canFly = true;
~~~

### 代码实现

~~~java
public class NumEnclaves {
    boolean canFly;

    public int numEnclaves(int[][] grid) {
        int enclaves = 0;
        int tmpArea;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                tmpArea = dfs(grid, i, j);
                if (!canFly) enclaves += tmpArea;
                canFly = false;
            }
        }
        return enclaves;
    }

    public int dfs(int[][] grid, int i, int j) {
        int tmpArea = 0;
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0) return 0;

        grid[i][j] = 0;//沉没岛屿
        if (i == 0 || i == grid.length - 1 || j == 0 || j == grid[0].length - 1) canFly = true;
        tmpArea++;
        tmpArea += dfs(grid, i + 1, j);
        tmpArea += dfs(grid, i, j + 1);
        tmpArea += dfs(grid, i - 1, j);
        tmpArea += dfs(grid, i, j - 1);
        return tmpArea;

    }
}
~~~

## 130. 被围绕的区域

给你一个 `m x n` 的矩阵 `board` ，由若干字符 `'X'` 和 `'O'` ，找到所有被 `'X'` 围绕的区域，并将这些区域里所有的 `'O'` 用 `'X'` 填充。

### 思路

依然是从地图周边出发，将周边空格相邻的'O'都做上标记，然后在遍历一遍地图，遇到 'O' 且没做过标记的，那么都是地图中间的'O'，全部改成'X'就行。

1. 步骤一：深搜或者广搜将地图周边的'O'全部改成'A'
2. 步骤二：在遍历地图，将'O'全部改成'X'（地图中间的'O'改成了'X'），将'A'改回'O'（保留的地图周边的'O'）

### 代码实现

~~~java
public class Solve {
    int[][] dir = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};

    public void solve(char[][] board) {
        int m = board.length;
        int n = board[0].length;
        //四周dfs遍历"O",将其标记为“A”
        for (int i = 0; i < m; i++) {
            dfs(board, i, 0);
            dfs(board, i, n - 1);
        }
        for (int j = 0; j < n; j++) {
            dfs(board, 0, j);
            dfs(board, m - 1, j);
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                switch (board[i][j]) {
                    case 'A':
                        board[i][j] = 'O';
                        break;
                    case 'O':
                        board[i][j] = 'X';
                        break;
                    case 'X':
                        break;
                }
            }
        }
    }

    public void dfs(char[][] board, int i, int j) {
        if (board[i][j] == 'O') {
            //处理当前节点
            board[i][j] = 'A';
            //当前的都是O
            for (int k = 0; k < 4; k++) {
                int nextX = i + dir[k][0];
                int nextY = j + dir[k][1];
                if (nextX < 0 || nextX >= board.length || nextY < 0 || nextY >= board[0].length)//校验是否越界
                    continue;
                dfs(board, nextX, nextY);
            }
        }
    }
}
~~~

## 417. 太平洋大西洋水流问题

有一个 `m × n` 的矩形岛屿，与 **太平洋** 和 **大西洋** 相邻。 **“太平洋”** 处于大陆的左边界和上边界，而 **“大西洋”** 处于大陆的右边界和下边界。

这个岛被分割成一个由若干方形单元格组成的网格。给定一个 `m x n` 的整数矩阵 `heights` ， `heights[r][c]` 表示坐标 `(r, c)` 上单元格 **高于海平面的高度** 。

岛上雨水较多，如果相邻单元格的高度 **小于或等于** 当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。

返回网格坐标 `result` 的 **2D 列表** ，其中 `result[i] = [ri, ci]` 表示雨水从单元格 `(ri, ci)` 流动 **既可流向太平洋也可流向大西洋** 。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/06/08/waterflow-grid.jpg)

```
输入: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]
输出: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
```

### 思路

分别从太平洋和大西洋海岸逆流，用不同的数组标记pacific和atlantic，可以逆流就记为true，最后只有pacific和atlantic都可以逆流到达才加入结果。

~~~java
if (atlantic[i][j] && pacific[i][j]) {
    res.add(List.of(i, j));
}
~~~

初始海岸要分别对pacific和atlantic设为true。

### 代码实现

~~~java
int[][] dirs = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};//四个方向

public List<List<Integer>> pacificAtlantic(int[][] heights) {
    int m = heights.length;
    int n = heights[0].length;
    boolean[][] pacific = new boolean[m][n];//是否从太平洋访问过
    boolean[][] atlantic = new boolean[m][n];//是否从大西洋访问过

    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    for (int i = 0; i < m; i++) {
        dfs(heights, pacific, i, 0);//左列太平洋
        pacific[i][0] = true;

        dfs(heights, atlantic, i, n - 1);//右列大西洋
        atlantic[i][n - 1] = true;
    }
    for (int j = 0; j < n; j++) {
        dfs(heights, pacific, 0, j);//上行太平洋
        pacific[0][j] = true;

        dfs(heights, atlantic, m - 1, j);//下行大西洋
        atlantic[m - 1][j] = true;
    }
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (atlantic[i][j] && pacific[i][j]) {
                res.add(List.of(i, j));
            }
        }
    }
    return res;

}

public void dfs(int[][] heights, boolean[][] visited, int r, int c) {
    for (int[] dir : dirs) {
        int nextR = r + dir[0];
        int nextC = c + dir[1];
        if (nextR < 0 || nextR >= heights.length || nextC < 0 || nextC >= heights[0].length || visited[nextR][nextC])
            continue;
        if (heights[r][c] <= heights[nextR][nextC]) {
            visited[nextR][nextC] = true;//可以向上逆流
            dfs(heights, visited, nextR, nextC);
        }
    }
}
~~~

## 827.最大人工岛

给你一个大小为 `n x n` 二进制矩阵 `grid` 。**最多** 只能将一格 `0` 变成 `1` 。

返回执行此操作后，`grid` 中最大的岛屿面积是多少？

**岛屿** 由一组上、下、左、右四个方向相连的 `1` 形成。

###  思路

只要用一次深搜把每个岛屿的面积记录下来就好。

第一步：一次遍历地图，得出各个岛屿的面积，并做编号记录。可以使用map记录，key为岛屿编号，value为岛屿面积 

~~~java
int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向
void dfs(vector<vector<int>>& grid, int x, int y, int mark) {
    if (grid[x][y] != 1 || grid[x][y] == 0) return; // 终止条件：访问过的节点 或者 遇到海水
    grid[x][y] = mark; // 给陆地标记新标签
    count++;
    for (int i = 0; i < 4; i++) {
        int nextx = x + dir[i][0];
        int nexty = y + dir[i][1];
        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过
        dfs(grid, nextx, nexty, mark);
    }
}
public:
    int largestIsland(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        unordered_map<int ,int> gridNum;
        int mark = 2; // 记录每个岛屿的编号
        bool isAllGrid = true; // 标记是否整个地图都是陆地
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (grid[i][j] == 0) isAllGrid = false;
                if (grid[i][j] == 1) {
                    count = 0;
                    dfs(grid, i, j, mark); // 将与其链接的陆地都标记上 true
                    gridNum[mark] = count; // 记录每一个岛屿的面积
                    mark++; // 记录下一个岛屿编号
                }
            }
        }
    }
}
~~~

第二步：在遍历地图，遍历0的方格（因为要将0变成1），并统计该1（由0变成的1）周边岛屿面积，将其相邻面积相加在一起，遍历所有 0 之后，就可以得出 选一个0变成1 之后的最大面积。

### 代码实现

太长，略

## 127.单词接龙

字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：

- 序列中第一个单词是 beginWord 。
- 序列中最后一个单词是 endWord 。
- 每次转换只能改变一个字母。
- 转换过程中的中间单词必须是字典 wordList 中的单词。
- 给你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。

示例 1：

- 输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
- 输出：5
- 解释：一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog", 返回它的长度 5。

### 思路

**这里无向图求最短路，广搜最为合适，广搜只要搜到了终点，那么一定是最短的路径**。因为广搜就是以起点中心向四周扩散的搜索。

- 本题是一个无向图，需要用标记位，标记着节点是否走过，否则就会死循环！
- 本题给出集合是数组型的，可以转成set结构，查找更快一些

### 代码实现

~~~java
public int ladderLength(String beginWord, String endWord, List<String> wordList) {
    HashSet<String> wordSet = new HashSet<>(wordList);
    Map<String, Integer> map = new HashMap<>();//记录路径长度
    Queue<String> queue = new LinkedList<>();//bfs队列
    queue.offer(beginWord);
    map.put(beginWord, 1);

    if (!wordSet.contains(endWord)) return 0;

    while (!queue.isEmpty()) {
        String word = queue.poll(); //取出队头单词
        int path = map.get(word); //获取到该单词的路径长度
        for (int i = 0; i < word.length(); i++) { //遍历单词的每个字符
            char[] chars = word.toCharArray(); //将单词转换为char array，方便替换
            for (char k = 'a'; k <= 'z'; k++) { //从'a' 到 'z' 遍历替换
                chars[i] = k; //替换第i个字符
                String newWord = String.valueOf(chars); //得到新的字符串
                if (newWord.equals(endWord)) {  //如果新的字符串值与endWord一致，返回当前长度+1
                    return path + 1;
                }
                if (wordSet.contains(newWord) && !map.containsKey(newWord)) { //如果新单词在set中，但是没有访问过
                    map.put(newWord, path + 1); //记录单词对应的路径长度
                    queue.offer(newWord);//加入队尾
                }
            }
        }
    }
    return 0; //未找到

}
~~~

## 841.钥匙和房间

有 `n` 个房间，房间按从 `0` 到 `n - 1` 编号。最初，除 `0` 号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。

当你进入一个房间，你可能会在里面找到一套不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。

给你一个数组 `rooms` 其中 `rooms[i]` 是你进入 `i` 号房间可以获得的钥匙集合。如果能进入 **所有** 房间返回 `true`，否则返回 `false`。

### 思路

BFS思想，通过队列遍历钥匙打开房间，每次打开房间，将钥匙放入队列，已经打开的门跳过。

### 代码实现

~~~java
public class CanVisitAllRooms {
    public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        int n = rooms.size();
        int[] visited = new int[n];//是否打开了房间
        Queue<Integer> queue = new LinkedList<>();
        //准备进入第一个房间拿到钥匙
        queue.offer(0);
        int openRooms = 0;
        while (!queue.isEmpty()) {
            int curKey = queue.poll();
            if (visited[curKey] == 0) {//没有打开过这个房间，现在打开，获取钥匙
                visited[curKey] = 1;
                openRooms++;
                List<Integer> keys = rooms.get(curKey);
                for (Integer key : keys) {
                    queue.offer(key);
                }
                if (openRooms == n) return true;
            }
        }
        return false;
    }

}
~~~

## 463. 岛屿的周长

给定一个 `row x col` 的二维网格地图 `grid` ，其中：`grid[i][j] = 1` 表示陆地， `grid[i][j] = 0` 表示水域。

网格中的格子 **水平和垂直** 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。

岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。

### 思路

统计陆地面积，四个方向有遇到陆地，相交边加一

> 其实可以只考虑两个方向，上边和左边的相交边两倍就是重叠的边

### 代码实现

~~~java
int[][] dir = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};//四个方向

public int islandPerimeter(int[][] grid) {
    int area = 0;
    int interEdges = 0;
    for (int i = 0; i < grid.length; i++) {
        for (int j = 0; j < grid[0].length; j++) {
            if (grid[i][j] == 1) {//只有一个岛，不用考虑之后
                area++;
                for (int k = 0; k < 4; k++) {
                    int nextX = i + dir[k][0];
                    int nextY = j + dir[k][1];
                    if (nextX < 0 || nextX >= grid.length || nextY < 0 || nextY >= grid[0].length || grid[nextX][nextY] == 0)
                        continue;
                    interEdges++;//有相交的边，那么加一
                }
            }
        }
    }
    return area * 4 - interEdges;
}
~~~

### 优化

~~~java
public int islandPerimeter(int[][] grid) {
    int area = 0;
    int interEdges = 0;
    for (int i = 0; i < grid.length; i++) {
        for (int j = 0; j < grid[0].length; j++) {
            if (grid[i][j] == 1) {//只有一个岛，不用考虑之后
                area++;
                if (i - 1 >= 0 && grid[i - 1][j] == 1) interEdges++;
                if (j - 1 >= 0 && grid[i][j - 1] == 1) interEdges++;
            }
        }
    }
    return area * 4 - interEdges * 2;
}
~~~

## 并查集理论

并查集主要有两个功能：

- 将两个元素添加到一个集合中。
- 判断两个元素在不在同一个集合

~~~c++
// 将v，u 这条边加入并查集
void join(int u, int v) {
    u = find(u); // 寻找u的根
    v = find(v); // 寻找v的根
    if (u == v) return; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回
    father[v] = u;
}
~~~

~~~c++
// 并查集里寻根的过程
int find(int u) {
    if (u == father[u]) return u; // 如果根就是自己，直接返回
    else return find(father[u]); // 如果根不是自己，就根据数组下标一层一层向下找
}
~~~

~~~c++
// 并查集初始化
void init() {
    for (int i = 0; i < n; ++i) {
        father[i] = i;
    }
}
~~~

```cpp
// 判断 u 和 v是否找到同一个根
bool isSame(int u, int v) {
    u = find(u);
    v = find(v);
    return u == v;
}
```

### 路径压缩

在实现 find 函数的过程中，我们知道，通过递归的方式，不断获取father数组下标对应的数值，最终找到这个集合的根。

搜索过程像是一个多叉树中从叶子到根节点的过程，如果这棵多叉树高度很深的话，每次find函数 去寻找根的过程就要递归很多次，我们的目的只需要知道这些节点在同一个根下就可以，所以对这棵多叉树的构造只需要这样就可以了，如图：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230602103040.png" alt="img" style="zoom:50%;" />

除了根节点其他所有节点都挂载根节点下，这样我们在寻根的时候就很快，只需要一步，

> 我们只需要在递归的过程中，让 father[u] 接住递归函数 find(father[u]) 的返回结果。
>
> 因为 find 函数向上寻找根节点，father[u] 表述 u 的父节点，那么让 father[u] 直接获取 find函数 返回的根节点，这样就让节点 u 的父节点 变成根节点。

```cpp
// 并查集里寻根的过程
int find(int u) {
    if (u == father[u]) return u;
    else return father[u] = find(father[u]); // 路径压缩
}
```

### 按秩合并

```cpp
// 将v->u 这条边加入并查集
void join(int u, int v) {
    u = find(u); // 寻找u的根
    v = find(v); // 寻找v的根

    if (rank[u] <= rank[v]) father[u] = v; // rank小的树合入到rank大的树
    else father[v] = u;

    if (rank[u] == rank[v] && u != v) rank[v]++; // 如果两棵树高度相同，则v的高度+1，因为上面 if (rank[u] <= rank[v]) father[u] = v; 注意是 <=
}
```

## 1971. 寻找图中是否存在路径

有一个具有 `n` 个顶点的 **双向** 图，其中每个顶点标记从 `0` 到 `n - 1`（包含 `0` 和 `n - 1`）。图中的边用一个二维整数数组 `edges` 表示，其中 `edges[i] = [ui, vi]` 表示顶点 `ui` 和顶点 `vi` 之间的双向边。 每个顶点对由 **最多一条** 边连接，并且没有顶点存在与自身相连的边。

请你确定是否存在从顶点 `source` 开始，到顶点 `destination` 结束的 **有效路径** 。

给你数组 `edges` 和整数 `n`、`source` 和 `destination`，如果从 `source` 到 `destination` 存在 **有效路径** ，则返回 `true`，否则返回 `false` 。

### 思路

采用并查集，一定要压缩路径，不然会超时

### 代码实现

~~~java
public class ValidPath {
    int[] father;

    public boolean validPath(int n, int[][] edges, int source, int destination) {
        father = new int[n];
        init();
        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];
            join(u, v);
        }
        return isSame(source, destination);
    }

    public void init() {
        for (int i = 0; i < father.length; i++) {
            father[i] = i;
        }
    }

    public int find(int u) {
        if (u == father[u]) return u;
        return father[u] = find(father[u]);
    }

    public boolean isSame(int u, int v) {
        u = find(u);
        v = find(v);
        return u == v;
    }

    public void join(int u, int v) {
        u = find(u);
        v = find(v);
        if (u == v) return;
        father[u] = v;
    }
}
~~~

## 684.冗余连接

树可以看成是一个连通且 **无环** 的 **无向** 图。

给定往一棵 `n` 个节点 (节点值 `1～n`) 的树中添加一条边后的图。添加的边的两个顶点包含在 `1` 到 `n` 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 `n` 的二维数组 `edges` ，`edges[i] = [ai, bi]` 表示图中在 `ai` 和 `bi` 之间存在一条边。

请找出一条可以删去的边，删除后可使得剩余部分是一个有着 `n` 个节点的树。如果有多个答案，则返回数组 `edges` 中最后出现的那个。

### 思路

那么我们就可以从前向后遍历每一条边（因为优先让前面的边连上），边的两个节点如果不在同一个集合，就加入集合（即：同一个根节点）。

- 节点A 和节点 B 不在同一个集合，那么就可以将两个 节点连在一起。
- 如果边的两个节点已经出现在同一个集合里，说明着边的两个节点已经连在一起了，再加入这条边一定就出现环了。

### 代码实现

~~~java
public int[] findRedundantConnection(int[][] edges) {
    int n = edges.length;
    father = new int[n + 1];
    init();
    for (int[] edge : edges) {
        int u = edge[0];
        int v = edge[1];
        if (!isSame(u, v)) {
            join(u, v);
        } else return edge;
    }
    return new int[]{0, 0};
}
~~~

## 685.冗余连接II

在本问题中，有根树指满足以下条件的 **有向** 图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。

输入一个有向图，该图由一个有着 `n` 个节点（节点值不重复，从 `1` 到 `n`）的树及一条附加的有向边构成。附加的边包含在 `1` 到 `n` 中的两个不同顶点间，这条附加的边不属于树中已存在的边。

结果图是一个以边组成的二维数组 `edges` 。 每个元素是一对 `[ui, vi]`，用以表示 **有向** 图中连接顶点 `ui` 和顶点 `vi` 的边，其中 `ui` 是 `vi` 的一个父节点。

返回一条能删除的边，使得剩下的图是有 `n` 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。

### 思路

那么有如下三种情况：

1. 前两种情况是出现入度为2的点，如图：

<img src="https://code-thinking.cdn.bcebos.com/pics/685.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5II1.png" alt="img" style="zoom:50%;" />

> 分别对这两条边删除，观察是否还能构成树，返回最后出现在给定二维数组的答案，因此用到了栈

2. 第三种情况是没有入度为2的点，那么图中一定出现了有向环（**注意这里强调是有向环！**）

<img src="https://code-thinking.cdn.bcebos.com/pics/685.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5II2.png" alt="img" style="zoom:50%;" />

> 按照如果新加入的边的两点如果有相同的根节点，那么舍弃

### 代码实现

~~~java
public int[] findRedundantDirectedConnection(int[][] edges) {
    int n = edges.length;
    father = new int[n + 1];
    int[] inDegrees = new int[n + 1];//节点入度
    int twoDegreesIdx = 0;
    //计算入度为2
    for (int i = 0; i < edges.length; i++) {
        inDegrees[edges[i][1]]++;
        if (inDegrees[edges[i][1]] == 2) twoDegreesIdx = edges[i][1];
    }
    Stack<Integer> stack = new Stack<>();
    for (int i = 0; i < edges.length; i++) {
        if (inDegrees[edges[i][1]] == 2) {
            stack.push(i);
        }
    }
    if (stack.size() == 2) {
        if (solveTwoInDegrees(edges, stack.peek())) return edges[stack.peek()];
        else {
            stack.pop();
            return edges[stack.peek()];
        }
    }

    return edges[removeCircleEdge(edges)];
}
public int removeCircleEdge(int[][] edges) {
    init();
    for (int i = 0; i < edges.length; i++) {
        if (isSame(edges[i][0], edges[i][1])) {//有环
            return i;
        } else join(edges[i][0], edges[i][1]);
    }
    return 0;
}

public boolean solveTwoInDegrees(int[][] edges, int i) {
    init();
    for (int j = 0; j < edges.length; j++) {
        if (j == i) continue;
        if (isSame(edges[j][0], edges[j][1])) {
            return false;
        } else join(edges[j][0], edges[j][1]);
    }
    return true;
}

    
~~~

## 117.软件构建心

某个大型软件项目的构建系统拥有 N 个文件，文件编号从 0 到 N - 1，在这些文件中，某些文件依赖于其他文件的内容，这意味着如果文件 A 依赖于文件 B，则必须在处理文件 A 之前处理文件 B （0 <= A, B <= N - 1）。请编写一个算法，用于确定文件处理的顺序。

**输入描述**

第一行输入两个正整数 N, M。表示 N 个文件之间拥有 M 条依赖关系。

后续 M 行，每行两个正整数 S 和 T，表示 T 文件依赖于 S 文件。

**输出描述**

输出共一行，如果能处理成功，则输出文件顺序，用空格隔开。 

如果不能成功处理（相互依赖），则输出 -1。

**输入示例**

```
5 4
0 1
0 2
1 3
2 4
```

**输出示例**

```
0 1 2 3 4
```

**提示信息**

文件依赖关系如下：



<img src="https://kamacoder.com/upload/kamacoder.com/image/20240430/20240430150745_18459.png" alt="img" style="zoom: 50%;" />



所以，文件处理的顺序除了示例中的顺序，还存在

0 2 4 1 3

0 2 1 3 4

等等合法的顺序。

数据范围：

0 <= N <= 10 ^ 5

1 <= M <= 10 ^ 9

每行末尾无空格。

### 思路

拓扑排序指的是一种 解决问题的大体思路， 而具体算法，可能是广搜也可能是深搜。

实现拓扑排序的算法有两种：卡恩算法（BFS）和DFS

> 卡恩1962年提出这种解决拓扑排序的思路

一般来说我们只需要掌握 BFS （广度优先搜索）就可以了，清晰易懂，如果还想多了解一些，可以再去学一下 DFS 的思路，但 DFS 不是本篇重点。

总体步骤：

> 找到入度为0 的节点，加入结果集
> 将该节点从图中移除

### 代码实现

~~~java
public class SoftwareDeploy {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int m = in.nextInt();

        List<List<Integer>> umap = new ArrayList<>();//记录依赖关系
        int[] inDegree = new int[n];//记录入度
        for (int i = 0; i < n; i++) {
            umap.add(new ArrayList<>());
        }

        for (int i = 0; i < m; i++) {
            int u = in.nextInt();
            int v = in.nextInt();
            umap.get(u).add(v);//记录依赖关系
            inDegree[v]++;//v入度加一
        }

        List<Integer> res = new ArrayList<>();
        Deque<Integer> queue = new LinkedList<>();
        for (int i = 0; i < n; i++) {//找到入度为0的点
            if (inDegree[i] == 0) queue.offer(i);
        }
        while (!queue.isEmpty()) {
            int cur = queue.poll();
            res.add(cur);
            for (int e : umap.get(cur)) {
                inDegree[e]--;
                if (inDegree[e] == 0) queue.offer(e);
            }
        }

        if (res.size() == n) {
            for (int i = 0; i < res.size(); i++) {
                System.out.print(res.get(i));
                if (i < res.size() - 1) {
                    System.out.print(" ");
                }
            }
        } else System.out.println(-1);
    }
}
~~~

