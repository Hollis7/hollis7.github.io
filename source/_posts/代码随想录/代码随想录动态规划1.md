---
title: 代码随想录-动态规划1
categories:
- code_Musing
tags:
- dp
---
<meta name="referrer" content="no-referrer"/>

# 内容

**本节包括：**

- 动态规划概念
- 动态规划实战
- 0-1背包（后续遍历）

<!--more-->

## 理论

动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。

**对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！**

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

## 509. 斐波那契数

**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

```
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
```

给定 `n` ，请计算 `F(n)` 。

### 思路

题目已经给出了状态转移方程，用代码实现就行，需要注意n=0，1的情况，动态数组可能越界问题。

### 代码实现

~~~java
public int fib(int n) {
    int[] dp = new int[n + 1];
    dp[0] = 0;
    if (n > 0) {
        dp[1] = 1;
    }
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
~~~

## 70. 爬楼梯

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

### 思路

动态规划

`dp[i]=dp[i-1]+dp[i-2]`

### 代码实现

~~~java
public int climbStairs(int n) {
    if (n == 1) return 1;
    if (n == 2) return 2;//(1,1),(2)
    int[] dp = new int[n + 1];
    dp[1] = 1;
    dp[2] = 2;
    for (int i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
~~~

## 746. 使用最小花费爬楼梯

给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

`2 <= cost.length <= 1000`

### 思路

`dp[i]`表示到达台阶`i`并起跳的最小费用

### 代码实现

~~~java
public int minCostClimbingStairs(int[] cost) {
    int[] dp = new int[cost.length + 1];
    dp[0] = cost[0];
    dp[1] = cost[1];
    for (int i = 2; i < cost.length; i++) {
        dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];
    }
    dp[cost.length] = Math.min(dp[cost.length - 1], dp[cost.length - 2]);
    return dp[cost.length];
}
~~~

## 62.不同路径

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

**示例 1：**

![img](https://pic.leetcode.cn/1697422740-adxmsI-image.png)

```
输入：m = 3, n = 7
输出：28
```

### 思路

机器人从(0 , 0) 位置出发，到(m - 1, n - 1)终点。

`dp[i][j]` ：表示从（0 ，0）出发，到(i, j) 有`dp[i][j]`条不同的路径。

想要求`dp[i][j]`，只能有两个方向来推导出来，即`dp[i - 1][j]` 和 `dp[i][j - 1]`。

起始行和起始列初始为1

### 代码实现

~~~java
public int uniquePaths(int m, int n) {
    int[][] dp = new int[m][n];//到达(i,j)的不同路径数
    for (int i = 0; i < m; i++) {
        dp[i][0] = 1;
    }
    for (int j = 0; j < n; j++) {
        dp[0][j] = 1;
    }
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m - 1][n - 1];
}
~~~

## 63. 不同路径 II

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

### 思路

因为从(0, 0)的位置到(i, 0)的路径只有一条，所以`dp[i][0]`一定为1，`dp[0][j]`也同理。

但如果(i, 0) 这条边有了障碍之后，障碍之后（包括障碍）都是走不到的位置了，所以障碍之后的`dp[i][0]`应该还是初始值0。

从递归公式`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]` 中可以看出，一定是从左到右一层一层遍历，这样保证推导`dp[i][j]`的时候，`dp[i - 1][j]` 和 `dp[i][j - 1]`一定是有数值。

当前是障碍物，直接跳过

### 代码实现

~~~java
public int uniquePathsWithObstacles(int[][] obstacleGrid) {
    int m = obstacleGrid.length;
    int n = obstacleGrid[0].length;
    //如果在起点或终点出现了障碍，直接返回0
    if (obstacleGrid[m - 1][n - 1] == 1 || obstacleGrid[0][0] == 1) {
        return 0;
    }
    int[][] dp = new int[m][n];
    for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;
    for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            if (obstacleGrid[i][j] == 1) continue;
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }

    return dp[m - 1][n - 1];
}
~~~

## 343. 整数拆分

给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。

返回 *你可以获得的最大乘积* 。

### 思路

因为拆分一个数n 使之乘积最大，那么一定是拆分成m个近似相同的子数相乘才是最大的。

例如 6 拆成 3 * 3， 10 拆成 3 * 3 * 4。 100的话 也是拆成m个近似数组的子数 相乘才是最大的。

那么 j 遍历，只需要遍历到 n/2 就可以，后面就没有必要遍历了，一定不是最大值。

 `dp[i] = Math.max(Math.max((i - j) * j, dp[i - j] * j), dp[i]);`

状态转移方程要考虑三个：

1. 当前`dp[i]`
2. `dp[i - j] * j`
3. 把`i-j`单独作为一个数乘以j

### 代码实现

~~~java
 public int integerBreak(int n) {
    int[] dp = new int[n + 1];//dp[n]代表正数拆分的最大乘积
    dp[1] = 1;
    dp[2] = 1;
    for (int i = 3; i <= n; i++) {
        for (int j = 1; j <= i / 2; j++) {
            dp[i] = Math.max(Math.max((i - j) * j, dp[i - j] * j), dp[i]);
        }
    }
    return dp[n];

}
~~~

## 96.不同的二叉搜索树

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

### 思路

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210107093226241.png" alt="96.不同的二叉搜索树2" style="zoom: 33%;" />

 dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]

j相当于是头结点的元素，从1遍历到i为止。

所以递推公式：dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量

## 动态规划：01背包理论基础

有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是`weight[i]`，得到的价值是`value[i]` 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

### 思路

1. 确定dp数组以及下标的含义

使用二维数组，即`dp[i][j]` 表示从下标为`[0-i]`的物品里任意取，放进容量为`j`的背包，价值总和最大是多少

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210110103003361.png" alt="动态规划-背包问题1" style="zoom:50%;" />

2. 确定递推公式

- **不放物品i**：由`dp[i - 1][j]`推出，即背包容量为`j`，里面不放物品i的最大价值，此时`dp[i][j]`就是`dp[i - 1][j]`。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以背包内的价值依然和前面相同。)

- **放物品i**：由`dp[i - 1][j - weight[i]]`推出，`dp[i - 1][j - weight[i]]` 为背包容量为`j - weight[i]`的时候不放物品i的最大价值，那么`dp[i - 1][j - weight[i]] + value[i]` （物品i的价值），就是背包放物品i得到的最大价值

3. dp数组如何初始化

首先从`dp[i][j]`的定义出发，如果背包容量j为0的话，即`dp[i][0]`，无论是选取哪些物品，背包价值总和一定为0。

`dp[0][j]`，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。

那么很明显当 `j < weight[0]`的时候，`dp[0][j]` 应该是 0，因为背包容量比编号0的物品重量还小。

当`j >= weight[0]`时，`dp[0][j]` 应该是value[0]，因为背包容量放足够放编号0物品。

### 代码实现

~~~java
package dynamicProgram;

import java.util.Scanner;

/**
 * 有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是`weight[i]`，
 * 得到的价值是`value[i]` 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。
 */
public class BagProblem {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int goods = scanner.nextInt();
        int bagSize = scanner.nextInt();
        int[] weight = new int[goods];
        int[] value = new int[goods];
        for (int i = 0; i < goods; i++) {
            weight[i] = scanner.nextInt();
        }
        for (int i = 0; i < goods; i++) {
            value[i] = scanner.nextInt();
        }
        System.out.println(testWeightBagProblem(weight, value, bagSize));

    }

    public static int testWeightBagProblem(int[] weight, int[] value, int bagSize) {
        int goods = weight.length;
        int[][] dp = new int[goods][bagSize + 1];

        for (int j = weight[0]; j <= bagSize; j++) {
            dp[0][j] = value[0];
        }
        for (int i = 1; i < goods; i++) {
            for (int j = 1; j <= bagSize; j++) {
                if (j < weight[i]) dp[i][j] = dp[i - 1][j];
                else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
                }
            }
        }
        return dp[goods - 1][bagSize];
    }
}

~~~

## 动态规划：01背包理论基础 一维数组

### 思路

对于背包问题其实状态都是可以压缩的。

在使用二维数组的时候，递推公式：`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])`;

**其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：`dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);`**

与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了，只用dp[j]（一维数组，也可以理解是一个滚动数组）。

~~~java
dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
~~~

**倒序遍历是为了保证物品i只被放入一次！**。但如果一旦正序遍历了，那么物品0就会被重复加入多次！

这和`j - weight[i]`有关

### 代码实现

~~~java
public static int testWeightBagProblemOneDimension(int[] weight, int[] value, int bagSize) {
        int goods = weight.length;
        int[] dp = new int[bagSize + 1];
        for (int i = 0; i < goods; i++) {
            for (int j = bagSize; j >= weight[i]; j--) {
                dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
            }
        }
        return dp[bagSize];
    }
~~~

## 416. 分割等和子集

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

### 思路

- 背包的体积为sum / 2
- 背包要放入的商品（集合里的元素）重量为元素的数值，价值也为元素的数值
- 背包如果正好装满，说明找到了总和为 sum / 2 的子集。
- 背包中每一个元素是不可重复放入。

### 代码实现

~~~java
public boolean canPartition(int[] nums) {
    int count = nums.length;

    int sum = Arrays.stream(nums).sum();
    if (sum % 2 == 1) return false;
    else sum /= 2;
    //容量为sum的背包可以装多少容量
    int[] dp = new int[sum + 1];
    for (int i = 0; i < count; i++) {
        for (int j = sum; j >= nums[i]; j--) {
            dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
        }
    }
    return dp[sum] == sum;
}
~~~

##  1049.最后一块石头的重量II

有一堆石头，用整数数组 `stones` 表示。其中 `stones[i]` 表示第 `i` 块石头的重量。

每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：

- 如果 `x == y`，那么两块石头都会被完全粉碎；
- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。

最后，**最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。

### 思路

将石头尽可能的分成两堆重量相近的子集

用动态规划计算`sum/2`的容量最多可以装多少石块，然后两堆石块进行相减

### 代码实现

~~~java
public int lastStoneWeightII(int[] stones) {
    int sum = Arrays.stream(stones).sum();
    int nums = stones.length;
    int capacities = sum / 2;
    //容量为sum的背包最多可以装多少石头
    int[] dp = new int[capacities + 1];
    for (int i = 0; i < nums; i++) {
        for (int j = capacities; j >= stones[i]; j--) {
            dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);
        }
    }
    return sum - dp[capacities] * 2;
}
~~~

##  494.目标和

给你一个非负整数数组 `nums` 和一个整数 `target` 。

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

### 思路

假设加法的总和为x，那么减法对应的总和就是sum - x。

所以我们要求的是 `x - (sum - x) = target`

`x = (target + sum) / 2`

- dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法
- dp[0] 为 1。
- 后续遍历

### 代码实现

~~~java
public int findTargetSumWays(int[] nums, int target) {
    int newTarget;
    int sum = Arrays.stream(nums).sum();//x positive (sum -x) negtive
    if (Math.abs(target) > sum) return 0;
    if ((sum + target) % 2 == 1) return 0;
    else {
        newTarget = (sum + target) / 2;
    }
    int[] dp = new int[newTarget + 1];
    dp[0] = 1;
    for (int i = 0; i < nums.length; i++) {
        for (int j = newTarget; j >= nums[i]; j--) {
            dp[j] += dp[j - nums[i]];
        }
    }
    return dp[newTarget];
}
~~~

## 474.一和零

给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。

请你找出并返回 `strs` 的最大子集的长度，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1` 。

如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 **子集** 。

### 思路

0-1背包，但是背包有二维

需要记录每个字符串的0和1的个数

### 代码实现

~~~java
public int findMaxForm(String[] strs, int m, int n) {
    int[][] counts = new int[strs.length][2];//存储0，1的个数
    for (int i = 0; i < strs.length; i++) {
        int zeroNums = 0;
        int oneNums = 0;
        String str = strs[i];
        for (int j = 0; j < str.length(); j++) {
            if (str.charAt(j) == '0') zeroNums++;
            else oneNums++;
        }
        counts[i][0] = zeroNums;
        counts[i][1] = oneNums;
    }
    //不用特别初始化，满足条件才加1
    int[][] dp = new int[m + 1][n + 1];
    for (int[] count : counts) {
        for (int i = m; i >= count[0]; i--) {
            for (int j = n; j >= count[1]; j--) {
                dp[i][j] = Math.max(dp[i][j], dp[i - count[0]][j - count[1]] + 1);
            }
        }
    }
    return dp[m][n];

}
~~~

