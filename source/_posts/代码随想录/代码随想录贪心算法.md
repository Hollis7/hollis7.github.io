---
title: 代码随想录-贪心算法
categories:
- code_Musing
tags:
- greedy
---
<meta name="referrer" content="no-referrer"/>

# 内容

**本节包括：**

- 各种贪心算法题

<!--more-->

## 455.分发饼干

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

**示例 2:**

```
输入: g = [1,2], s = [1,2,3]
输出: 2
解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.
```

### 思路

这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩。

### 代码实现

~~~java
  public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int gPos = g.length - 1;
        int sPos = s.length - 1;
        int count = 0;
        for (; gPos >= 0 && sPos >= 0; gPos--) {
            //饼干能满足孩子胃口
            if (s[sPos] >= g[gPos]) {
                count++;
                sPos--;
            }
        }
        return count;
    }
~~~

## 376. 摆动序列

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

- 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。
- 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

**子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。

### 思路一

分情况讨论：

1. 情况一：上下坡中有平坡
2. 情况二：数组首尾两端
3. 情况三：单调坡中有平坡

#### 情况一：上下坡中有平坡

我们记录峰值的条件应该是： `(preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0)`

#### 情况二：数组首尾两端

我们在计算 `prediff（nums[i] - nums[i-1]）` 和 `curdiff（nums[i+1] - nums[i]）`的时候，至少需要三个数字才能计算，而数组只有两个数字时。result 初始为 1（默认最右面有一个峰值），此时 `curDiff > 0 && preDiff <= 0`，那么 result++（计算了左面的峰值）

#### 情况三：单调坡度有平坡

如果在一个单调坡度上有平坡，例如[1,2,2,2,3,4]

我们只需要在这个坡度摆动变化的时候，更新prediff就行，这样prediff在单调区间有平坡的时候就不会发生变化，造成我们的误判。

### 代码实现

~~~java
  public int wiggleMaxLength(int[] nums) {
        if (nums.length == 1) return 1;
        int preDiff = 0;
        int curDiff = 0;
        int res = 1;
        for (int i = 0; i < nums.length - 1; i++) {
            curDiff = nums[i + 1] - nums[i];
            if ((preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0)) {
                res++;
                //出现拐弯时才更新preDiff
                preDiff = curDiff;
            }
        }
        return res;
    }
~~~

### 思路二

下降=在上升的次数加一，上升=在下降的次数加一

### 代码实现

~~~java
class Solution {
    public int wiggleMaxLength(int[]nums) {
        int down = 1, up = 1;
    for (int i = 1; i < nums.length; i++) {
        if (nums[i] > nums[i - 1])
            up = down + 1;
        else if (nums[i] < nums[i - 1])
            down = up + 1;
    }
    return nums.length == 0 ? 0 : Math.max(down, up);
    }
  }
~~~

## 53. 最大子序和

给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

- 输入: [-2,1,-3,4,-1,2,1,-5,4]
- 输出: 6
- 解释: 连续子数组  [4,-1,2,1] 的和最大，为  6。

### 思路-贪心

遍历 nums，从头开始用 sum累积，如果 count 一旦加上 nums[i]变为负数，那么就应该从 nums[i+1]开始从 0 累积 count 了，因为已经变为负数的 count，只会拖累总和。

### 代码实现

~~~java
public int maxSubArray(int[] nums) {
        int res = Integer.MIN_VALUE;
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            if (sum > res) {// 取区间累计的最大值（相当于不断确定最大子序终止位置）
                res = sum;
            }
            if (sum < 0) {
                sum = 0;
            }
        }
        return res;
    }
~~~

### 思路-动态规划

dp[i]：包括下标i（以nums[i]为结尾）的最大连续子序列和为dp[i]。

递推公式中`dp[i]`依赖于dp[i - 1]的状态，需要从前向后遍历。

~~~java
  dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
~~~

- dp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和
- nums[i]，即：从头开始计算当前连续子序列和

### 代码实现

~~~java
public int maxSubArrayDP(int[] nums) {
    int[] dp = new int[nums.length];
    dp[0] = nums[0];
    int res = nums[0];
    for (int i = 1; i < nums.length; i++) {
        dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
        if (res < dp[i]) {
            res = dp[i];
        }
    }
    return res;
}
~~~

##  122.买卖股票的最佳时机 II

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。**你也可以先购买，然后在 同一天出售。**

返回你能获得的 **最大** 利润。

**示例 1：**

```
输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
     总利润为 4 + 3 = 7 。
```

### 思路-贪心

**如果想到其实最终利润是可以分解的，那么本题就很容易了！**

假如第 0 天买入，第 3 天卖出，那么利润为：prices[3] - prices[0]。

相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。

**此时就是把利润分解为每天为单位的维度，而不是从 0 天到第 3 天整体去考虑！**

那么根据 prices 可以得到每天的利润序列：`(prices[i] - prices[i - 1]).....(prices[1] - prices[0])`。

将每日的利润（正）加起来

### 代码实现

~~~java
public int maxProfit(int[] prices) {
    int profit = 0;
    int[] dailyProfit = new int[prices.length - 1];
    for (int i = 0; i < prices.length - 1; i++) {
        dailyProfit[i] = prices[i + 1] - prices[i];
    }
    for (int i = 0; i < dailyProfit.length; i++) {
        if (dailyProfit[i] > 0) {
            profit += dailyProfit[i];
        }
    }
    return profit;
}
~~~

### 思路-动态规划

- `dp[i][0]` 表示第i天持有股票所得现金。
- `dp[i][1]` 表示第i天不持有股票所得最多现金

`dp[i][0]`

第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：`dp[i - 1][0]`
第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：`dp[i - 1][1] - prices[i]`

`dp[i][1]`

第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：`dp[i - 1][1]`
第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：`prices[i] + dp[i - 1][0]`

### 代码实现

~~~java
 public int maxProfitThroughDp(int[] prices) {
        int days = prices.length;
        int[][] dp = new int[days][2];//第i天的最大利润
        //dp[i][0]代表有股票，dp[i][1]代表没有股票
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < days; i++) {
            dp[i][0] =  Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[days - 1][1];
    }
~~~

## 55. 跳跃游戏

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

### 思路

每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点。

> i 每次移动只能在 cover 的范围内移动，每移动一个元素，cover 得到该元素数值（新的覆盖范围）的补充，让 i 继续移动下去。

### 代码实现

~~~java
public boolean canJump(int[] nums) {
    int cover = 0;
    for (int i = 0; i <= cover; i++) {
        cover = Math.max(cover, i + nums[i]);
        if (cover >= nums.length - 1) return true;
    }
    return false;
}
~~~

## 45.跳跃游戏 II

给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。

每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:

- `0 <= j <= nums[i]` 
- `i + j < n`

返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。

### 思路

要从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最少步数！

**这里需要统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖**。

如果移动下标达到了当前这一步的最大覆盖最远距离了，还没有到终点的话，那么就必须再走一步来增加覆盖范围，直到覆盖范围覆盖了终点。

### 代码实现

~~~java
public int jump(int[] nums) {
    int steps = 0;
    int curMax = 0;
    int nextMax = 0;
    if (nums.length == 1) return 0;
    for (int i = 0; i < nums.length; i++) {
        nextMax = Math.max(nextMax, i + nums[i]);
        if (i == curMax) {
            steps++;
            curMax = nextMax;
            //已经可以跳到数组末尾
            if (nextMax >= nums.length - 1) {
                return steps;
            }
        }
    }
    return steps;
}
~~~

## 1005.K次取反后最大化的数组和

给你一个整数数组 `nums` 和一个整数 `k` ，按以下方法修改该数组：

- 选择某个下标 `i` 并将 `nums[i]` 替换为 `-nums[i]` 。

重复这个过程恰好 `k` 次。可以多次选择同一个下标 `i` 。

以这种方式修改数组后，返回数组 **可能的最大和** 。

### 思路

- 第一步：将数组按照绝对值大小从大到小排序，**注意要按照绝对值的大小**
- 第二步：从前向后遍历，遇到负数将其变为正数，同时K--
- 第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完
- 第四步：求和

### 代码实现

~~~java
 int negCount = 0;
        //数组按照绝对值从大到小排序
        nums = IntStream.of(nums)
                .boxed()
                .sorted((o1, o2) -> Math.abs(o2) - Math.abs(o1))
                .mapToInt(Integer::intValue)
                .toArray();
        for (int i = 0; i < nums.length; i++) {
            if (k > 0 && nums[i] < 0) {
                nums[i] = Math.abs(nums[i]);
                k--;
            }
        }
        if (k % 2 == 1) nums[nums.length - 1] = -nums[nums.length - 1];
        return Arrays.stream(nums).sum();
~~~

### 思路2

1. 先排序，将负数变为正数
2. 若k>0，再次排序，将最小值取反
3. 求和

### 代码实现

~~~java
 public int largestSumAfterKNegations(int[] nums, int k) {
        Arrays.sort(nums);
        //将负数变为正数
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] < 0 && k > 0) {
                nums[i] = -nums[i];
                k--;
            }
        }
        if (k % 2 == 1) {
            Arrays.sort(nums);
            nums[0] = -nums[0];
        }
        return Arrays.stream(nums).sum();

    }
~~~

## 134. 加油站

在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升。

你有一辆油箱容量无限的的汽车，从第 `i` 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。

给定两个整数数组 `gas` 和 `cost` ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 `-1` 。如果存在解，则 **保证** 它是 **唯一** 的。

### 思路

首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明 各个站点的加油站 剩油量`rest[i]`相加一定是大于等于零的。

i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，因为这个区间选择任何一个位置作为起点，到i这里都会断油，那么起始位置从i+1算起，再从0计算curSum。

### 代码实现

~~~java
public int canCompleteCircuit(int[] gas, int[] cost) {
    int len = gas.length;
    int resGas = 0;
    int totalRest = 0;
    int start = 0;
    for (int i = 0; i < len; i++) {
        resGas += gas[i] - cost[i];
        totalRest += gas[i] - cost[i];
        if (resGas < 0) {
            start = i + 1;
            resGas = 0;
        }
    }
    if (totalRest < 0) return -1;
    else return start;
}
~~~

## 135. 分发糖果

`n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

- 每个孩子至少分配到 `1` 个糖果。
- 相邻两个孩子评分更高的孩子会获得更多的糖果。

请你给每个孩子分发糖果，计算并返回需要准备的 **最少糖果数目** 。

示例 2:

- 输入: [1,2,2]
- 输出: 4
- 解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。第三个孩子只得到 1 颗糖果，这已满足上述两个条件。

### 思路

- 一次是从左到右遍历，只比较右边孩子评分比左边大的情况。
- 一次是从右到左遍历，只比较左边孩子评分比右边大的情况。

### 代码实现

~~~java
public int candy(int[] ratings) {
        int[] childCandy = new int[ratings.length];
        Arrays.fill(childCandy, 1);
        //从左往右比较
        for (int i = 1; i < ratings.length; i++) {
            childCandy[i] = (ratings[i] > ratings[i - 1]) ? childCandy[i - 1] + 1 : 1;
        }
        //从后往前比较
        for (int i = ratings.length - 1; i > 0; i--) {
            if (ratings[i - 1] > ratings[i])
                childCandy[i - 1] = Math.max(childCandy[i - 1], childCandy[i] + 1);
        }
        return Arrays.stream(childCandy).sum();
    }
~~~

## 860.柠檬水找零

在柠檬水摊上，每一杯柠檬水的售价为 `5` 美元。顾客排队购买你的产品，（按账单 `bills` 支付的顺序）一次购买一杯。

每位顾客只买一杯柠檬水，然后向你付 `5` 美元、`10` 美元或 `20` 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 `5` 美元。

注意，一开始你手头没有任何零钱。

给你一个整数数组 `bills` ，其中 `bills[i]` 是第 `i` 位顾客付的账。如果你能给每位顾客正确找零，返回 `true` ，否则返回 `false` 。

### 代码实现

在 Java 中，switch 语句通常在匹配到一个 case 后会执行对应的代码块然后跳出 switch 结构。如果删除了 break 语句，即使匹配到一个 case，也会继续执行下一个 case 中的代码，直到遇到 break 语句或者 switch 结束。

~~~java
public boolean lemonadeChange(int[] bills) {
    //0,1分别存5美元和10美元零钱
    int[] coins = new int[2];
    for (int i = 0; i < bills.length; i++) {
        switch (bills[i]) {
            case 20:
                if (coins[1] > 0) {
                    coins[1] -= 1;
                    coins[0] -= 1;
                } else {
                    coins[0] -= 3;
                }

                break;
            case 10:
                coins[0] -= 1;
                coins[1] += 1;
                break;
            case 5:
                coins[0] += 1;
                break;
        }
        if (coins[0] < 0 || coins[1] < 0) {
            return false;
        }
    }
    return true;
}
~~~

## 406.根据身高重建队列

假设有打乱顺序的一群人站成一个队列，数组 `people` 表示队列中一些人的属性（不一定按顺序）。每个 `people[i] = [hi, ki]` 表示第 `i` 个人的身高为 `hi` ，前面 **正好** 有 `ki` 个身高大于或等于 `hi` 的人。

请你重新构造并返回输入数组 `people` 所表示的队列。返回的队列应该格式化为数组 `queue` ，其中 `queue[j] = [hj, kj]` 是队列中第 `j` 个人的属性（`queue[0]` 是排在队列前面的人）

**示例 1：**

```
输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
解释：
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
```

### 思路

1. 先按照身高`h`从大到小排序，注意身高相同，那么就按照`k`从小到大排序
2. 遍历，根据`ki`插入对应的队列位置
3. 注意，最后序列转化为数组的方式

### 代码实现

~~~java
public class ReconstructQueue {
    public int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people, (a, b) -> {
            if (a[0] == b[0]) return a[1] - b[1];//身高相同，从小到达排序
            return b[0] - a[0];//整体升高从大到小
        });
        LinkedList<int[]> queue = new LinkedList<>();
        for (int i = 0; i < people.length; i++) {
            queue.add(people[i][1], people[i]);
        }
        return queue.toArray(new int[people.length][]);
    }
}
~~~

## 452. 用最少数量的箭引爆气球

有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 `points` ，其中`points[i] = [x_start, x_end]` 表示水平直径在 `xstart` 和 `xend`之间的气球。你不知道气球的确切 y 坐标。

一支弓箭可以沿着 x 轴从不同点 **完全垂直** 地射出。在坐标 `x` 处射出一支箭，若有一个气球的直径的开始和结束坐标为 `x_start`，`x_end`， 且满足  `x_start ≤ x ≤ x_end`，则该气球会被 **引爆** 。可以射出的弓箭的数量 **没有限制** 。 弓箭一旦被射出之后，可以无限地前进。

给你一个数组 `points` ，*返回引爆所有气球所必须射出的 **最小** 弓箭数* 。

**示例 1：**

```
输入：points = [[10,16],[2,8],[1,6],[7,12]]
输出：2
解释：气球可以用2支箭来爆破:
-在x = 6处射出箭，击破气球[2,8]和[1,6]。
-在x = 11处发射箭，击破气球[10,16]和[7,12]。
```

`-231 <= xstart < xend <= 231 - 1`

### 思路

既然按照起始位置排序，那么就从前向后遍历气球数组，靠左尽可能让气球重复。

从前向后遍历遇到重叠的气球了怎么办？

**如果气球重叠了，重叠气球中右边边界的最小值 之前的区间一定需要一个弓箭**。

> 为了避免数据溢出，要考虑Integer.compare(a[0], b[0]))进行比较，它不是直接做减法运算，而是比较两个数的大小，因此不会发生溢出。
>
> 一定要更新重叠气球的最小值

### 代码实现

~~~java
public int findMinArrowShots(int[][] points) {
    Arrays.sort(points, (a, b) -> Integer.compare(a[0], b[0]));
    //至少需要一只箭，避免最后的一组会落空
    int numArrows = 1;
    for (int i = 1; i < points.length; i++) {
        if (points[i][0] > points[i - 1][1]) {
            numArrows++;
        } else {
            points[i][1] = Math.min(points[i][1], points[i - 1][1]); // 更新重叠气球最小右边界
        }
    }
    return numArrows;
}
~~~

## 435. 无重叠区间

给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。

### 思路

找到所有重叠的区间，然后用总区间减去重叠区间数

### 代码实现

~~~java
public class EraseOverlapIntervals {
    public int eraseOverlapIntervals(int[][] intervals) {
        int crossInterval = 1;//记录重叠的区间组总数
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
        for (int i = 1; i < intervals.length; i++) {
            if (intervals[i][0] >= intervals[i - 1][1]) {
                crossInterval++;
            } else {
                intervals[i][1] = Math.min(intervals[i][1], intervals[i - 1][1]);
            }
        }
        return intervals.length - crossInterval;
    }
}
~~~

## 763.划分字母区间

给你一个字符串 `s` 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。

注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s` 。

返回一个表示每个字符串片段的长度的列表。

### 思路

将每个字母的最后出现的位置记录下来，不断更新局部区间字母出现最大值，直到这个最大值等于当前索引，这是由于`ababcbaca`中`a`最后出现的位置大于`b`，应该让`a`包含`b`，同时用last记录上个区间的位置，方便计算字符串长度。

### 代码实现

~~~java
public List<Integer> partitionLabels(String s) {
    int[] farIdx = new int[26];
    List<Integer> res = new ArrayList<>();
    for (int i = 0; i < s.length(); i++) {
        farIdx[s.charAt(i) - 'a'] = i;
    }
    int last = -1;
    int far = 0;
    for (int i = 0; i < s.length(); i++) {
        far = Math.max(far, farIdx[s.charAt(i) - 'a']);
        if (far == i) {
            res.add(i - last);
            last = i;
        }
    }
    return res;
}
~~~

## 56. 合并区间

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。

**示例 1：**

```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

### 思路

先排序，让所有的相邻区间尽可能的重叠在一起，按左边界，或者右边界排序都可以，处理逻辑稍有不同。

`intervals[i][0] > r`，表明当前区间不能和前面的区间合并

合并区间后左边界和右边界，作为一个新的区间，加入到result数组里就可以了

### 代码实现

~~~java
public int[][] merge(int[][] intervals) {
    List<int[]> res = new ArrayList<int[]>();
    Arrays.sort(intervals, (a, b) -> {
        if (a[0] == b[0]) return a[1] - b[1];
        return a[0] - b[0];
    });
    int l = intervals[0][0];
    int r = intervals[0][1];
    for (int i = 1; i < intervals.length; i++) {
        if (intervals[i][0] > r) {
            res.add(new int[]{l, r});
            l = intervals[i][0];
            r = intervals[i][1];
        } else {
            r = Math.max(r, intervals[i][1]);
        }
    }
    res.add(new int[]{l, r});
    return res.toArray(new int[res.size()][]);

}
~~~

## 738.单调递增的数字

当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是**单调递增**的。

给定一个整数 `n` ，返回 *小于或等于 `n` 的最大数字，且数字呈 **单调递增*** 。

**示例 1:**

```
输入: n = 10
输出: 9
```

**示例 2:**

```
输入: n = 1234
输出: 1234
```

**示例 3:**

```
输入: n = 332
输出: 299
```

### 思路

用一个flag来标记从哪里开始赋值9

遇到`strNum[i - 1] > strNum[i]`的情况，让`strNum[i - 1]`减一，`flag`设为`i`

### 代码实现

~~~java
public int monotoneIncreasingDigits(int n) {
    String s = String.valueOf(n);
    char[] array = s.toCharArray();
    int start = s.length();
    for (int i = array.length - 1; i > 0; i--) {
        if (array[i - 1] > array[i]) {
            start = i;
            array[i - 1]--;
        }
    }
    for (int i = start; i < array.length; i++) {
        array[i] = '9';
    }
    return Integer.parseInt(String.valueOf(array));
}
~~~

## 968.监控二叉树

给定一个二叉树，我们在树的节点上安装摄像头。

节点上的每个摄影头都可以监视**其父对象、自身及其直接子对象。**

计算监控树的所有节点所需的最小摄像头数量。

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_01.png)

```
输入：[0,0,null,0,0]
输出：1
解释：如图所示，一台摄像头足以监控所有节点。
```

### 思路

后续遍历

**局部最优：让叶子节点的父节点安摄像头，所用摄像头最少，整体最优：全部摄像头数量所用最少！**

我们分别有三个数字来表示：

- 0：该节点无覆盖
- 1：本节点有摄像头
- 2：本节点有覆盖

**空节点的状态只能是有覆盖，这样就可以在叶子节点的父节点放摄像头了**

**递推关系：**

终止条件应该是遇到了空节点，此时应该返回2（有覆盖）

**单层逻辑：**

- 情况1：左右节点都有覆盖

左孩子有覆盖，右孩子有覆盖，那么此时中间节点应该就是无覆盖的状态了。

- 情况2：左右节点至少有一个无覆盖的情况

此时摄像头的数量要加一，并且return 1，代表中间节点放摄像头。

如果是以下情况，其实就是 左右孩子节点有一个有摄像头了，那么其父节点就应该是2（覆盖的状态）

- 情况3：左右节点至少有一个有摄像头

如果是以下情况，其实就是 左右孩子节点有一个有摄像头了，那么其父节点就应该是2（覆盖的状态）

- 情况4：头结点没有覆盖

以上都处理完了，递归结束之后，可能头结点 还有一个无覆盖的情况

### 代码实现

~~~java
public class MinCameraCover {
    int res = 0;

    public int minCameraCover(TreeNode root) {
        if (traversal(root) == 0) {
            ++res;
        }
        return res;
    }

    /**
     * 0：该节点无覆盖
     * 1：本节点有摄像头
     * 2：本节点有覆盖
     *
     * @param root
     * @return
     */
    public int traversal(TreeNode root) {
        if (root == null) return 2;
        int left = traversal(root.left);
        int right = traversal(root.right);
        if (left == 2 && right == 2) {
            return 0;
        } else if (left == 0 || right == 0) {//一定是父节点覆盖子节点优先，2优于3
            ++res;
            return 1;
        } else if (left == 1 || right == 1) {
            return 2;
        } else {//不会走到这里
            return -1;
        }
    }
}
~~~

